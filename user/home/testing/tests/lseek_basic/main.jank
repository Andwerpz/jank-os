#include <iostream>;
#include <assert>;
#include <dirent>;
#include <string>;

u64 count_dir_children(u8* path) {
    dirstream* dir = opendir(path);
    u64 dircnt = $u64 0;
    while(1) {
        dirent* dent = readdir(dir);
        if(dir->eof()) {
            break;
        }
        if($void* dent == nullptr) {
            //error reading
            break;
        }
        string name = new string($u8* @(dent->d_name));
        if(name == "." || name == "..") continue;
        dircnt ++;
    }
    closedir(dir);
    return dircnt;
}

void mkdir(u8* path) {
    if(sys_mkdir(path, $mode_t 0o755)) {
        cout << "mkdir failed\n";
        sys_exit(1);
    }
}

void rmdir(u8* path) {
    if(sys_rmdir(path)) {
        cout << "rmdir failed\n";
        sys_exit(1);
    }
}

string readfile(u8* path) {
    i32 fd = sys_open(path, O_RDONLY, $mode_t 0);
    assert(fd >= 0, "readfile() : failed to open file");

    istream fin = new istream(fd);
    string contents;
    u8 c = fin.next_char();
    while(!fin.eof()) {
        if(fin.bad()) {
            cout << "readfile : error reading file\n";
            sys_exit(1);
        }
        contents.push_back(c);
        c = fin.next_char();
    }
    sys_close(fd);

    return contents;
}

void writefile(u8* path, i32 flags, u8* str) {
    i32 fd = sys_open(path, O_WRONLY | flags, $mode_t 0);
    assert(fd >= 0, "writefile() : failed to open file");

    ostream fout = new ostream(fd);
    fout << str;
    sys_close(fd);
}

void test_seek_set() {
    mkdir("test_seek_set");

    i32 fd = sys_open("test_seek_set/a.txt", O_CREAT | O_WRONLY, $mode_t 0o755);
    assert(fd >= 0, "test_seek_set() : this should succeed");

    u8* str1 = "0123456789";
    sys_write(fd, $void* str1, strlen(str1));   // file: 0123456789

    u8* str2 = "aaa";
    sys_lseek(fd, $i64 0x1, SEEK_SET);
    sys_write(fd, $void* str2, strlen(str2));   // file: 0aaa456789

    u8* str3 = "bbbb";
    sys_lseek(fd, $i64 0x7, SEEK_SET);
    sys_write(fd, $void* str3, strlen(str3));   // file: 0aaa456bbbb

    u8* str4 = "ccccc";
    sys_lseek(fd, $i64 0x3, SEEK_SET);
    sys_write(fd, $void* str4, strlen(str4));   // file: 0aacccccbbb

    sys_close(fd);

    u8* expected = "0aacccccbbb";
    string contents = readfile("test_seek_set/a.txt");
    assert(strcmp(expected, contents.jstr()) == 0, "test_seek_set() : strings should match");

    cout << "test seek_set passed\n";
}

void test_seek_cur() {
    mkdir("test_seek_cur");
    
    i32 fd = sys_open("test_seek_cur/a.txt", O_CREAT | O_WRONLY, $mode_t 0o755);
    assert(fd >= 0, "test_seek_cur() : this should succeed");

    u8* base = "0123456789";
    sys_write(fd, $void* base, strlen(base));      // file: 0123456789

    u8* s1 = "abc";
    sys_lseek(fd, $i64 -5, SEEK_CUR);              // offset: 5
    sys_write(fd, $void* s1, strlen(s1));          // file: 01234abc89

    u8* s2 = "XYZ";
    sys_lseek(fd, $i64 2, SEEK_CUR);               // offset: 10
    sys_write(fd, $void* s2, strlen(s2));          // file: 01234abc89XYZ

    sys_close(fd);

    u8* expected = "01234abc89XYZ";
    string contents = readfile("test_seek_cur/a.txt");
    assert(strcmp(expected, contents.jstr()) == 0, "test_seek_cur() : strings should match");

    cout << "test seek_cur passed\n";
}

void test_seek_end() {
    mkdir("test_seek_end");

    i32 fd = sys_open("test_seek_end/a.txt", O_CREAT | O_WRONLY, $mode_t 0o755);
    assert(fd >= 0, "test_seek_end() : this should succeed");

    u8* base = "0123456789";
    sys_write(fd, $void* base, strlen(base));      // file: 0123456789

    // Seek to end and append
    u8* s1 = "XYZ";
    sys_lseek(fd, $i64 0, SEEK_END);               // offset: 10
    sys_write(fd, $void* s1, strlen(s1));          // file: 0123456789XYZ

    // Now seek 5 bytes before end (13 - 5 = 8) and overwrite a single byte
    u8* s2 = "Q";
    sys_lseek(fd, $i64 -5, SEEK_END);              // offset: 8
    sys_write(fd, $void* s2, strlen(s2));          // file: 01234567Q9XYZ

    sys_close(fd);

    u8* expected = "01234567Q9XYZ";
    string contents = readfile("test_seek_end/a.txt");
    assert(strcmp(expected, contents.jstr()) == 0, "test_seek_end() : strings should match");

    cout << "test seek_end passed\n";
}

//makes sure that O_APPEND always moves file offset to EOF before every write
void test_append() {
    mkdir("test_append");

    i32 fd = sys_open("test_append/a.txt", O_CREAT | O_WRONLY | O_APPEND, $mode_t 0o755);
    assert(fd >= 0, "test_append() : open should succeed");

    u8* s1 = "AAAA";
    sys_write(fd, $void* s1, strlen(s1));   // file = "AAAA"

    u8* s2 = "BBBB";
    sys_lseek(fd, $i64 0, SEEK_SET);   // should be ignored for write position with O_APPEND
    sys_write(fd, $void* s2, strlen(s2));   // file = "AAAABBBB"

    u8* s3 = "CC";
    sys_lseek(fd, $i64 2, SEEK_SET);   
    sys_write(fd, $void* s3, strlen(s3));   // file = "AAAABBBBCC"

    sys_close(fd);

    u8* expected = "AAAABBBBCC";
    string contents = readfile("test_append/a.txt");
    assert(strcmp(expected, contents.jstr()) == 0, "test_append() : O_APPEND should always append at EOF");

    cout << "test append passed\n";
}

//make sure that negative offset fails
void test_negative() {
    mkdir("test_negative");

    i32 fd = sys_open("test_negative/a.txt", O_CREAT | O_WRONLY, $mode_t 0o755);
    assert(fd >= 0, "test_negative() : open should succeed");

    u8* s1 = "abcde";
    sys_write(fd, $void* s1, strlen(s1));

    i64 stat1 = sys_lseek(fd, $i64 -1, SEEK_SET);
    assert(stat1 < $i64 0, "test_negative() : this should fail");

    i64 stat2 = sys_lseek(fd, $i64 -6, SEEK_CUR);
    assert(stat2 < $i64 0, "test_negative() : this should fail");

    i64 stat3 = sys_lseek(fd, $i64 -5, SEEK_END);
    assert(stat3 == $i64 0, "test_negative() : this should succeed");

    i64 stat4 = sys_lseek(fd, $i64 -1, SEEK_CUR);
    assert(stat4 < $i64 0, "test_negative() : this should fail");

    i64 stat5 = sys_lseek(fd, $i64 -6, SEEK_END);
    assert(stat5 < $i64 0, "test_negative() : this should fail");
    
    sys_close(fd);

    cout << "test negative passed\n";
}

//make sure that lseek that fails doesn't change offset
void test_fail() {
    mkdir("test_fail");

    i32 fd = sys_open("test_fail/a.txt", O_CREAT | O_WRONLY, $mode_t 0o755);
    assert(fd >= 0, "test_fail() : open should succeed");

    u8* s1 = "abcde";
    sys_write(fd, $void* s1, strlen(s1));

    i64 stat1 = sys_lseek(fd, $i64 2, SEEK_SET);
    assert(stat1 == $i64 2, "test_fail() : this should succeed");

    i64 stat2 = sys_lseek(fd, $i64 -1, SEEK_SET);
    assert(stat2 < $i64 0, "test_fail() : this should fail");

    i64 stat3 = sys_lseek(fd, $i64 0, SEEK_CUR);
    assert(stat3 == $i64 2, "test_fail() : this should succeed");

    sys_close(fd);

    cout << "test fail passed\n";
}

i32 main(u64 argc, u8** argv) {
    test_seek_set();
    test_seek_cur();
    test_seek_end();
    test_append();
    test_negative();
    test_fail();
    
    cout << "tests passed\n";
    return 0;
}