#include <iostream>;
#include <assert>;
#include <dirent>;

u64 count_dir_children(u8* path) {
    dirstream* dir = opendir(path);
    u64 dircnt = $u64 0;
    while(1) {
        dirent* dent = readdir(dir);
        if(dir->eof()) {
            break;
        }
        if($void* dent == nullptr) {
            //error reading
            break;
        }
        string name = new string($u8* @(dent->d_name));
        if(name == "." || name == "..") continue;
        dircnt ++;
    }
    closedir(dir);
    return dircnt;
}

void mkdir(u8* path) {
    if(sys_mkdir(path, $mode_t 0o755)) {
        cout << "mkdir failed\n";
        sys_exit(1);
    }
}

void rmdir(u8* path) {
    if(sys_rmdir(path)) {
        cout << "rmdir failed\n";
        sys_exit(1);
    }
}

void test_many() {
    mkdir("testdir");

    u64 n = $u64 64;
    u8* buf = $u8* malloc(0x1000);
    memcpy($void* buf, $void* "testdir/", $u64 8);
    buf[8 + 16] = '\0';
    for(u64 i = 0x0; i < n; i++) {
        u64 mask = 0b1111;
        for(i32 j = 15; j >= 0; j--){
            u64 dig = (i & (mask << ($u64 j * $u64 4))) >> ($u64 j * $u64 4);
            u8 c;
            if(dig < $u64 10) c = '0' + $u8 dig;
            else c = 'a' + $u8 dig - $u8 10;
            buf[8 + 15 - j] = c;
        }

        mkdir(buf);
    }
    
    u64 dircnt = count_dir_children("./testdir");
    assert(dircnt == n);

    memcpy($void* buf, $void* "testdir/", $u64 8);
    buf[8 + 16] = '\0';
    for(u64 i = n / 0x2; i < n; i++) {
        u64 mask = 0b1111;
        for(i32 j = 15; j >= 0; j--){
            u64 dig = (i & (mask << ($u64 j * $u64 4))) >> ($u64 j * $u64 4);
            u8 c;
            if(dig < $u64 10) c = '0' + $u8 dig;
            else c = 'a' + $u8 dig - $u8 10;
            buf[8 + 15 - j] = c;
        }

        rmdir(buf);
    }

    dircnt = count_dir_children("./testdir");
    assert(dircnt == n / 0x2);

    memcpy($void* buf, $void* "testdir/", $u64 8);
    buf[8 + 16] = '\0';
    for(u64 i = n / 0x2; i < n; i++) {
        u64 mask = 0b1111;
        for(i32 j = 15; j >= 0; j--){
            u64 dig = (i & (mask << ($u64 j * $u64 4))) >> ($u64 j * $u64 4);
            u8 c;
            if(dig < $u64 10) c = '0' + $u8 dig;
            else c = 'a' + $u8 dig - $u8 10;
            buf[8 + 15 - j] = c;
        }

        mkdir(buf);
    }

    dircnt = count_dir_children("./testdir");
    assert(dircnt == n);

    memcpy($void* buf, $void* "testdir/", $u64 8);
    buf[8 + 16] = '\0';
    for(u64 i = 0x0; i < n; i++) {
        u64 mask = 0b1111;
        for(i32 j = 15; j >= 0; j--){
            u64 dig = (i & (mask << ($u64 j * $u64 4))) >> ($u64 j * $u64 4);
            u8 c;
            if(dig < $u64 10) c = '0' + $u8 dig;
            else c = 'a' + $u8 dig - $u8 10;
            buf[8 + 15 - j] = c;
        }

        rmdir(buf);
    }

    dircnt = count_dir_children("./testdir");
    assert(dircnt == 0x0);

    free($void* buf, 0x1000);

    rmdir("testdir");
    cout << "test many passed\n";
}

void test_many2() {
    mkdir("testdir");

    u64 n = $u64 64;
    u8* buf = $u8* malloc(0x1000);
    memcpy($void* buf, $void* "testdir/", $u64 8);
    buf[8 + 16] = '\0';
    for(u64 i = 0x0; i < n; i++) {
        u64 mask = 0b1111;
        for(i32 j = 15; j >= 0; j--){
            u64 dig = (i & (mask << ($u64 j * $u64 4))) >> ($u64 j * $u64 4);
            u8 c;
            if(dig < $u64 10) c = '0' + $u8 dig;
            else c = 'a' + $u8 dig - $u8 10;
            buf[8 + 15 - j] = c;
        }

        mkdir(buf);
    }
    
    u64 dircnt = count_dir_children("./testdir");
    assert(dircnt == n);

    memcpy($void* buf, $void* "testdir/", $u64 8);
    buf[8 + 16] = '\0';
    for(u64 i = 0x0; i < n / 0x2; i++) {
        u64 mask = 0b1111;
        for(i32 j = 15; j >= 0; j--){
            u64 dig = (i & (mask << ($u64 j * $u64 4))) >> ($u64 j * $u64 4);
            u8 c;
            if(dig < $u64 10) c = '0' + $u8 dig;
            else c = 'a' + $u8 dig - $u8 10;
            buf[8 + 15 - j] = c;
        }

        rmdir(buf);
    }

    dircnt = count_dir_children("./testdir");
    assert(dircnt == n / 0x2);

    memcpy($void* buf, $void* "testdir/", $u64 8);
    buf[8 + 16] = '\0';
    for(u64 i = 0x0; i < n / 0x2; i++) {
        u64 mask = 0b1111;
        for(i32 j = 15; j >= 0; j--){
            u64 dig = (i & (mask << ($u64 j * $u64 4))) >> ($u64 j * $u64 4);
            u8 c;
            if(dig < $u64 10) c = '0' + $u8 dig;
            else c = 'a' + $u8 dig - $u8 10;
            buf[8 + 15 - j] = c;
        }

        mkdir(buf);
    }

    dircnt = count_dir_children("./testdir");
    assert(dircnt == n);

    memcpy($void* buf, $void* "testdir/", $u64 8);
    buf[8 + 16] = '\0';
    for(u64 i = 0x0; i < n; i++) {
        u64 mask = 0b1111;
        for(i32 j = 15; j >= 0; j--){
            u64 dig = (i & (mask << ($u64 j * $u64 4))) >> ($u64 j * $u64 4);
            u8 c;
            if(dig < $u64 10) c = '0' + $u8 dig;
            else c = 'a' + $u8 dig - $u8 10;
            buf[8 + 15 - j] = c;
        }

        rmdir(buf);
    }

    dircnt = count_dir_children("./testdir");
    assert(dircnt == 0x0);

    free($void* buf, 0x1000);

    rmdir("testdir");
    cout << "test many2 passed\n";
}

void test_nested() {
    mkdir("testdir");

    mkdir("testdir/a");
    mkdir("testdir/a/b");
    mkdir("testdir/a/b/c");

    rmdir("testdir/a/b/c");
    rmdir("testdir/a/b");
    rmdir("testdir/a");

    rmdir("testdir");
    cout << "test nested passed\n";
}

void test_fail() {
    mkdir("testdir");

    mkdir("testdir/a");

    //this should fail
    if(!sys_rmdir("testdir")) {
        cout << "this should\'ve failed\n";
        sys_exit(1);
    }

    rmdir("testdir/a");

    rmdir("testdir");
    cout << "test fail passed\n";
}

i32 main(u64 argc, u8** argv) {
    test_many();
    test_many2();
    test_nested();
    test_fail();
    
    cout << "tests passed\n";
    return 0;
}