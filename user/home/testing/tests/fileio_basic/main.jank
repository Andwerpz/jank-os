#include <iostream>;
#include <assert>;
#include <dirent>;
#include <string>;

u64 count_dir_children(u8* path) {
    dirstream* dir = opendir(path);
    u64 dircnt = $u64 0;
    while(1) {
        dirent* dent = readdir(dir);
        if(dir->eof()) {
            break;
        }
        if($void* dent == nullptr) {
            //error reading
            break;
        }
        string name = new string($u8* @(dent->d_name));
        if(name == "." || name == "..") continue;
        dircnt ++;
    }
    closedir(dir);
    return dircnt;
}

void mkdir(u8* path) {
    if(sys_mkdir(path, $mode_t 0o755)) {
        cout << "mkdir failed\n";
        sys_exit(1);
    }
}

void rmdir(u8* path) {
    if(sys_rmdir(path)) {
        cout << "rmdir failed\n";
        sys_exit(1);
    }
}

string readfile(u8* path) {
    i32 fd = sys_open(path, O_RDONLY, $mode_t 0);
    assert(fd >= 0, "readfile() : failed to open file");

    istream fin = new istream(fd);
    string contents;
    u8 c = fin.next_char();
    while(!fin.eof()) {
        if(fin.bad()) {
            cout << "readfile : error reading file\n";
            sys_exit(1);
        }
        contents.push_back(c);
        c = fin.next_char();
    }
    sys_close(fd);

    return contents;
}

void writefile(u8* path, i32 flags, u8* str) {
    i32 fd = sys_open(path, O_WRONLY | flags, $mode_t 0);
    assert(fd >= 0, "writefile() : failed to open file");

    ostream fout = new ostream(fd);
    fout << str;
    fout.flush();
    sys_close(fd);
}

void test_basic() {
    mkdir("test_basic");

    i32 fd = sys_open("test_basic/a.txt", O_CREAT | O_WRONLY, $mode_t 0o755);
    sys_close(fd);

    cout << "test basic passed\n";
}

void test_readback() {
    mkdir("test_readback");

    i32 fd = sys_open("test_readback/a.txt", O_CREAT | O_WRONLY, $mode_t 0o755);
    ostream fout = new ostream(fd);
    string str = new string("testing testing 123");
    fout << str;
    fout.flush();
    sys_close(fd);

    string fstr = readfile("test_readback/a.txt");
    assert(str == fstr, "test_readback() : strings should match");

    cout << "test readback passed\n";
}

void test_large() {
    mkdir("test_large");

    string str = new string("bello, this is a very long string. uhh, idk what else to put here lmao");

    i32 fd = sys_open("test_large/a.txt", O_CREAT | O_WRONLY, $mode_t 0o755);
    assert(fd >= 0, "test_large() : this should succeed");
    ostream fout = new ostream(fd);
    for(u64 i = 0x0; i < 0x100; i++) {
        fout << str << "\n";
    }
    fout.flush();
    sys_close(fd);

    i32 fd2 = sys_open("test_large/a.txt", O_RDONLY, $mode_t 0);
    istream fin = new istream(fd2);
    for(u64 i = 0x0; i < 0x100; i++) {
        string x = fin.next_line();
        assert(x == str, "test_large() : strings should match");
    }
    sys_close(fd2);

    cout << "test large passed\n";
}

void test_unlink() {
    mkdir("test_unlink");

    //this should succeed
    i32 fd = sys_open("test_unlink/a.txt", O_CREAT | O_WRONLY | O_EXCL, $mode_t 0o755);
    assert(fd >= 0, "test_unlink() : this should succeed 1");
    sys_close(fd);

    //remove a.txt
    sys_unlink("test_unlink/a.txt");

    //this should succeed
    i32 fd2 = sys_open("test_unlink/a.txt", O_CREAT | O_WRONLY | O_EXCL, $mode_t 0o755);
    assert(fd2 >= 0, "test_unlink() : this should succeed 2");
    sys_close(fd2);

    cout << "test unlink passed\n";
}

void test_fail() {
    mkdir("test_fail");

    //this should succeed
    i32 fd = sys_open("test_fail/a.txt", O_CREAT | O_WRONLY | O_EXCL, $mode_t 0o755);
    assert(fd >= 0, "test_fail() : this should succeed 1");
    sys_close(fd);

    //this should fail
    i32 fd2 = sys_open("test_fail/a.txt", O_CREAT | O_WRONLY | O_EXCL, $mode_t 0o755);
    assert(fd2 < 0, "test_fail() : this should fail, O_EXCL expects file to not exist");

    //this should succeed
    i32 fd3 = sys_open("test_fail/b.txt", O_CREAT | O_WRONLY | O_EXCL, $mode_t 0o755);
    assert(fd3 >= 0, "test_fail() : this should succeed 2");
    sys_close(fd3);

    cout << "test fail passed\n";
}

void test_trunc() {
    mkdir("test_trunc");
    
    i32 fd = sys_open("test_trunc/a.txt", O_CREAT | O_WRONLY | O_TRUNC, $mode_t 0o755);
    assert(fd >= 0, "test_trunc() : this should succeed");
    sys_close(fd);

    u8* short = "short string";
    u8* long = "longer string bla bla bla";
    writefile("test_trunc/a.txt", O_TRUNC, short);
    writefile("test_trunc/a.txt", O_TRUNC, long);

    string fstr = readfile("test_trunc/a.txt");
    assert(strcmp(fstr.jstr(), long) == 0, "test_trunc() : long string should completely overwrite short");

    writefile("test_trunc/a.txt", O_TRUNC, short);
    fstr = readfile("test_trunc/a.txt");
    assert(strcmp(fstr.jstr(), short) == 0, "test_trunc() : short string should completely overwrite long");

    cout << "test trunc passed\n";
}

i32 main(u64 argc, u8** argv) {
    test_basic();
    test_readback();
    test_large();
    test_unlink();
    test_fail();
    test_trunc();
    
    cout << "tests passed\n";
    return 0;
}