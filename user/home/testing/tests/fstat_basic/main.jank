#include "./src/file_utils.jank";

void test_file() {
    mkchdir("test_file");

    i32 fd = sys_open("a.txt", O_CREAT | O_WRONLY, $mode_t 0o755);
    assert(fd >= 0, "test_file() : file should create");
    stat* st1 = $stat* malloc(sizeof(stat));
    if(sys_fstat(fd, st1)) assert(0, "test_file() : this should succeed");
    assert((st1->st_mode & S_IFMT) == S_IFREG, "test_file() : should be regular file");
    free($void* st1, sizeof(stat));
    sys_close(fd);

    stat* st2 = $stat* malloc(sizeof(stat));
    if(sys_stat("./a.txt", st2)) assert(0, "test_file() : this should succeed");
    assert((st2->st_mode & S_IFMT) == S_IFREG, "test_file() : should be regular file");
    free($void* st2, sizeof(stat));

    exdir();
    cout << "test file passed\n";
}

void test_dir() {
    mkchdir("test_dir");

    mkdir("a");
    
    i32 fd = sys_open("./a", O_RDONLY | O_DIRECTORY, $mode_t 0);
    assert(fd >= 0, "test_dir() : dir should open");
    stat* st1 = $stat* malloc(sizeof(stat));
    if(sys_fstat(fd, st1)) assert(0, "test_dir() : this should succeed");
    assert((st1->st_mode & S_IFMT) == S_IFDIR, "test_dir() : should be directory");
    free($void* st1, sizeof(stat));
    sys_close(fd);

    stat* st2 = $stat* malloc(sizeof(stat));
    if(sys_stat("./a", st2)) assert(0, "test_dir() : this should succeed");
    assert((st2->st_mode & S_IFMT) == S_IFDIR, "test_dir() : should be directory");
    free($void* st2, sizeof(stat));

    exdir();
    cout << "test dir passed\n";
}

void test_pipe() {
    mkchdir("test_pipe");

    i32[2]* fds = $i32[2]* malloc(sizeof(i32[2]));
    if(sys_pipe(fds)) assert(0, "test_pipe() : pipe should create");
    assert((*fds)[0] >= 0, "test_pipe() : read end should be valid");
    assert((*fds)[1] >= 0, "test_pipe() : write end should be valid");

    stat* st1 = $stat* malloc(sizeof(stat));
    if(sys_fstat((*fds)[0], st1)) assert(0, "test_pipe() : this should succeed");
    assert((st1->st_mode & S_IFMT) == S_IFIFO, "test_pipe() : should be fifo");
    free($void* st1, sizeof(stat));

    stat* st2 = $stat* malloc(sizeof(stat));
    if(sys_fstat((*fds)[1], st2)) assert(0, "test_pipe() : this should succeed");
    assert((st2->st_mode & S_IFMT) == S_IFIFO, "test_pipe() : should be fifo");
    free($void* st2, sizeof(stat));

    exdir();
    cout << "test pipe passed\n";
}

void test_fail() {
    mkchdir("test_fail");

    stat* buf = $stat* malloc(sizeof(stat));

    //ensure that fstat on fd that's not open fails
    i32 fd = sys_open("./a", O_CREAT | O_RDONLY, $mode_t 0o755);
    assert(fd >= 0, "test_fail() : this should succeed");
    sys_close(fd);
    if(sys_fstat(fd, buf) == 0) assert(0, "test_fail() : this should fail");

    //ensure that fstat on invalid fd fails
    if(sys_fstat(-1, buf) == 0) assert(0, "test_fail() : this should fail");

    //ensure that stat on invalid path fails
    if(sys_stat("./b", buf) == 0) assert(0, "test_fail() : this should fail");

    free($void* buf, sizeof(stat));

    exdir();
    cout << "test fail passed\n";
}

i32 main(u64 argc, u8** argv) {
    test_file();
    test_dir();
    test_pipe();
    test_fail();
    
    cout << "tests passed\n";
    return 0;
}