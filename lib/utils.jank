
[__GLOBAL_FIRST__] u32 EFER_MSR             = $u32 0xc0000080;
[__GLOBAL_FIRST__] u32 STAR_MSR             = $u32 0xc0000081;
[__GLOBAL_FIRST__] u32 LSTAR_MSR            = $u32 0xc0000082;
[__GLOBAL_FIRST__] u32 FMASK_MSR            = $u32 0xc0000084;  //auto clear RFLAGS bits on syscall
[__GLOBAL_FIRST__] u32 GS_BASE_MSR          = $u32 0xc0000101;  //swapgs swaps this and KERNEL_GS_BASE
[__GLOBAL_FIRST__] u32 KERNEL_GS_BASE_MSR   = $u32 0xc0000102;

void wrmsr(u32 reg, u64 val) {
    u32 low = $u32 val;
    u32 high = $u32 (val >> $u64 32);
    asm!("movl {reg}, %ecx");
    asm!("movl {low}, %eax");
    asm!("movl {high}, %edx");
    asm!("wrmsr");
}

u64 rdmsr(u32 reg) {
    u32 low;
    u32 high;
    asm!("movl {reg}, %ecx");   
    asm!("rdmsr");              
    asm!("movl %eax, {low}");
    asm!("movl %edx, {high}");
    return ($u64 high << $u64 32) | ($u64 low);
}

void outb(u16 port, u8 val) {
    asm!("movw {port}, %dx");
    asm!("movb {val}, %al");
    asm!("outb %al, %dx");
}

void outw(u16 port, u16 val) {
    asm!("movw {port}, %dx");
    asm!("movw {val}, %ax");
    asm!("outw %ax, %dx");
}

void outl(u16 port, u32 val) {
    asm!("movw {port}, %dx");
    asm!("movl {val}, %eax");
    asm!("outl %eax, %dx");
}

u8 inb(u16 port) {
    u8 ret;
    asm!("movw {port}, %dx");
    asm!("inb %dx, %al");
    asm!("movb %al, {ret}");
    return ret;
}

u32 inl(u16 port) {
    u32 ret;
    asm!("movw {port}, %dx");
    asm!("inl %dx, %eax");
    asm!("movl %eax, {ret}");
    return ret;
}

//prints 16 separated bytes on a line
template<T>
void hexdump(T* _buf, u64 amt_bytes) {
    u8* buf = $u8* _buf;
    for(u64 i = 0x1; i <= amt_bytes; i++){
        u64 low = ($u64 buf[i - 0x1]) & 0xf;
        u64 high = ($u64 buf[i - 0x1] >> $u64 4) & 0xf;
        if(high < $u64 10) cout << ('0' + $u8 high);
        else cout << ('a' + $u8 high - $u8 10);
        if(low < $u64 10) cout << ('0' + $u8 low);
        else cout << ('a' + $u8 low - $u8 10);
        cout << " ";
        if(i % 0x10 == 0x0) cout << "\n";
    }
    if(amt_bytes % 0x10) cout << "\n";
}

//assumes that the lowest significant bits in each byte come first
i32 bitmap_get_bit(void* bitmap, u64 index) {
    return $i32 ((($u8* bitmap)[index / $u64 8] >> $u8 (index % $u64 8)) & $u8 1);
}

void bitmap_set_bit(void* bitmap, u64 index) {
    ($u8* bitmap)[index / $u64 8] |= ($u8 1 << $u8 (index % $u64 8));
}

void bitmap_unset_bit(void* bitmap, u64 index) {
    bitmap_set_bit(bitmap, index);
    ($u8* bitmap)[index / $u64 8] ^= ($u8 1 << $u8 (index % $u64 8));
}
