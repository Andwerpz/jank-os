#include <memory>;
#include <jstring>;

#include "vga.jank";
#include "panic.jank";
#include "utils.jank";

#include "../../../lib/pagetable.jank";
#include "../../../lib/utils.jank";
#include "../../../lib/mbr.jank";

[__GLOBAL_FIRST__] u64 PAGE_SIZE    = $u64 0x001000;
[__GLOBAL_FIRST__] u64 HUGEPG_SIZE  = $u64 0x200000;

[__GLOBAL_FIRST__] u64 AHCI_ABAR_PAGE;  //AHCI driver needs physical buf of size PAGE_SIZE * 2

[__GLOBAL_FIRST__] u64 MB = 0x100000;   
[__GLOBAL_FIRST__] u64 GB = 0x40000000;

[__GLOBAL_FIRST__] boot_info* boot_info = $boot_info* 0x1000;
struct boot_info {
    // populated by 16/32 bit mode
    e820_ent*   e820_mmap;              // 0
    u16         e820_entry_count;       // 8
    u8          boot_drive;             // 10

    void*       reserved_start;         // 11
    u64         reserved_sz;            // 19

    u64         kcode_start;            // 27
}

struct e820_ent {
    u64 base;
    u64 length;
    u32 type;   // 1 = usable RAM
    u32 attr;
}

u64 malloc_ptr;
void* malloc(u64 sz) {
    void* ret = $void* malloc_ptr;
    malloc_ptr += sz;
    return ret;
}

i32 free(void* addr, u64 sz) {
    //do nothing
    return 0;
}

u64 palloc_ptr;
void* palloc() {
    void* ret = $void* palloc_ptr;
    palloc_ptr += PAGE_SIZE;
    return ret;
}

void pfree(void* page) {
    //do nothing (for now)
}

i32 main() {
    vga_print("bello from jank\n");

    vga_print("Boot drive : ");
    vga_print($u16 (boot_info->boot_drive));
    vga_print("\n");

    vga_print("E820 MMAP : \n");
    for(u64 i = 0x0; i < $u64 (boot_info->e820_entry_count); i++) {
        e820_ent* ent = @(boot_info->e820_mmap[i]);
        vga_print("base : ");
        vga_print(ent->base);
        vga_print(", length : ");
        vga_print(ent->length);
        vga_print(", type : ");
        vga_print(ent->type);
        vga_print("\n");
    }

    // clean up E820 MMAP
    // - ensure that all regions are non-overlapping
    // - ensure that regions are sorted in ascending order
    // TODO

    vga_print("Reserved : ");
    vga_print($u64 (boot_info->reserved_start));
    vga_print(", ");
    vga_print(boot_info->reserved_sz);
    vga_print("\n");

    println("Kernel code start : ", boot_info->kcode_start);
    
    if(boot_info->reserved_start == nullptr) {
        panic("failed to reserve");
    }

    panic();

    // init malloc / palloc
    malloc_ptr = $u64 boot_info->reserved_start + 0x0 * MB;
    palloc_ptr = $u64 boot_info->reserved_start + 0x1 * MB;
    u64 code_ptr = $u64 boot_info->reserved_start + 0x2 * MB;
    u64 stack_ptr = $u64 boot_info->reserved_start + 0x4 * MB;

    pagetable_t pt = pt_get_current();
    print("CR3 : ");
    println(pt);

    println("PAGETABLE");
    pt_print(pt);

    // create identity mapping for memory above 1GB
    // stub should've already mapped everything below 1GB
    u64 max_phys = 0x0;
    for(u64 i = 0x0; i < $u64 (boot_info->e820_entry_count); i++) {
        e820_ent* ent = @(boot_info->e820_mmap[i]);
        if(ent->type == $u32 0x1 && ent->base + ent->length > max_phys) {
            max_phys = ent->base + ent->length;
        }
    }
    for(u64 i = GB; i + HUGEPG_SIZE <= max_phys; i += HUGEPG_SIZE) {
        pt_map_hugepg(pt, $void* i, $void* i, PTE_WRITEABLE);
    }

    vga_clear();
    vga_reset_cursor();
    print("MAX PHYS : ");
    println(max_phys);
    println("PAGETABLE");
    pt_print(pt);

    // map higher half kernel
    // - code
    // - stack
    // - framebuffer

    // jump to kernel

    while(1) {
        asm!("hlt");
    }

    return 0;
}
