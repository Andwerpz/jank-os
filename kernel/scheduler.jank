
[__GLOBAL_FIRST__] u64 PROCESS_NEW          = 0x0;
[__GLOBAL_FIRST__] u64 PROCESS_READY        = 0x1;
[__GLOBAL_FIRST__] u64 PROCESS_RUNNING      = 0x2;
[__GLOBAL_FIRST__] u64 PROCESS_ZOMBIE       = 0x3;
[__GLOBAL_FIRST__] u64 PROCESS_IDLE         = 0x4;

struct trapframe {
    u64 rax;
    u64 rbx;
    u64 rcx;
    u64 rdx;
    u64 rsi;
    u64 rdi;
    u64 rbp;
    u64 rsp;
    u64 r8;
    u64 r9;
    u64 r10;
    u64 r11;
    u64 r12;
    u64 r13;
    u64 r14;
    u64 r15;
    u64 rip;
    u64 rflags;
}

struct process {
    u64 pid;
    u64 kstack_bottom;  
    u64 brk;
    u64 status;
    u64* pt;
}

vector<process*> all_processes;
deque<process*> process_queue;
process* current_process;

process* get_cur_proc() {
    return current_process;
}

//should panic if there's no more processes to choose from
process* schedule_next_process() {
    //go until you see PROCESS_READY
    //should probably add a check to see if there's actually some process that's READY in the queue
    while(1) {
        passert(process_queue.size() != 0x0, "schedule_next_process() : no more processes!!");
        process* next = process_queue.front();
        process_queue.push_back(process_queue.pop_front());

        if(next->status == PROCESS_READY) {
            return next;
        }
        else if(next->status == PROCESS_ZOMBIE) {
            //remove zombies from queue
            process_queue.pop_back();
        }
    }

    //shouldn't get here
    return $process* nullptr;
}

u64 kstack_ptr = KSTACK_AREA_BOTTOM; //for now, just incrementally map new kstacks
u64 pid_ptr = 0x0;

//should allocate a kstack for the new process
//panics if there isn't enough room for a new kstack
//assumes we're currently using the kernel_pt
process* create_process(u8* elf_buf, u64 size) {
    u64* kernel_pt = pt_get_current();

    process proc = new process();
    proc.pt = pt_alloc_new();
    proc.pid = pid_ptr ++;
    proc.brk = USER_HEAP_BOTTOM;
    proc.status = PROCESS_NEW;

    //map kernel into process
    for(u64 i = KERNEL_BOTTOM; i != 0x0; i += PAGE_SIZE) {
        void* vaddr = $void* i;
        if(pt_is_vaddr_mapped(kernel_pt, vaddr)) {
            u64 perm_flags;
            void* paddr = pt_translate(kernel_pt, vaddr, perm_flags);
            pt_map_page(proc.pt, vaddr, paddr, perm_flags);
        }
    }
    
    //alloc new kstack for process, need to map in kernel as well
    passert(kstack_ptr + KSTACK_SIZE <= KSTACK_AREA_TOP, "create_process() : ran out of room for kstacks");
    proc.kstack_bottom = kstack_ptr;
    for(u64 i = 0x0; i < KSTACK_SIZE; i += PAGE_SIZE) {
        void* paddr = palloc();
        pt_map_page(kernel_pt, $void* (kstack_ptr + i), paddr, PTE_WRITEABLE);
        pt_map_page(proc.pt, $void* (kstack_ptr + i), paddr, PTE_WRITEABLE);
    }
    kstack_ptr += KSTACK_SIZE;

    //map user stack
    for(u64 i = USER_STACK_BOTTOM; i <= USER_STACK_TOP; i += PAGE_SIZE) {
        pt_alloc_and_map_page(proc.pt, $void* i, PTE_USER | PTE_WRITEABLE);
    }

    //map guard page
    pt_alloc_and_map_page(proc.pt, $void* USER_GUARD_PAGE, 0x0);

    //map elf 
    u64 entry_off;
    if(load_elf(elf_buf, size, proc.pt, entry_off)) {
        panic("failed to load elf");
    }

    //write initial execution context to trapframe
    trapframe* tf = $trapframe* (proc.kstack_bottom + KSTACK_TRAPFRAME);
    tf->rsp = USER_STACK_TOP;
    tf->rip = entry_off;
    tf->rflags = 0x202;     //enable timer interrupt

    //add to scheduler
    all_processes.push_back(@proc);
    process_queue.push_back(@proc);

    return @proc;
}

//should only be able to remove zombie processes
void remove_process(u64 pid) {
    //find process
    u64 ind = all_processes.size();
    for(u64 i = 0x0; i < all_processes.size(); i++){
        if(all_processes[i]->pid != pid) continue;
        if(ind != all_processes.size()) panic("remove_process() : found two processes with same pid");
        ind = i;
    }
    if(ind == all_processes.size()) panic("remove_process() : could not find process");
    process* proc = all_processes[ind];

    //make sure process is a zombie process
    passert(proc->status == PROCESS_ZOMBIE, "remove_process() : process must be zombie");
    u64* kernel_pt = pt_get_current();

    //unmap kernel
    for(u64 i = KERNEL_BOTTOM; i != 0x0; i += PAGE_SIZE) {
        void* vaddr = $void* i;
        if(pt_is_vaddr_mapped(kernel_pt, vaddr)) {
            pt_unmap_page(proc->pt, vaddr);
        }
    }

    //unmap kstack from kernel pt (we want to delete the underlying pages)
    for(u64 i = 0x0; i < KSTACK_SIZE; i++){
        void* vaddr = $void* (proc->kstack_bottom + i);
        pt_unmap_page(kernel_pt, vaddr);
    }

    //free pagetable + underlying pages
    pt_free_pagetable(proc->pt);

    all_processes.erase(ind);
}

//this function never returns
void init_scheduler() {
    sout << "start init scheduler\n";   

    //initialize idler process 

    //initialize some shell process?

    //switch to idler process kernel stack

    //startup the scheduler
    scheduler();
}

//this assumes we're currently executing in some process's kernel stack
//we still need kernel pagetables active as we'll want to access kernel heap structures
//this should choose a process to run then jump to that process
//this should not have to cleanup, the saved execution context should make it so that 
//  any stuff leftover is treated as trash memory. 
void scheduler() {
    //look for next process to run
    process* next_process = schedule_next_process();

    //context switch to process and run it

}

[__GLOBAL_FIRST__] extern u8 timer_interrupt_entry;
void timer_interrupt_handler() {
    //we've just come from a timer interrupt
    asm!("timer_interrupt_entry:");

    //change process state to READY

    //save the current execution context to the corresponding trapframe

    //jump to scheduler
    asm!("jmp scheduler");
}