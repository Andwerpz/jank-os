
[__GLOBAL_FIRST__] u64 PROCESS_NEW          = 0x0;
[__GLOBAL_FIRST__] u64 PROCESS_READY        = 0x1;
[__GLOBAL_FIRST__] u64 PROCESS_RUNNING      = 0x2;
[__GLOBAL_FIRST__] u64 PROCESS_ZOMBIE       = 0x3;
[__GLOBAL_FIRST__] u64 PROCESS_IDLE         = 0x4;

struct trapframe {
    u64 rax;        // 0
    u64 rbx;        // 8
    u64 rcx;        // 16
    u64 rdx;        // 24
    u64 rsi;        // 32
    u64 rdi;        // 40
    u64 rbp;        // 48
    u64 rsp;        // 56
    u64 r8;         // 64
    u64 r9;         // 72
    u64 r10;        // 80
    u64 r11;        // 88
    u64 r12;        // 96
    u64 r13;        // 104
    u64 r14;        // 112
    u64 r15;        // 120
    u64 rip;        // 128
    u64 rflags;     // 136
    u64 pt;         // 144
}

struct process {
    u64 pid;            // 0
    u64 kstack_bottom;  // 8
    u64 brk;            // 16
    u64 status;         // 24
    u64* pt;            // 32
    i32 exit_status;    // 40
    file_descriptor*[64] fd_table;  //empty fds will be nullptr
}

vector<process*> all_processes;
deque<process*> process_queue;
process* current_process;

process* get_cur_proc() {
    return current_process;
}

//should panic if there's no more processes to choose from
process* schedule_next_process() {
    //go until you see PROCESS_READY
    //should probably add a check to see if there's actually some process that's READY in the queue
    while(1) {
        passert(process_queue.size() != 0x0, "schedule_next_process() : no more processes!!");
        process* next = process_queue.front();
        process_queue.push_back(process_queue.pop_front());

        if(next->status == PROCESS_READY) {
            return next;
        }
        else if(next->status == PROCESS_ZOMBIE) {
            //remove zombies from queue
            process_queue.pop_back();
        }
    }

    panic("schedule_next_process() : you shouldn't be here D:");
    return $process* nullptr;
}

u64 kstack_ptr = KSTACK_AREA_BOTTOM; //for now, just incrementally map new kstacks
u64 pid_ptr = 0x0;

//creates a dummy process
//you still need to do some stuff, this just takes care of some busywork
[__GLOBAL_FIRST__] u64 PROCESS_CREATE_STACK     = $u64 1 << $u64 0;
[__GLOBAL_FIRST__] u64 PROCESS_CREATE_FDTABLE   = $u64 1 << $u64 1;
process* create_process(u64 flags) {
    u64* kernel_pt = pt_get_current();

    process* proc = $process* malloc(sizeof(process));
    proc->pt = pt_alloc_new();
    proc->pid = pid_ptr ++;
    proc->brk = USER_HEAP_BOTTOM;
    proc->status = PROCESS_NEW;

    //map kernel
    for(u64 i = KERNEL_BOTTOM; i != 0x0; i += PAGE_SIZE) {
        void* vaddr = $void* i;
        if(pt_is_vaddr_mapped(kernel_pt, vaddr)) {
            u64 perm_flags;
            void* paddr = pt_translate(kernel_pt, vaddr, perm_flags);
            pt_map_page(proc->pt, vaddr, paddr, perm_flags);
        }
    }

    //alloc new kstack for process, need to map in kernel as well
    passert(kstack_ptr + KSTACK_SIZE <= KSTACK_AREA_TOP, "create_process() : ran out of room for kstacks");
    proc->kstack_bottom = kstack_ptr;
    for(u64 i = 0x0; i < KSTACK_SIZE; i += PAGE_SIZE) {
        void* paddr = palloc();
        pt_map_page(kernel_pt, $void* (kstack_ptr + i), paddr, PTE_WRITEABLE);
        pt_map_page(proc->pt, $void* (kstack_ptr + i), paddr, PTE_WRITEABLE);
    }
    kstack_ptr += KSTACK_SIZE;

    if(flags & PROCESS_CREATE_STACK) {
        //map user stack
        for(u64 i = USER_STACK_BOTTOM; i <= USER_STACK_TOP; i += PAGE_SIZE) {
            pt_alloc_and_map_page(proc->pt, $void* i, PTE_USER | PTE_WRITEABLE);
        }

        //map guard page
        pt_alloc_and_map_page(proc->pt, $void* USER_GUARD_PAGE, 0x0);
    }

    if(flags & PROCESS_CREATE_FDTABLE) {
        proc->fd_table[0] = create_serial_fd(O_RDONLY); //STDIN
        proc->fd_table[1] = create_serial_fd(O_WRONLY); //STDOUT
        proc->fd_table[2] = create_serial_fd(O_WRONLY); //STDERR
    }

    //write initial execution context to trapframe
    trapframe* tf = $trapframe* (proc->kstack_bottom + KSTACK_TRAPFRAME);
    tf->rsp = USER_STACK_TOP;
    tf->rflags = 0x202;     //enable timer interrupt
    tf->pt = $u64 proc->pt;

    //add to scheduler
    all_processes.push_back(proc);
    process_queue.push_back(proc);

    return proc;
}

//create new process with ELF code
process* create_process(u8* elf_buf, u64 size) {
    process* proc = create_process(PROCESS_CREATE_STACK | PROCESS_CREATE_FDTABLE);

    //map elf 
    u64 entry_off;
    if(load_elf(elf_buf, size, proc->pt, entry_off)) {
        panic("failed to load elf");
    }

    //set entry point
    trapframe* tf = $trapframe* (proc->kstack_bottom + KSTACK_TRAPFRAME);
    tf->rip = entry_off;

    //make ready
    proc->status = PROCESS_READY;

    return proc;
}

//creates a clone of the parent process's user memory state and other stuff
//does not clone register state
process* create_process(process* parent) {
    process* child = create_process(0x0);

    //copy process info
    child->brk = parent->brk;
    child->fd_table = parent->fd_table;

    //increment refcount of file descriptors
    for(i32 i = 0; i < 64; i++){
        if($void* child->fd_table[i] == nullptr) continue;
        child->fd_table[i]->refcount ++;
    }

    //copy parent lower half mappings
    pt_copy_lower_half(parent->pt, child->pt);

    return proc;
}

//copies all mappings from pt to out_pt that exist in the lower half
//allocs new pages and copies the data over as well
void pt_copy_lower_half(u64* pt, u64* out_pt, u64 vaddr, u64 level) {
    for(u64 i = 0x0; i < $u64 512; i++){
        if(level == 0x3 && i == $u64 256) break; 

        u64 cvaddr = vaddr | (i << ($u64 12 + $u64 9 * level));
        u64 pte = pt[i];    
        if(!(pte & PTE_PRESENT)) continue;

        //if this is not a leaf, copy subtree
        if(level) pt_copy_lower_half(pt, out_pt, cvaddr, level - 0x1);

        //if this is a leaf, copy mapping
        if(!level) {
            u64 flags = pte_get_permission_flags(pte);
            void* paddr = $void* pte_get_addr(pte);
            void* npaddr = palloc();

            pt_map_page(out_pt, $void* cvaddr, npaddr, flags);
            memcpy(npaddr, paddr, PAGE_SIZE);
        }
    }
}

void pt_copy_lower_half(u64* pt, u64* out_pt) {
    pt_copy_lower_half(pt, out_pt, 0x0, 0x3);
}

//on success, returns a pointer to a process
//on failure, panics
process* find_process(u64 pid) {
    u64 ind = all_processes.size();
    for(u64 i = 0x0; i < all_processes.size(); i++){
        if(all_processes[i]->pid != pid) continue;
        if(ind != all_processes.size()) panic("find_process() : found two processes with same pid");
        ind = i;
    }
    if(ind == all_processes.size()) panic("find_process() : could not find process");
    return all_processes[ind];
}

//all new processes should go through this to become ready
//does some last checks and setup
void make_process_ready(process* proc) {

}

//marks process as dead, cleans up process. 
//the process will still exist in the scheduler as a zombie
//if this is the current process, jumps to scheduler. 
void kill_process(u64 pid, i32 status) {
    
}

//this completely gets rid of the process from the scheduler
//should only be able to remove zombie processes
void remove_process(u64 pid) {
    //find process
    process* proc = find_process(pid);

    //make sure process is a zombie process
    passert(proc->status == PROCESS_ZOMBIE, "remove_process() : process must be zombie");
    u64* kernel_pt = pt_get_current();

    //unmap kernel
    for(u64 i = KERNEL_BOTTOM; i != 0x0; i += PAGE_SIZE) {
        void* vaddr = $void* i;
        if(pt_is_vaddr_mapped(kernel_pt, vaddr)) {
            pt_unmap_page(proc->pt, vaddr);
        }
    }

    //unmap kstack from kernel pt (we want to delete the underlying pages)
    for(u64 i = 0x0; i < KSTACK_SIZE; i++){
        void* vaddr = $void* (proc->kstack_bottom + i);
        pt_unmap_page(kernel_pt, vaddr);
    }

    //free file descriptors
    for(i32 i = 0; i < 64; i++){
        if(proc->fd_table[i] == nullptr) continue;
        sys_close(i);
    }

    //free pagetable + underlying pages
    pt_free_pagetable(proc->pt);

    //remove process from scheduler
    all_processes.erase(ind);
    free($void* proc, sizeof(process));
}

//once we call this, the initial kernel startup phase has finished
//this function should never return. 
void init_scheduler() {
    sout << "start init scheduler\n";   

    //initialize shell process 

    //point %rsp to top of kernel stack
    asm!("mov BOOTBOOT_STACK_TOP(%rip), %rsp");

    //startup the scheduler
    scheduler();
}

//before jumping here, should make it so that %rsp points to a stack that we can safely
//  put garbage on. you can use the kernel stack for this
//this expects kernel pagetables to be active as we'll want to access kernel heap structures
//this should choose a process to run then jump to that process
//this should not have to cleanup, the saved execution context should make it so that 
//  any stuff leftover is treated as trash memory. 
void scheduler() {
    //look for next process to run
    current_process = schedule_next_process();
    u64 proc_trapframe_off = current_process->kstack_bottom + KSTACK_TRAPFRAME;    // -8(%rbp)

    //set process state to RUNNING
    current_process->status = PROCESS_RUNNING;

    //so syscalls know where this is
    GSData* gs_data = $GSData* GSDATA_PAGE;
    gs_data->cur_proc_kstack_top = current_process->kstack_bottom + KSTACK_TOP;

    //swapgs
    asm!("swapgs");

    //context switch to process and run it
    asm!("movq -8(%rbp), %rax");

    //iretq information
    asm!("pushq $0x1B");        // SS
    asm!("pushq 56(%rax)");     // %rsp
    asm!("pushq 136(%rax)");    // rflags
    asm!("pushq $0x23");        // CS
    asm!("pushq 128(%rax)");    // %rip

    //push registers
    asm!("pushq 0(%rax)");      // %rax
    asm!("pushq 8(%rax)");      // %rbx
    asm!("pushq 16(%rax)");     // %rcx
    asm!("pushq 24(%rax)");     // %rdx
    asm!("pushq 32(%rax)");     // %rsi
    asm!("pushq 40(%rax)");     // %rdi
    asm!("pushq 48(%rax)");     // %rbp
                                // skip %rsp
    asm!("pushq 64(%rax)");     // %r8
    asm!("pushq 72(%rax)");     // %r9
    asm!("pushq 80(%rax)");     // %r10
    asm!("pushq 88(%rax)");     // %r11
    asm!("pushq 96(%rax)");     // %r12
    asm!("pushq 104(%rax)");    // %r13
    asm!("pushq 112(%rax)");    // %r14
    asm!("pushq 120(%rax)");    // %r15
    asm!("pushq 144(%rax)");    // %cr3

    //pop registers
    asm!("popq %rax");
    asm!("movq %rax, %cr3");
    
    asm!("popq %r15");
    asm!("popq %r14");
    asm!("popq %r13");
    asm!("popq %r12");
    asm!("popq %r11");
    asm!("popq %r10");
    asm!("popq %r9");
    asm!("popq %r8");
                                // skip %rsp
    asm!("popq %rbp");
    asm!("popq %rdi");
    asm!("popq %rsi");
    asm!("popq %rdx");
    asm!("popq %rcx");
    asm!("popq %rbx");
    asm!("popq %rax");

    asm!("iretq");
}

//TSS should make it so that this uses the kernel stack
[__GLOBAL_FIRST__] extern u8 timer_interrupt_entry;
void timer_interrupt_handler() {
    asm!("timer_interrupt_entry:"); //don't want stack frame messing stuff up

    //we should've come from user mode
    //cpu will have pushed these things onto the stack:
    // SS
    // %rsp
    // RFLAGS
    // CS
    // %rip
    //when we add preemption to syscalls, need to account for different stack contents

    //push registers onto stack
    asm!("pushq %rax");
    asm!("pushq %rbx");
    asm!("pushq %rcx");
    asm!("pushq %rdx");
    asm!("pushq %rsi");
    asm!("pushq %rdi");
    asm!("pushq %rbp");
                                // skip %rsp
    asm!("pushq %r8");
    asm!("pushq %r9");
    asm!("pushq %r10");
    asm!("pushq %r11");
    asm!("pushq %r12");
    asm!("pushq %r13");
    asm!("pushq %r14");
    asm!("pushq %r15");

    asm!("mov %cr3, %rax");
    asm!("pushq %rax");

    //setup kernel execution context
    asm!("swapgs");                                 //swap to kernel GS 
    asm!("movq %gs:0, %rax");                       //swap to kernel pagetable
    asm!("mov %rax, %cr3");

    //get current process
    asm!("call get_cur_proc");      //%rax now holds pointer to current process
    asm!("movq PROCESS_READY(%rip), %rbx");
    asm!("movq %rbx, 24(%rax)");    //change state of current process to READY

    //put trapframe addr into %rax
    asm!("movq 8(%rax), %rax");     //%rax now holds proc->kstack_bottom
    asm!("movq KSTACK_TRAPFRAME(%rip), %rbx");
    asm!("add %rbx, %rax");         //%rax now holds trapframe addr

    //write to trapframe
    asm!("popq 144(%rax)");     // %cr3
    asm!("popq 120(%rax)");     // %r15
    asm!("popq 112(%rax)");     // %r14
    asm!("popq 104(%rax)");     // %r13
    asm!("popq 96(%rax)");      // %r12
    asm!("popq 88(%rax)");      // %r11
    asm!("popq 80(%rax)");      // %r10
    asm!("popq 72(%rax)");      // %r9
    asm!("popq 64(%rax)");      // %r8
                                // skip %rsp
    asm!("popq 48(%rax)");      // %rbp
    asm!("popq 40(%rax)");      // %rdi
    asm!("popq 32(%rax)");      // %rsi
    asm!("popq 24(%rax)");      // %rdx
    asm!("popq 16(%rax)");      // %rcx
    asm!("popq 8(%rax)");       // %rbx
    asm!("popq 0(%rax)");       // %rax

    asm!("popq 128(%rax)");     // %rip 
    asm!("add $8, %rsp");       // CS
    asm!("popq 136(%rax)");     // RFLAGS
    asm!("popq 56(%rax)");      // %rsp
    asm!("add $8, %rsp");       // SS

    //send EOI
    asm!("movb $0x20, %al");
    asm!("outb %al, $0x20");

    //jump to scheduler
    asm!("jmp scheduler");
}