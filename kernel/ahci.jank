// https://wiki.osdev.org/AHCI
// https://www.intel.com/content/dam/www/public/us/en/documents/technical-specifications/serial-ata-ahci-spec-rev1-3-1.pdf

void init_ahci() {
    ahci_hba* hba = $ahci_hba* malloc(sizeof(ahci_hba));
    scan_for_ahci(hba);
    hba_info(hba);
}

// https://wiki.osdev.org/PCI#Configuration_Space_Access_Mechanism_#1
// Bit 31       Bits 30-24  Bits 23-16  Bits 15-11      Bits 10-8           Bits 7-0
// Enable Bit   Reserved    Bus Number  Device Number   Function Number     Register Offset
[__GLOBAL_FIRST__] u64 PCI_CONFIG_ADDRESS           = 0xcf8;
[__GLOBAL_FIRST__] u64 PCI_CONFIG_DATA              = 0xcfc;
[__GLOBAL_FIRST__] u64 AHCI_CLASS_CODE              = 0x1;
[__GLOBAL_FIRST__] u64 AHCI_SUBCLASS                = 0x6;

struct ahci_hba {
    u8  bus;
    u8  device;
    u8  function;
    u64 abar; // AHCI Base Address Register :O
}

u32 pci_read(u8 bus, u8 device, u8 function, u8 offset) {
    u32 enabled = ($u32 1) << $u32 31;
    u32 busl = ($u32 bus) << $u32 16;
    u32 devicel = ($u32 device) << $u32 11;
    u32 functionl = ($u32 function) << $u32 8;
    u32 offsetl = ($u32 offset) & $u32 0xfc; // the two lowest bits of CONFIG_ADDRESS must always be zero (?)

    u32 addr = enabled | busl | devicel | functionl | offsetl;

    outl($u16 PCI_CONFIG_ADDRESS, addr);

    return inl($u16 PCI_CONFIG_DATA); // vendor in lower 16 bits, device in upper 16 bits
}

i32 scan_for_ahci(ahci_hba* hba) {
    sout << "scanning pci bus for ahci controller :O" << "\n";

    for(i32 bus = 0; bus < 256; bus++) {
        for(i32 device = 0; device < 32; device++) {
            u16 vendor_id = $u16 (pci_read($u8 bus, $u8 device, $u8 0, $u8 0) & $u32 0xffff);
            if(vendor_id == $u16 0xffff) continue;

            u8 header_type = $u8 ((pci_read($u8 bus, $u8 device, $u8 0, $u8 0xc) >> $u32 16) & $u32 0xff); // Common Header Fields -> Header type offset
            
            i32 max_functions = 1;
            if(header_type & $u8 0x80) max_functions = 8; // Multi-function Devices - bit 7 of the header type field set
            for(i32 function = 0; function < max_functions; function++) {
                // Common Header Fields -> Class code offset
                u32 class_reg = pci_read($u8 bus, $u8 device, $u8 0, $u8 0x8);
                u8 class_code = $u8 ((class_reg >> $u32 24) & $u32 0xff);
                u8 subclass = $u8 ((class_reg >> $u32 16) & $u32 0xff);

                if(class_code == $u8 AHCI_CLASS_CODE && subclass == $u8 AHCI_SUBCLASS) {
                    sout << "found ahci hba" << "\n";
                    
                    u32 bar5 = pci_read($u8 bus, $u8 device, $u8 function, $u8 0x24); // Base Address Registers -> Memory Space BAR Layout 
                    u8 bar_type = $u8 ((bar5 >> $u32 1) & $u32 0x3); // 0x0 = 32bit; 0x2 = 64bit

                    hba->bus = $u8 bus;
                    hba->device = $u8 device;
                    hba->function = $u8 function;
                    
                    if(bar_type == $u8 0x2) {
                        sout << "64 bit ABAR" << "\n";
                    } else {
                        hba->abar = $u64 (bar5 & $u32 0xfffffff0);
                        sout << "32 bit ABAR" << "\n";
                    }
                    return 0;
                }
            }
        }
    }

    sout << "no ahci controller found" << "\n";
    return -1;
}

// https://wiki.osdev.org/AHCI#Detect_attached_SATA_devices
[__GLOBAL_FIRST__] u32 SATA_SIG_ATA      = $u32 0x00000101;
[__GLOBAL_FIRST__] u32 SATA_SIG_ATAPI    = $u32 0xeb140101;
[__GLOBAL_FIRST__] u32 SATA_SIG_SEMB	 = $u32 0xc33c0101;
[__GLOBAL_FIRST__] u32 SATA_SIG_PM	     = $u32 0x96690101;

struct HBA_PORT {
	u32         clb;		// 0x00, command list base address, 1K-byte aligned
	u32         clbu;		// 0x04, command list base address upper 32 bits
	u32         fb;		    // 0x08, FIS base address, 256-byte aligned
	u32         fbu;		// 0x0C, FIS base address upper 32 bits
	u32         is;		    // 0x10, interrupt status
	u32         ie;		    // 0x14, interrupt enable
	u32         cmd;		// 0x18, command and status
	u32         rsv0;		// 0x1C, Reserved
	u32         tfd;		// 0x20, task file data
	u32         sig;		// 0x24, signature
	u32         ssts;		// 0x28, SATA status (SCR0:SStatus)
	u32         sctl;		// 0x2C, SATA control (SCR2:SControl)
	u32         serr;		// 0x30, SATA error (SCR1:SError)
	u32         sact;		// 0x34, SATA active (SCR3:SActive)
	u32         ci;		    // 0x38, command issue
	u32         sntf;		// 0x3C, SATA notification (SCR4:SNotification)
	u32         fbs;		// 0x40, FIS-based switch control
	u32[11]     rsv1;	    // 0x44 ~ 0x6F, Reserved
	u32[4]      vendor;	    // 0x70 ~ 0x7F, vendor specific
}

struct HBA_MEM {
	// 0x00 - 0x2B, Generic Host Control
	u32             cap;		// 0x00, Host capability
	u32             ghc;		// 0x04, Global host control
	u32             is;		    // 0x08, Interrupt status
	u32             pi;		    // 0x0C, Port implemented
	u32             vs;		    // 0x10, Version
	u32             ccc_ctl;	// 0x14, Command completion coalescing control
	u32             ccc_pts;	// 0x18, Command completion coalescing ports
	u32             em_loc;		// 0x1C, Enclosure management location
	u32             em_ctl;		// 0x20, Enclosure management control
	u32             cap2;		// 0x24, Host capabilities extended
	u32             bohc;		// 0x28, BIOS/OS handoff control and status

	// 0x2C - 0x9F, Reserved
	u8[116]         rsv;        // 0xa0-0x2c = 0x74

	// 0xA0 - 0xFF, Vendor specific registers
	u8[96]          vendor;     // 0x100-0xa0 = 0x60

	// 0x100 - 0x10FF, Port control registers
	HBA_PORT[1]     ports;	    // 1 ~ 32
}

void hba_info(ahci_hba* hba) {
    HBA_MEM* h = $HBA_MEM* hba->abar;

    sout << "HBA Info:\n";
    sout << "bus : device : function\n";
    sout << $i32 hba->bus << ":" << $i32 hba->device << ":" << $i32 hba->function << "\n";
    sout << "abar: " << $void* hba->abar << "\n";

    u32 version = h->vs;
    u16 major = $u16 ((version >> $u32 16) & $u32 0xffff);
    u16 minor = $u16 (version & $u32 0xffff);
    sout << "Version: " << major << "." << minor << "\n"; 

    u64 ports_implemented = $u64 h->pi;
    for(u64 i = 0x0; i < $u64 32; i++) {
        if(ports_implemented & ($u64 1 << i)) {
            sout << "port: " << i << " is available\n";
            HBA_PORT* p = @h->ports[i];
            u32 status = p->ssts;
            u8 detection = $u8 (status & $u32 0x0f);
            if(detection != $u8 3) {
                sout << "  - no device detected on this port\n"; 
                continue;
            }
            sout << "  + device detected on this port\n";
            
            u32 signature = p->sig;
            if(signature == SATA_SIG_ATA) {
                sout << "  SATA drive\n";
            } else if(signature == SATA_SIG_ATAPI) {
                sout << "  SATAPI drive\n";
            } else if(signature == SATA_SIG_SEMB) {
                sout << "  SEMB drive\n";
            } else if(signature == SATA_SIG_PM) {
                sout << "  PM drive\n";
            }
        }
    }
}

// https://wiki.osdev.org/AHCI#AHCI_port_memory_space_initialization
[__GLOBAL_FIRST__] u32 HBA_PxCMD_ST    = $u32 0x0001;
[__GLOBAL_FIRST__] u32 HBA_PxCMD_FRE   = $u32 0x0010;
[__GLOBAL_FIRST__] u32 HBA_PxCMD_FR    = $u32 0x4000;
[__GLOBAL_FIRST__] u32 HBA_PxCMD_CR    = $u32 0x8000;

void stop_cmd(HBA_PORT* p) {
    p->cmd &= ~HBA_PxCMD_ST; // clear ST
    p->cmd &= ~HBA_PxCMD_FRE; // clear FRE
    
    // busy wait until FR and CR are cleared
    while((p->cmd & HBA_PxCMD_FR) || (p->cmd & HBA_PxCMD_CR)) {}
}

void start_cmd(HBA_PORT* p) {
    // busy wait until CR is cleared
    while(p->cmd & HBA_PxCMD_CR) {}

	p->cmd |= HBA_PxCMD_FRE; // set FRE
	p->cmd |= HBA_PxCMD_ST; // set ST
}

void rebase_port(HBA_PORT* p, i32 port_num) {
    stop_cmd(p);
    
    // TODO

    start_cmd(p);
}

// TODO
// map abar to vaddr
// PCD, is the 'Cache Disable' bit. If the bit is set, the page will not be cached. Otherwise, it will be. ADD CONSTANT TO PGTBL
// pt_map_page calc size and map
// palloc 3 pages, assign clb,fb,ctba