
[0] u32* FB_ADDR = $u32* 0xfffffffffc000000;

[0] u64 FB_WIDTH = $u64 800;
[0] u64 FB_HEIGHT = $u64 600;

struct psf_header {
    u32 magic;
    u32 version;
    u32 headersize;
    u32 flags;
    u32 numglyph;
    u32 bytesperglyph;
    u32 height;
    u32 width;
    u8 glyphs;  //glyph starting byte
}
[0] extern u8 _binary_font_psf_start;

void draw_pixel(u64 x, u64 y, u32 color) {
    FB_ADDR[FB_WIDTH * y + x] = color;
}

void draw_pixel(i32 x, i32 y, u32 color) {
    draw_pixel($u64 x, $u64 y, color);
}

[0] u32 COLOR_WHITE = $u32 0x00ffffff;
[0] u32 COLOR_BLACK = $u32 0x00000000;
[0] u32 COLOR_GRAY = $u32 0x00aaaaaa;

//top left corner positioned at (x, y)
//the bits within each byte are big endian, but the bytes themselves are little endian. 
void draw_char(i32 x, i32 y, u8 c) {
    psf_header* font = $psf_header* @_binary_font_psf_start;
    u64 bpl = ($u64 font->width + $u64 7) / $u64 8;
    u8* glyph = $u8* ($u64 font + $u64 font->headersize + $u64 font->bytesperglyph * $u64 c);
    for(i32 j = 0; j < $i32 font->height; j++){
        u64 line = ($u64* @(glyph[bpl * $u64 j]))[0];
        for(i32 i = 0; i < $i32 font->width; i++){
            if(line & ($u64 1 << ($u64 font->width - $u64 1 - $u64 i))) {
                draw_pixel(x + i, y + j, COLOR_WHITE);
            }
            else {
                draw_pixel(x + i, y + j, COLOR_BLACK);
            }
        }
    }
}

void draw_string(i32 x, i32 y, u8* str) {
    psf_header* font = $psf_header* @_binary_font_psf_start;
    while(*str) {
        draw_char(x, y, *str);
        x += $i32 font->width;
        str = $u8* ($u64 str + $u64 1);
    }
}



void outb(u16 port, u8 val) {
    asm!("movw 24(%rbp), %dx");
    asm!("movb 16(%rbp), %al");
    asm!("out %al, %dx");
}

u8 inb(u16 port) {
    u8 ret;
    asm!("movw 16(%rbp), %dx");
    asm!("inb %dx, %al");
    asm!("movb %al, -8(%rbp)");
    return ret;
}

[0] u16 COM1 = $u16 0x3f8;
i32 init_serial() {
    outb(COM1 + $u16 1, $u8 0x00);    // Disable all interrupts
    outb(COM1 + $u16 3, $u8 0x80);    // Enable DLAB (set baud rate divisor)
    outb(COM1 + $u16 0, $u8 0x03);    // Set divisor to 3 (lo byte) 38400 baud
    outb(COM1 + $u16 1, $u8 0x00);    //                  (hi byte)
    outb(COM1 + $u16 3, $u8 0x03);    // 8 bits, no parity, one stop bit
    outb(COM1 + $u16 2, $u8 0xc7);    // Enable FIFO, clear them, with 14-byte threshold
    outb(COM1 + $u16 4, $u8 0x0b);    // IRQs enabled, RTS/DSR set
    outb(COM1 + $u16 4, $u8 0x1e);    // Set in loopback mode, test the serial chip
    outb(COM1 + $u16 0, $u8 0xae);    // Test serial chip (send byte 0xAE and check if serial returns same byte)

    // Check if serial is faulty (i.e: not same byte as sent)
    if(inb(COM1 + $u16 0) != $u8 0xae) {
        return $i32 1;
    }

    // If serial is not faulty set it in normal operation mode
    // (not-loopback with IRQs enabled and OUT#1 and OUT#2 bits enabled)
    outb(COM1 + $u16 4, $u8 0x0f);
    return $i32 0;
}

u8 is_transmit_empty() {
   return inb(COM1 + $u16 5) & $u8 0x20;
}

void write_serial(u8 a) {
   while(is_transmit_empty() == $u8 0) {}
   outb(COM1, a);
}

void serial_print(u8* str) {
    while(*str != $u8 0) {
        write_serial(*str);
        str = $u8* ($u64 str + $u64 1);
    }
}

u8 serial_received() {
   return inb(COM1 + $u16 5) & $u8 1;
}

u8 read_serial() {
   while(serial_received() == $u8 0) {}
   return inb(COM1);
}

i32 main() {
    init_serial();

    for(i32 i = 0; i < 100; i++){
        for(i32 j = 0; j < 100; j++){
            draw_pixel(i + 700, j + 500, COLOR_WHITE);    //0x00FFFFFF
        }
    }

    u8* testString = "BELLOOOOO ANDREW LI 0123456789!@#$%^&*()[]{};:";
    draw_string(0, 0, testString);
    serial_print(testString);

    u64 charCnt = $u64 0;
    u64 lineCnt = $u64 0;
    psf_header* font = $psf_header* @_binary_font_psf_start;

    while(1) {
        u8 c = read_serial();

        write_serial(c);
        write_serial('\n');

        draw_char($i32 charCnt, $i32 lineCnt, c);
        
        charCnt += $u64 font->width;
        if(charCnt >= FB_WIDTH) {
            lineCnt += $u64 font->height;
            charCnt = $u64 0;
        }
    }
    return 0;
}
