#include "serial.jank";
#include "vga.jank";
#include "pma.jank";
#include "pagetable.jank";

void check_paging_enabled() {
    u64 cr0;
    asm!("mov %cr0, %rax");
    asm!("mov %rax, -8(%rbp)");
    if(cr0 & ($u64 1 << $u64 31)) serial_print("paging enabled\n");
    else serial_print("paging disabled\n");
}   

void mem_touch(u64 low, u64 high) {
    serial_print("TOUCHING : ");
    serial_print($void* low);
    serial_print(" ");
    serial_println($void* high);
    u8* mem = $u8* $u64 0;
    for(u64 i = low; i < high; i++){
        mem[i] = '\0';
    }
    serial_print("done touching\n");
}

void print_mmap() {
    BOOTBOOT* bootboot = $BOOTBOOT* BOOTBOOT_INFO;
    MMapEnt* mmap = $MMapEnt* @(bootboot->mmap);
    u8* end = $u8* ($u64 bootboot + $u64 bootboot->size);
    while($u64 mmap < $u64 end) {
        u64 type = mmap->size & $u64 0xf;
        u64 addr = mmap->ptr;                            // physical address
        u64 size = mmap->size & $u64 0xfffffffffffffff0; // size in bytes

        serial_print("\n");
        serial_print("Found: \n");
        serial_print("Addr: ");
        serial_println($void* addr);
        serial_print("Size: ");
        serial_println($void* size);
        serial_print("Type: ");
        serial_println($void* type);

        mmap = $MMapEnt* ($u64 mmap + $u64 sizeof(MMapEnt));
    }
}

i32 main() {
    check_paging_enabled();

    if(1) {
        print_mmap();
    }

    if(1) {
        u64* kernel_pt = pt_get_current();
        void* fb_phys = pt_translate(kernel_pt, $void* BOOTBOOT_FB);
        serial_print("FB PHYS : ");
        serial_println(fb_phys);
        void* info_phys = pt_translate(kernel_pt, $void* BOOTBOOT_INFO);
        serial_print("info_phys : ");
        serial_println(info_phys);
    }

    init_pma();
    init_serial();
    
    if(0) {
        u64 tlow  = 0x0000000007fe0000;
        u64 thigh = 0x0000000007fe0000;

        u64* kernel_pt = pt_get_current();
        serial_print("kernel pt addr : ");
        serial_println(kernel_pt);

        passert(pt_is_vaddr_mapped(kernel_pt, $void* 0x10000), "bruh");

        mem_touch(tlow, thigh);
    }

    if(1) {
        u64* kernel_pt = pt_get_current();
        BOOTBOOT* bootboot = $BOOTBOOT* BOOTBOOT_INFO;
        MMapEnt* mmap = $MMapEnt* @(bootboot->mmap);
        u8* end = $u8* ($u64 bootboot + $u64 bootboot->size);
        while($u64 mmap < $u64 end) {
            u64 type = mmap->size & $u64 0xf;
            u64 addr = mmap->ptr;                            // physical address
            u64 size = mmap->size & $u64 0xfffffffffffffff0; // size in bytes

            if(type == $u64 1) {                      
                mem_touch(addr, addr + size);

                u64 base = (addr + PAGE_SIZE - $u64 1) & ~(PAGE_SIZE - $u64 1);
                while(base + PAGE_SIZE <= addr + size) {
                    passert(pt_is_vaddr_mapped(kernel_pt, $void* base), "this should be mapped");
                    base += PAGE_SIZE;
                }
            }   
            mmap = $MMapEnt* ($u64 mmap + $u64 sizeof(MMapEnt));
        }
    }

    if(1) {
        u64* kernel_pt = pt_get_current();
        u64 low  = 0x0000000100000000;
        u64 high = 0x0000000100100000;
        for(u64 i = low; i < high; i += PAGE_SIZE) {
            serial_print("MAP : ");
            serial_println($void* i);
            pt_map_page(kernel_pt, $void* i, $void* (i - low), PTE_WRITEABLE, PTE_WRITEABLE);
        }
        mem_touch(low, high);
        for(u64 i = low; i < high; i += PAGE_SIZE) {
            pt_unmap_page(kernel_pt, $void* i);
        }
    }

    u64 charCnt = $u64 0;
    u64 lineCnt = $u64 0;
    psf_header* font = $psf_header* @_binary_font_psf_start;

    while(1) {
        u8 c = read_serial();

        write_serial(c);
        write_serial('\n');

        draw_char($i32 charCnt, $i32 lineCnt, c);
        
        charCnt += $u64 font->width;
        if(charCnt >= FB_WIDTH) {
            lineCnt += $u64 font->height;
            charCnt = $u64 0;
        }
    }
    
    return 0;
}
