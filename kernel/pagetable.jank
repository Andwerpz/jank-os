#include "pma.jank";
#include "memlayout.jank";

//right now, we kind of have to handle huge pages as BOOTBOOT initializes our kernel pagetable with hugepages.

[0] u64 PTE_PRESENT    = $u64 1 << $u64 0;
[0] u64 PTE_WRITEABLE  = $u64 1 << $u64 1;
[0] u64 PTE_USER       = $u64 1 << $u64 2;
[0] u64 PTE_HUGEPG     = $u64 1 << $u64 7;
[0] u64 PTE_NX         = $u64 1 << $u64 63;

u64* pte_get_addr(u64 pte) {
    return $u64* (pte & 0x7fffffffff000);
}

u64 pte_create_new(u64 flags) {
    u64* pt = pt_alloc_new();
    return ($u64 pt) | flags | PTE_PRESENT;
}

u64 pte_create_new(void* paddr, u64 flags) {
    return ($u64 paddr) | flags | PTE_PRESENT;
}

u64 vaddr_get_pt_ind(void* vaddr, i32 level) {
    passert(3 >= level && level >= 0, "vaddr_get_pt_ind() : invalid level");
    return (($u64 vaddr) & (0x1ff << $u64 (12 + level * 9))) >> $u64 (12 + level * 9);
}

u64* pt_alloc_new() {
    u64* pt = $u64* palloc();
    memset($void* pt, 0, PAGE_SIZE);
    return pt;
}

u64* pt_get_current() {
    u64* ret;
    asm!("mov %cr3, %rax");
    asm!("mov %rax, -8(%rbp)");
    return ret;
}

//given virtual page address, walks along the provided pagetable
//stops traversing at level 'level' and returns the physical address of the page
// if(create), then it creates stuff wherever needed
// else, it returns $void* -1 if it can't find anything
void* pt_walk(u64* pt, void* vaddr, i32 level, i32 create, u64 flags, u64 leaf_flags) {
    passert($u64 vaddr % PAGE_SIZE == $u64 0, "pt_walk() : vaddr must be page aligned");
    passert(3 >= level && level >= 0, "pt_walk() : invalid level");
    serial_print("PT WALK VADDR : ");
    serial_println(vaddr);
    for(i32 i = 3; i >= level; i--){
        u64 ind = vaddr_get_pt_ind(vaddr, i);
        u64 pte = pt[ind];

        serial_print("PT : ");
        serial_print($void* pte);
        serial_print(" ");
        serial_println($void* ind);

        //TODO check if this is a huge page

        //check if pte is not present
        if(!(pte & PTE_PRESENT)) {
            if(!create) return $void* $u64 -1;
            if(i != 0) pt[ind] = pte_create_new(flags);
            else pt[ind] = pte_create_new(leaf_flags);
            pte = pt[ind];
        }

        u64* npt = pte_get_addr(pte);
        pt = npt;
    }
    serial_print("PT DONE : ");
    serial_println($void* pt);
    return $void* ($u64 pt + ($u64 vaddr & 0xfff));
}

//nocreate pt_walk
void* pt_walk(u64* pt, void* vaddr, i32 level) {
    void* ret = pt_walk(pt, vaddr, level, 0, $u64 0, $u64 0);
    passert($u64 ret != $u64 -1, "pt_walk() : vaddr mapping not found");
    return ret;
}

i32 pt_is_mapped(u64* pt, void* vaddr) {
    void* ret = pt_walk(pt, vaddr, 0, 0, $u64 0, $u64 0);
    return $u64 ret != $u64 -1;
}

//creates a pagetable mapping from vaddr -> paddr
//panics if vaddr is already mapped
void pt_map_page(u64* pt, void* vaddr, void* paddr, u64 flags, u64 leaf_flags) {
    //traverse pt to level 0
    pt = $u64* pt_walk(pt, vaddr, 1, 1, flags, leaf_flags);

    //entry corresponding to physical page must be not present
    u64 ind = vaddr_get_pt_ind(vaddr, 0);
    u64 pte = pt[ind];
    passert(!(pte & PTE_PRESENT), "pt_map_page() : vaddr already mapped");

    //map the page
    pt[ind] = pte_create_new(paddr, leaf_flags);
}

//removes pagetable mapping corresponding to vaddr, does not free the physical page
//panics if vaddr is not mapped
void pt_unmap_page(u64* pt, void* vaddr) {
    //traverse pt to level 0
    pt = $u64* pt_walk(pt, vaddr, 1);

    //entry corresponding to physical page must be present
    u64 ind = vaddr_get_pt_ind(vaddr, 0);
    u64 pte = pt[ind];
    passert((pte & PTE_PRESENT), "pt_unmap_page() : vaddr not mapped");

    //unmap the page
    pt[ind] = $u64 0;
}

//translates vaddr into paddr
void* pt_translate(u64* pt, void* vaddr) {
    //TODO fix
    return pt_walk(pt, vaddr, 0);
}

//recursively frees the entire pagetable and the underlying physical pages. 
//assumes that each physical page is only mapped once. 
void pt_free_pagetable(u64* pt, u64 level) {
    for(i32 i = 0; i < 512; i++){
        u64 pte = pt[i];
        if(!(pte & PTE_PRESENT)) continue;

        //if this is not a leaf, free subtree
        if(level) pt_free_pagetable(pte_get_addr(pte), level - $u64 1);

        //if this is a leaf, free the mem directly
        if(!level) pfree($void* pte_get_addr(pte));
    }

    //free this pt
    pfree($void* pt);
}

//unmaps all physical memory above 2MB. 
//the actual purpose of this is to get rid of all huge pages. 
void pt_unmap_above_2MB(u64* pt, u64 level) {
    for(i32 i = 0; i < 512; i++){
        u64 pte = pt[i];
        if(!(pte & PTE_PRESENT)) continue;

        u64* addr = pte_get_addr(pte);
        if($u64 addr >= 0x200000) pt[i] = $u64 0;
        else if(level) pt_unmap_above_2MB($u64* addr, level - $u64 1);
    }
}

void pt_print(u64* pt, u64 level, i32 indent) {
    for(i32 i = 0; i < 512; i++){
        u64 pte = pt[i];
        if(!(pte & PTE_PRESENT)) continue;
        if(level) pt_print(pte_get_addr(pte), level - $u64 1, indent + 1);
    }
    for(i32 i = 0; i < indent; i++) serial_print("    ");
    serial_println(pt);
}

void pt_free_pagetable(u64* pt) {
    pt_free_pagetable(pt, $u64 3);
}
