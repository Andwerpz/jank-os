
// kernel space synchronization
// the assumption when I wrote this is that hardware interrupts are turned off, so we won't have any
//  interrupts in unexpected locations. 
// if this assumption is not true, then the code around locking and unlocking may need to be rewritten
//  to include atomic CAS assembly instructions

struct mutex {
    i32 locked;
    waitq wait_queue;
    pid_t owner;

    mutex() {
        this.locked = 0;
        this.owner = $pid_t 0;
    }

    mutex(mutex& other) {
        panic("mutex : should not be copied");
    }

    ~mutex() {
        assert(this.locked == 0, "mutex::~() : cannot be locked when destructing");
    }
    
    void lock() {
        //check if currently locked
        if(this.locked) {
            //block process, if mutex becomes unlocked, will unblock a process from queue
            assert(this.owner != $pid_t 0, "mutex::lock() : must have owner when locked");
            wait_on(@(this.wait_queue));
            assert(!this.locked, "mutex::lock() : should be unlocked when woken up");
        }

        //acquire lock
        assert(this.owner == $pid_t 0, "mutex::lock() : must not have owner");
        this.locked = 1;
        this.owner = get_cur_pid();
    }

    void unlock() {
        assert(this.locked, "mutex::unlock() : should be locked when trying to unlock");
        assert(this.owner != $pid_t 0, "mutex::unlock() : there has to be an owner");
        assert(this.owner == get_cur_pid(), "mutex::unlock() : only owner can unlock");
        this.locked = 0;
        this.owner = $pid_t 0;

        //if there are blocked processes, unblock one
        waitq_wake_one(@(this.wait_queue));
    }
}
