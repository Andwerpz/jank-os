
struct mutex {
    i32 locked;
    deque<pid_t> wait_queue;
    pid_t owner;

    mutex() {
        this.locked = 0;
        this.owner = $pid_t 0;
    }

    mutex(mutex& other) {
        panic("mutex : should not be copied");
    }

    ~mutex() {
        passert(this.locked == 0, "mutex::~() : cannot be locked when destructing");
    }
    
    void lock() {
        irq_disable();
        if(this.locked) {
            passert(this.owner != $pid_t 0, "mutex::lock() : must have owner when locked");

            //block process, if mutex becomes unlocked, will unblock a process from queue
            process* proc = get_cur_proc();
            proc->status = PROCESS_BLOCKED;
            this.wait_queue.push_back(proc->pid);
            irq_enable();

            yield();

            irq_disable();
            passert(!this.locked, "mutex::lock() : should be unlocked when woken up");
        }

        passert(this.owner == $pid_t 0, "mutex::lock() : must not have owner");

        this.locked = 1;
        this.owner = get_cur_pid();
        irq_enable();
    }

    void unlock() {
        irq_disable();
        
        passert(this.locked, "mutex::unlock() : should be locked when trying to unlock");
        passert(this.owner != $pid_t 0, "mutex::unlock() : there has to be an owner");
        passert(this.owner == get_cur_pid(), "mutex::unlock() : only owner can unlock");
        this.locked = 0;
        this.owner = $pid_t 0;

        //if there are blocked processes, unblock one
        if(this.wait_queue.size()){
            process* nextp = find_process(this.wait_queue.pop_front());
            passert(nextp->status == PROCESS_BLOCKED, "mutex::unlock() : process in queue should be blocked");
            nextp->status = PROCESS_READY;
        }

        irq_enable();
    }
}
