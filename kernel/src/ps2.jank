// PS/2, from the IBM Personal System / 2 series of personal computers

// PS2 communicates via two serial ports, 0x60 and 0x64
// 0x60 is the data port
// 0x64 is the status/command port. status when reading, command when writing

// when reading/writing, you must wait for a corresponding status bit to be on
// status bit 0 : output buffer full, only read when this is set
// status bit 1 : input buffer full, only write when this is not set

// the codes generated by a PS2 keyboard are called scancodes
// for each key on the keyboard, there is a different sequence of bytes that gets sent whenever that key
//   gets pressed or released
// the job of this driver is to poll for these scancodes and translate them into key events
// there are several different scancode sets, however scancode set 2 is used as default by all modern PS2 keyboards

// list of scancodes:
// http://www.technoblogy.com/show?4QEL

[__GLOBAL_FIRST__] u16 PS2_DATA = $u16 0x60;
[__GLOBAL_FIRST__] u16 PS2_STATUS = $u16 0x64;

u8 ps2_read_status() {
    return inb(PS2_STATUS);
}

void ps2_write_command(u8 c) {
    while(ps2_read_status() & ($u8 0x2)) { /* spin */ }
    outb(PS2_STATUS, c);
}

u8 ps2_read_data() {
    while(!(ps2_read_status() & ($u8 0x1))) { /* spin */ }
    return inb(PS2_DATA);
}

void ps2_write_data(u8 c) {
    while(ps2_read_status() & ($u8 0x2)) { /* spin */ }
    outb(PS2_DATA, c);
}

//returns 0 on success, 1 on failure
i32 ps2_poll_data(u8& c) {
    if(ps2_read_status() & ($u8 0x1)) {
        c = inb(PS2_DATA);
        return 0;
    }
    return 1;
}

u8 i8042_read_cfg() {
    ps2_write_command($u8 0x20);
    return ps2_read_data();               
}

void i8042_write_cfg(u8 cfg) {
    ps2_write_command($u8 0x60);
    ps2_write_data(cfg);
}

//original IBM keyboards used scancode set 1, while newer keyboards use set 2
//for compatability reasons, the controller has a translation feature from set 2 to set 1
//this disables that feature
void i8042_disable_translation() {
    u8 cfg = i8042_read_cfg();
    cfg &= ~($u8 0x40);   // clear bit 6 : translation
    i8042_write_cfg(cfg);
}

void i8042_enable_interrupts() {
    u8 cfg = i8042_read_cfg();
    cfg |= ($u8 0x01);   // set bit 0 : interrupt enable
    i8042_write_cfg(cfg);
}

// ACK = 0xFA, RESEND = 0xFE
void ps2_write_data_expect_ack(u8 c) {
    while(1) {
        // flush pending bytes
        while(ps2_read_status() & ($u8 0x1)) inb(PS2_DATA);

        // write to data
        ps2_write_data(c);

        // get response
        u8 r = ps2_read_data();

        if (r == $u8 0xFA) return;          // ACK
        if (r == $u8 0xFE) continue;        // RESEND

        panic("ps2_write_expect_ack() : unexpected response");
    }
}

void init_ps2() {
    println("start init ps2");

    // reset
    ps2_write_data_expect_ack($u8 0xFF);
    u8 bat = ps2_read_data();           // also expect BAT result (0xAA pass, 0xFC/0xFD fail)
    if (bat != $u8 0xAA) panic("init_ps2() : bad BAT");

    // set scancode set 2
    ps2_write_data_expect_ack($u8 0xF0);
    ps2_write_data_expect_ack($u8 0x02);

    // setup i8042
    i8042_disable_translation();
    i8042_enable_interrupts();

    // enable scanning
    ps2_write_data_expect_ack($u8 0xF4);

    // initialize scancode set 2 mapsets
    PS2_MAPSET2 = $u32* malloc(sizeof(u32) * 0xFF);
    PS2_MAPSET2_EXT = $u32* malloc(sizeof(u32) * 0xFF);
    for(u64 i = 0x0; i < 0xFF; i++) {
        PS2_MAPSET2[i] = KEYCODE_INVALID;
        PS2_MAPSET2_EXT[i] = KEYCODE_INVALID;
    }

    PS2_MAPSET2[0x76] = KEYCODE_ESC;
    PS2_MAPSET2[0x05] = KEYCODE_F1;
    PS2_MAPSET2[0x06] = KEYCODE_F2;
    PS2_MAPSET2[0x04] = KEYCODE_F3;
    PS2_MAPSET2[0x0C] = KEYCODE_F4;
    PS2_MAPSET2[0x03] = KEYCODE_F5;
    PS2_MAPSET2[0x0B] = KEYCODE_F6;
    PS2_MAPSET2[0x83] = KEYCODE_F7;
    PS2_MAPSET2[0x0A] = KEYCODE_F8;
    PS2_MAPSET2[0x01] = KEYCODE_F9;
    PS2_MAPSET2[0x09] = KEYCODE_F10;
    PS2_MAPSET2[0x78] = KEYCODE_F11;
    PS2_MAPSET2[0x07] = KEYCODE_F12;
    PS2_MAPSET2[0x7E] = KEYCODE_SCROLLLOCK;

    PS2_MAPSET2[0x0E] = KEYCODE_GRAVE;
    PS2_MAPSET2[0x16] = KEYCODE_1;
    PS2_MAPSET2[0x1E] = KEYCODE_2;
    PS2_MAPSET2[0x26] = KEYCODE_3;
    PS2_MAPSET2[0x25] = KEYCODE_4;
    PS2_MAPSET2[0x2E] = KEYCODE_5;
    PS2_MAPSET2[0x36] = KEYCODE_6;
    PS2_MAPSET2[0x3D] = KEYCODE_7;
    PS2_MAPSET2[0x3E] = KEYCODE_8;
    PS2_MAPSET2[0x46] = KEYCODE_9;
    PS2_MAPSET2[0x45] = KEYCODE_0;
    PS2_MAPSET2[0x4E] = KEYCODE_MINUS;
    PS2_MAPSET2[0x55] = KEYCODE_EQUAL;
    PS2_MAPSET2[0x66] = KEYCODE_BACKSPACE;

    PS2_MAPSET2[0x0D] = KEYCODE_TAB;
    PS2_MAPSET2[0x15] = KEYCODE_Q;
    PS2_MAPSET2[0x1D] = KEYCODE_W;
    PS2_MAPSET2[0x24] = KEYCODE_E;
    PS2_MAPSET2[0x2D] = KEYCODE_R;
    PS2_MAPSET2[0x2C] = KEYCODE_T;
    PS2_MAPSET2[0x35] = KEYCODE_Y;
    PS2_MAPSET2[0x3C] = KEYCODE_U;
    PS2_MAPSET2[0x43] = KEYCODE_I;
    PS2_MAPSET2[0x44] = KEYCODE_O;
    PS2_MAPSET2[0x4D] = KEYCODE_P;
    PS2_MAPSET2[0x54] = KEYCODE_LBRACKET;
    PS2_MAPSET2[0x5B] = KEYCODE_RBRACKET;
    PS2_MAPSET2[0x5D] = KEYCODE_BACKSLASH;

    PS2_MAPSET2[0x58] = KEYCODE_CAPSLOCK;
    PS2_MAPSET2[0x1C] = KEYCODE_A;
    PS2_MAPSET2[0x1B] = KEYCODE_S;
    PS2_MAPSET2[0x23] = KEYCODE_D;
    PS2_MAPSET2[0x2B] = KEYCODE_F;
    PS2_MAPSET2[0x34] = KEYCODE_G;
    PS2_MAPSET2[0x33] = KEYCODE_H;
    PS2_MAPSET2[0x3B] = KEYCODE_J;
    PS2_MAPSET2[0x42] = KEYCODE_K;
    PS2_MAPSET2[0x4B] = KEYCODE_L;
    PS2_MAPSET2[0x4C] = KEYCODE_SEMICOLON;
    PS2_MAPSET2[0x52] = KEYCODE_APOSTROPHE;
    PS2_MAPSET2[0x5A] = KEYCODE_ENTER;

    PS2_MAPSET2[0x12] = KEYCODE_LSHIFT;
    PS2_MAPSET2[0x1A] = KEYCODE_Z;
    PS2_MAPSET2[0x22] = KEYCODE_X;
    PS2_MAPSET2[0x21] = KEYCODE_C;
    PS2_MAPSET2[0x2A] = KEYCODE_V;
    PS2_MAPSET2[0x32] = KEYCODE_B;
    PS2_MAPSET2[0x31] = KEYCODE_N;
    PS2_MAPSET2[0x3A] = KEYCODE_M;
    PS2_MAPSET2[0x41] = KEYCODE_COMMA;
    PS2_MAPSET2[0x49] = KEYCODE_DOT;
    PS2_MAPSET2[0x4A] = KEYCODE_SLASH;
    PS2_MAPSET2[0x59] = KEYCODE_RSHIFT;

    PS2_MAPSET2[0x14] = KEYCODE_LCTRL;
    PS2_MAPSET2[0x11] = KEYCODE_LALT;
    PS2_MAPSET2[0x29] = KEYCODE_SPACE;

    PS2_MAPSET2[0x77] = KEYCODE_NUMLOCK;
    PS2_MAPSET2[0x7C] = KEYCODE_KP_MULTIPLY;
    PS2_MAPSET2[0x7B] = KEYCODE_KP_MINUS;
    PS2_MAPSET2[0x6C] = KEYCODE_KP_7;
    PS2_MAPSET2[0x75] = KEYCODE_KP_8;
    PS2_MAPSET2[0x7D] = KEYCODE_KP_9;
    PS2_MAPSET2[0x79] = KEYCODE_KP_PLUS;
    PS2_MAPSET2[0x6B] = KEYCODE_KP_4;
    PS2_MAPSET2[0x73] = KEYCODE_KP_5;
    PS2_MAPSET2[0x74] = KEYCODE_KP_6;
    PS2_MAPSET2[0x69] = KEYCODE_KP_1;
    PS2_MAPSET2[0x72] = KEYCODE_KP_2;
    PS2_MAPSET2[0x7A] = KEYCODE_KP_3;
    PS2_MAPSET2[0x70] = KEYCODE_KP_0;
    PS2_MAPSET2[0x71] = KEYCODE_KP_DOT;

    PS2_MAPSET2_EXT[0x1F] = KEYCODE_LGUI;
    PS2_MAPSET2_EXT[0x11] = KEYCODE_LALT;
    PS2_MAPSET2_EXT[0x27] = KEYCODE_RGUI;
    PS2_MAPSET2_EXT[0x2F] = KEYCODE_MENU;
    PS2_MAPSET2_EXT[0x14] = KEYCODE_RCTRL;
    
    PS2_MAPSET2_EXT[0x70] = KEYCODE_INSERT;
    PS2_MAPSET2_EXT[0x6C] = KEYCODE_HOME;
    PS2_MAPSET2_EXT[0x7D] = KEYCODE_PAGEUP;
    PS2_MAPSET2_EXT[0x71] = KEYCODE_DELETE;
    PS2_MAPSET2_EXT[0x69] = KEYCODE_END;
    PS2_MAPSET2_EXT[0x7A] = KEYCODE_PAGEDOWN;

    PS2_MAPSET2_EXT[0x75] = KEYCODE_UP;
    PS2_MAPSET2_EXT[0x6B] = KEYCODE_LEFT;
    PS2_MAPSET2_EXT[0x72] = KEYCODE_DOWN;
    PS2_MAPSET2_EXT[0x74] = KEYCODE_RIGHT;

    PS2_MAPSET2_EXT[0x4A] = KEYCODE_KP_DIVIDE;
    PS2_MAPSET2_EXT[0x5A] = KEYCODE_KP_ENTER;

    println("done init ps2");
}


//finite state machine scancode parser
[__GLOBAL_FIRST__] u64 PS2_STATE_ENTRY      = 0x1;
[__GLOBAL_FIRST__] u64 PS2_STATE_F0         = 0x2;      // saw F0
[__GLOBAL_FIRST__] u64 PS2_STATE_E0         = 0x3;      // saw E0
[__GLOBAL_FIRST__] u64 PS2_STATE_E0_F0      = 0x4;      // saw E0 F0
[__GLOBAL_FIRST__] u64 PS2_STATE_PAUSE      = 0x5;      // saw E1, collecting bytes
[__GLOBAL_FIRST__] u64 PS2_STATE_PRTM       = 0x6;      // saw E0 12, collecting bytes
[__GLOBAL_FIRST__] u64 PS2_STATE_PRTB       = 0x7;      // saw E0 F0 7C, collecting bytes
[__GLOBAL_FIRST__] u64 PS2_SEQ_BYTES_LEFT;  //for long sequences (Pause, PrtScr)

[PS2] u64 PS2_PARSE_STATE = PS2_STATE_ENTRY;

[__GLOBAL_FIRST__] u32* PS2_MAPSET2;
[__GLOBAL_FIRST__] u32* PS2_MAPSET2_EXT;

//if extended is true, will translate all two-byte scancodes that are prefixed with 0xE0
//otherwise, only translates single byte scancodes
u32 ps2_map_set2(u8 code, i32 extended) {
    if(extended) return PS2_MAPSET2_EXT[code];
    else return PS2_MAPSET2[code];
}

//sends key events to kbinput controller
void ps2_accept_char(u8 c) {
    if(PS2_PARSE_STATE == PS2_STATE_ENTRY) {
        if(c == $u8 0xF0) {
            PS2_PARSE_STATE = PS2_STATE_F0;
        }
        else if(c == $u8 0xE0) {
            PS2_PARSE_STATE = PS2_STATE_E0;
        }
        else if(c == $u8 0xE1) {
            PS2_PARSE_STATE = PS2_STATE_PAUSE;
            PS2_SEQ_BYTES_LEFT = 0x7;
        }
        else {
            u32 keycode = ps2_map_set2(c, 0);
            kb_write_keyevent(keycode, KEYACTION_DOWN);
            PS2_PARSE_STATE = PS2_STATE_ENTRY;
        }
    }
    else if(PS2_PARSE_STATE == PS2_STATE_F0) {
        u32 keycode = ps2_map_set2(c, 0);
        kb_write_keyevent(keycode, KEYACTION_UP);
        PS2_PARSE_STATE = PS2_STATE_ENTRY;
    }
    else if(PS2_PARSE_STATE == PS2_STATE_E0) {
        if(c == $u8 0xF0) {
            PS2_PARSE_STATE = PS2_STATE_E0_F0;
        }
        else if(c == $u8 0x12) {
            PS2_PARSE_STATE = PS2_STATE_PRTM;
            PS2_SEQ_BYTES_LEFT = 0x2;
        }
        else {
            u32 keycode = ps2_map_set2(c, 1);
            kb_write_keyevent(keycode, KEYACTION_DOWN);
            PS2_PARSE_STATE = PS2_STATE_ENTRY;
        }
    }
    else if(PS2_PARSE_STATE == PS2_STATE_E0_F0) {
        if(c == $u8 0x7C) {
            PS2_PARSE_STATE = PS2_STATE_PRTB;
            PS2_SEQ_BYTES_LEFT = 0x3;
        }
        else {
            u32 keycode = ps2_map_set2(c, 1);
            kb_write_keyevent(keycode, KEYACTION_UP);
            PS2_PARSE_STATE = PS2_STATE_ENTRY;
        }
    }
    else if(PS2_PARSE_STATE == PS2_STATE_PAUSE) {
        if(PS2_SEQ_BYTES_LEFT == 0x7) {
            if(c == $u8 0x14) PS2_SEQ_BYTES_LEFT --;
            else PS2_PARSE_STATE = PS2_STATE_ENTRY;
        }
        else if(PS2_SEQ_BYTES_LEFT == 0x6) {
            if(c == $u8 0x77) PS2_SEQ_BYTES_LEFT --;
            else PS2_PARSE_STATE = PS2_STATE_ENTRY;
        }
        else if(PS2_SEQ_BYTES_LEFT == 0x5) {
            if(c == $u8 0xE1) PS2_SEQ_BYTES_LEFT --;
            else PS2_PARSE_STATE = PS2_STATE_ENTRY;
        }
        else if(PS2_SEQ_BYTES_LEFT == 0x4) {
            if(c == $u8 0xF0) PS2_SEQ_BYTES_LEFT --;
            else PS2_PARSE_STATE = PS2_STATE_ENTRY;
        }
        else if(PS2_SEQ_BYTES_LEFT == 0x3) {
            if(c == $u8 0x14) PS2_SEQ_BYTES_LEFT --;
            else PS2_PARSE_STATE = PS2_STATE_ENTRY;
        }
        else if(PS2_SEQ_BYTES_LEFT == 0x2) {
            if(c == $u8 0xE0) PS2_SEQ_BYTES_LEFT --;
            else PS2_PARSE_STATE = PS2_STATE_ENTRY;
        }
        else if(PS2_SEQ_BYTES_LEFT == 0x1) {
            if(c == $u8 0x77) PS2_SEQ_BYTES_LEFT --;
            else PS2_PARSE_STATE = PS2_STATE_ENTRY;
        }
        else panic("ps2_accept_char() : PS2_STATE_PAUSE invalid bytes left count");
        if(PS2_SEQ_BYTES_LEFT == 0x0) {
            kb_write_keyevent(KEYCODE_PAUSE, KEYACTION_DOWN);
            PS2_PARSE_STATE = PS2_STATE_ENTRY;
        }
    }
    else if(PS2_PARSE_STATE == PS2_STATE_PRTM) {
        if(PS2_SEQ_BYTES_LEFT == 0x2) {
            if(c == $u8 0xE0) PS2_SEQ_BYTES_LEFT --;
            else PS2_PARSE_STATE = PS2_STATE_ENTRY;
        }
        else if(PS2_SEQ_BYTES_LEFT == 0x1) {
            if(c == $u8 0x7C) PS2_SEQ_BYTES_LEFT --;
            else PS2_PARSE_STATE = PS2_STATE_ENTRY;
        }
        else panic("ps2_accept_char() : PS2_STATE_PRTM invalid bytes left count");
        if(PS2_SEQ_BYTES_LEFT == 0x0) {
            kb_write_keyevent(KEYCODE_PRINTSCREEN, KEYACTION_DOWN);
            PS2_PARSE_STATE = PS2_STATE_ENTRY;
        }
    }
    else if(PS2_PARSE_STATE == PS2_STATE_PRTB) {
        if(PS2_SEQ_BYTES_LEFT == 0x3) {
            if(c == $u8 0xE0) PS2_SEQ_BYTES_LEFT --;
            else PS2_PARSE_STATE = PS2_STATE_ENTRY;
        }
        else if(PS2_SEQ_BYTES_LEFT == 0x2) {
            if(c == $u8 0xF0) PS2_SEQ_BYTES_LEFT --;
            else PS2_PARSE_STATE = PS2_STATE_ENTRY;
        }
        else if(PS2_SEQ_BYTES_LEFT == 0x1) {
            if(c == $u8 0x12) PS2_SEQ_BYTES_LEFT --;
            else PS2_PARSE_STATE = PS2_STATE_ENTRY;
        }
        else panic("ps2_accept_char() : PS2_STATE_PRTB invalid bytes left count");
        if(PS2_SEQ_BYTES_LEFT == 0x0) {
            kb_write_keyevent(KEYCODE_PRINTSCREEN, KEYACTION_UP);
            PS2_PARSE_STATE = PS2_STATE_ENTRY;
        }
    }
    else panic("ps2_accept_char() : invalid parse state");
}



