// PS/2, from the IBM Personal System / 2 series of personal computers

// PS2 communicates via two serial ports, 0x60 and 0x64
// 0x60 is the data port
// 0x64 is the status/command port. status when reading, command when writing

// when reading/writing, you must wait for a corresponding status bit to be on
// status bit 0 : output buffer full, only read when this is set
// status bit 1 : input buffer full, only write when this is not set

// the PS/2 controller itself has connectors for 2 physical devices, 
// usually the first connector is for a keyboard and the second one is for a mouse or touchpad. 

// the codes generated by a PS2 keyboard are called scancodes
// for each key on the keyboard, there is a different sequence of bytes that gets sent whenever that key
//   gets pressed or released
// the job of this driver is to poll for these scancodes and translate them into key events
// there are several different scancode sets, however scancode set 2 is used as default by all modern PS2 keyboards

// list of scancodes:
// http://www.technoblogy.com/show?4QEL

[__GLOBAL_FIRST__] u16 PS2_DATA = $u16 0x60;
[__GLOBAL_FIRST__] u16 PS2_STATUS = $u16 0x64;

[__GLOBAL_FIRST__] u8 PS2_STATUS_INPUT_BUFFER_FULL      = $u8 0b00000001;   // input buffer full, only write when this is not set
[__GLOBAL_FIRST__] u8 PS2_STATUS_OUTPUT_BUFFER_FULL     = $u8 0b00000010;   // output buffer full, only read when this is set
[__GLOBAL_FIRST__] u8 PS2_STATUS_SYSTEM_FLAG            = $u8 0b00000100;       
[__GLOBAL_FIRST__] u8 PS2_STATUS_COMMAND_DATA           = $u8 0b00001000;

[__GLOBAL_FIRST__] u8 PS2_COMMAND_READ_BYTE0            = $u8 0x20;     // reads byte 0 of PS2 internal RAM, data should arrive in data port
[__GLOBAL_FIRST__] u8 PS2_COMMAND_WRITE_BYTE0           = $u8 0x60;     // writes byte 0 of PS2 interal RAM, data should be written to data port
[__GLOBAL_FIRST__] u8 PS2_COMMAND_DISABLE_SECOND_PORT   = $u8 0xA7;
[__GLOBAL_FIRST__] u8 PS2_COMMAND_ENABLE_SECOND_PORT    = $u8 0xA8;
[__GLOBAL_FIRST__] u8 PS2_COMMAND_TEST_SECOND_PORT      = $u8 0xA9;     // 0x00 : test passed
[__GLOBAL_FIRST__] u8 PS2_COMMAND_SELF_TEST             = $u8 0xAA;     // 0x55 : test passed, 0xFC : test failed. Data arrives in data port
[__GLOBAL_FIRST__] u8 PS2_COMMAND_TEST_FIRST_PORT       = $u8 0xAB;     // 0x00 : test passed
[__GLOBAL_FIRST__] u8 PS2_COMMAND_DISABLE_FIRST_PORT    = $u8 0xAD;
[__GLOBAL_FIRST__] u8 PS2_COMMAND_ENABLE_FIRST_PORT     = $u8 0xAE;
[__GLOBAL_FIRST__] u8 PS2_COMMAND_WRITE_TO_SECOND_PORT  = $u8 0xD4;     // the next byte written to the data port will be written to the second device instead of the first. Make sure that there actually is a second device or the byte will just be sent to the first one. 

// PS2 configuration byte, first byte of PS2 internal RAM
[__GLOBAL_FIRST__] u8 PS2_CONFIG_FIRST_PORT_INTERRUPT   = $u8 0b00000001;   // 1 : enabled, 0 : disabled
[__GLOBAL_FIRST__] u8 PS2_CONFIG_SECOND_PORT_INTERRUPT  = $u8 0b00000010;   // 1 : enabled, 0 : disabled
[__GLOBAL_FIRST__] u8 PS2_CONFIG_SYSTEM_FLAG            = $u8 0b00000100;   // should be 1 (??)
[__GLOBAL_FIRST__] u8 PS2_CONFIG_RESERVED0              = $u8 0b00001000;   // should be 0
[__GLOBAL_FIRST__] u8 PS2_CONFIG_FIRST_PORT_CLOCK       = $u8 0b00010000;   // 1 : disabled, 0 : enabled
[__GLOBAL_FIRST__] u8 PS2_CONFIG_SECOND_PORT_CLOCK      = $u8 0b00100000;   // 1 : disabled, 0 : enabled
[__GLOBAL_FIRST__] u8 PS2_CONFIG_FIRST_PORT_TRANSLATION = $u8 0b01000000;   // 1 : translation to scancode set 1 enabled, 0 : translation disabled
[__GLOBAL_FIRST__] u8 PS2_CONFIG_RESERVED1              = $u8 0b10000000;   // should be 0

u8 ps2_read_status() {
    return inb(PS2_STATUS);
}

void ps2_write_command(u8 c) {
    while(ps2_read_status() & PS2_STATUS_OUTPUT_BUFFER_FULL) { /* spin */ }
    outb(PS2_STATUS, c);
}

u8 ps2_read_data() {
    while(!(ps2_read_status() & PS2_STATUS_INPUT_BUFFER_FULL)) { /* spin */ }
    return inb(PS2_DATA);
}

void ps2_write_data(u8 c) {
    while(ps2_read_status() & PS2_STATUS_OUTPUT_BUFFER_FULL) { /* spin */ }
    outb(PS2_DATA, c);
}

//returns 0 on success, 1 on failure
i32 ps2_poll_data(u8& c) {
    if(ps2_read_status() & PS2_STATUS_INPUT_BUFFER_FULL) {
        c = inb(PS2_DATA);
        return 0;
    }
    return 1;
}

//makes sure incoming data buffer is empty
void ps2_flush_data() {
    while(ps2_read_status() & PS2_STATUS_OUTPUT_BUFFER_FULL) inb(PS2_DATA);
}

u8 i8042_read_cfg() {
    ps2_write_command(PS2_COMMAND_READ_BYTE0);
    return ps2_read_data();               
}

void i8042_write_cfg(u8 cfg) {
    ps2_write_command(PS2_COMMAND_WRITE_BYTE0);
    ps2_write_data(cfg);
}

//original IBM keyboards used scancode set 1, while newer keyboards use set 2
//for compatability reasons, the controller has a translation feature from set 2 to set 1
//this disables that feature
void i8042_disable_translation() {
    u8 cfg = i8042_read_cfg();
    cfg &= ~($u8 0x40);   // clear bit 6 : translation
    i8042_write_cfg(cfg);
}

void i8042_enable_interrupts() {
    u8 cfg = i8042_read_cfg();
    cfg |= ($u8 0x01);   // set bit 0 : interrupt enable
    i8042_write_cfg(cfg);
}

// ACK = 0xFA, RESEND = 0xFE
void ps2_write_data_expect_ack(u8 c) {
    while(1) {
        // flush pending bytes
        ps2_flush_data();

        // write to data
        ps2_write_data(c);

        // get response
        u8 r = ps2_read_data();

        if (r == $u8 0xFA) return;          // ACK
        if (r == $u8 0xFE) continue;        // RESEND

        println("ps2_write_expect_ack() : unexpected response : ", $void* $u64 r);
        panic("ps2_write_expect_ack() : unexpected response");
    }
}

void init_ps2() {
    println("start init ps2");

    // TODO check in ACPI to see if PS2 controller even exists
    // TODO handle second port properly

    // disable both ports
    ps2_write_command(PS2_COMMAND_DISABLE_FIRST_PORT);
    ps2_write_command(PS2_COMMAND_DISABLE_SECOND_PORT);
    println("ports disabled");

    // flush all input data
    ps2_flush_data();
    println("data flushed");

    // set controller configuration byte
    {
        u8 cfg = i8042_read_cfg();
        println("controller cfg read");
        cfg &= ~PS2_CONFIG_FIRST_PORT_TRANSLATION;  // disable translation to scancode 1
        cfg &= ~PS2_CONFIG_FIRST_PORT_INTERRUPT;    // disable CPU interrupts for first port
        cfg &= ~PS2_CONFIG_SECOND_PORT_INTERRUPT;   // disable CPU interrupts for the second port
        i8042_write_cfg(cfg);
        println("controller configuration set");
    }

    // controller self test
    ps2_write_command(PS2_COMMAND_SELF_TEST);
    if(ps2_read_data() != $u8 0x55) panic("init_ps2() : self test failed");
    println("self test passed");

    // test first port
    ps2_write_command(PS2_COMMAND_TEST_FIRST_PORT);
    if(ps2_read_data() != $u8 0x00) panic("init_ps2() : test first port failed");
    println("first port test passed");

    // enable first port
    ps2_write_command(PS2_COMMAND_ENABLE_FIRST_PORT);
    println("first port enabled");

    // reset first port device
    ps2_write_data_expect_ack($u8 0xFF);
    u8 bat = ps2_read_data();           // also expect BAT result (0xAA pass, 0xFC/0xFD fail)
    if(bat != $u8 0xAA) panic("init_ps2() : bad BAT");
    println("device reset");

    // enable interrupts for first port
    {
        u8 cfg = i8042_read_cfg();
        cfg |= PS2_CONFIG_FIRST_PORT_INTERRUPT;     // enable CPU interrupts for first port
        cfg &= ~PS2_CONFIG_FIRST_PORT_CLOCK;        // enable port clock for first port 
        i8042_write_cfg(cfg);
    }

    // set scancode set 2
    ps2_write_data_expect_ack($u8 0xF0);
    ps2_write_data_expect_ack($u8 0x02);

    // enable scanning
    ps2_write_data_expect_ack($u8 0xF4);

    // initialize scancode set 2 mapsets
    PS2_MAPSET2 = $u32* malloc(sizeof(u32) * 0xFF);
    PS2_MAPSET2_EXT = $u32* malloc(sizeof(u32) * 0xFF);
    for(u64 i = 0x0; i < 0xFF; i++) {
        PS2_MAPSET2[i] = KEYCODE_INVALID;
        PS2_MAPSET2_EXT[i] = KEYCODE_INVALID;
    }

    PS2_MAPSET2[0x76] = KEYCODE_ESC;
    PS2_MAPSET2[0x05] = KEYCODE_F1;
    PS2_MAPSET2[0x06] = KEYCODE_F2;
    PS2_MAPSET2[0x04] = KEYCODE_F3;
    PS2_MAPSET2[0x0C] = KEYCODE_F4;
    PS2_MAPSET2[0x03] = KEYCODE_F5;
    PS2_MAPSET2[0x0B] = KEYCODE_F6;
    PS2_MAPSET2[0x83] = KEYCODE_F7;
    PS2_MAPSET2[0x0A] = KEYCODE_F8;
    PS2_MAPSET2[0x01] = KEYCODE_F9;
    PS2_MAPSET2[0x09] = KEYCODE_F10;
    PS2_MAPSET2[0x78] = KEYCODE_F11;
    PS2_MAPSET2[0x07] = KEYCODE_F12;
    PS2_MAPSET2[0x7E] = KEYCODE_SCROLLLOCK;

    PS2_MAPSET2[0x0E] = KEYCODE_GRAVE;
    PS2_MAPSET2[0x16] = KEYCODE_1;
    PS2_MAPSET2[0x1E] = KEYCODE_2;
    PS2_MAPSET2[0x26] = KEYCODE_3;
    PS2_MAPSET2[0x25] = KEYCODE_4;
    PS2_MAPSET2[0x2E] = KEYCODE_5;
    PS2_MAPSET2[0x36] = KEYCODE_6;
    PS2_MAPSET2[0x3D] = KEYCODE_7;
    PS2_MAPSET2[0x3E] = KEYCODE_8;
    PS2_MAPSET2[0x46] = KEYCODE_9;
    PS2_MAPSET2[0x45] = KEYCODE_0;
    PS2_MAPSET2[0x4E] = KEYCODE_MINUS;
    PS2_MAPSET2[0x55] = KEYCODE_EQUAL;
    PS2_MAPSET2[0x66] = KEYCODE_BACKSPACE;

    PS2_MAPSET2[0x0D] = KEYCODE_TAB;
    PS2_MAPSET2[0x15] = KEYCODE_Q;
    PS2_MAPSET2[0x1D] = KEYCODE_W;
    PS2_MAPSET2[0x24] = KEYCODE_E;
    PS2_MAPSET2[0x2D] = KEYCODE_R;
    PS2_MAPSET2[0x2C] = KEYCODE_T;
    PS2_MAPSET2[0x35] = KEYCODE_Y;
    PS2_MAPSET2[0x3C] = KEYCODE_U;
    PS2_MAPSET2[0x43] = KEYCODE_I;
    PS2_MAPSET2[0x44] = KEYCODE_O;
    PS2_MAPSET2[0x4D] = KEYCODE_P;
    PS2_MAPSET2[0x54] = KEYCODE_LBRACKET;
    PS2_MAPSET2[0x5B] = KEYCODE_RBRACKET;
    PS2_MAPSET2[0x5D] = KEYCODE_BACKSLASH;

    PS2_MAPSET2[0x58] = KEYCODE_CAPSLOCK;
    PS2_MAPSET2[0x1C] = KEYCODE_A;
    PS2_MAPSET2[0x1B] = KEYCODE_S;
    PS2_MAPSET2[0x23] = KEYCODE_D;
    PS2_MAPSET2[0x2B] = KEYCODE_F;
    PS2_MAPSET2[0x34] = KEYCODE_G;
    PS2_MAPSET2[0x33] = KEYCODE_H;
    PS2_MAPSET2[0x3B] = KEYCODE_J;
    PS2_MAPSET2[0x42] = KEYCODE_K;
    PS2_MAPSET2[0x4B] = KEYCODE_L;
    PS2_MAPSET2[0x4C] = KEYCODE_SEMICOLON;
    PS2_MAPSET2[0x52] = KEYCODE_APOSTROPHE;
    PS2_MAPSET2[0x5A] = KEYCODE_ENTER;

    PS2_MAPSET2[0x12] = KEYCODE_LSHIFT;
    PS2_MAPSET2[0x1A] = KEYCODE_Z;
    PS2_MAPSET2[0x22] = KEYCODE_X;
    PS2_MAPSET2[0x21] = KEYCODE_C;
    PS2_MAPSET2[0x2A] = KEYCODE_V;
    PS2_MAPSET2[0x32] = KEYCODE_B;
    PS2_MAPSET2[0x31] = KEYCODE_N;
    PS2_MAPSET2[0x3A] = KEYCODE_M;
    PS2_MAPSET2[0x41] = KEYCODE_COMMA;
    PS2_MAPSET2[0x49] = KEYCODE_DOT;
    PS2_MAPSET2[0x4A] = KEYCODE_SLASH;
    PS2_MAPSET2[0x59] = KEYCODE_RSHIFT;

    PS2_MAPSET2[0x14] = KEYCODE_LCTRL;
    PS2_MAPSET2[0x11] = KEYCODE_LALT;
    PS2_MAPSET2[0x29] = KEYCODE_SPACE;

    PS2_MAPSET2[0x77] = KEYCODE_NUMLOCK;
    PS2_MAPSET2[0x7C] = KEYCODE_KP_MULTIPLY;
    PS2_MAPSET2[0x7B] = KEYCODE_KP_MINUS;
    PS2_MAPSET2[0x6C] = KEYCODE_KP_7;
    PS2_MAPSET2[0x75] = KEYCODE_KP_8;
    PS2_MAPSET2[0x7D] = KEYCODE_KP_9;
    PS2_MAPSET2[0x79] = KEYCODE_KP_PLUS;
    PS2_MAPSET2[0x6B] = KEYCODE_KP_4;
    PS2_MAPSET2[0x73] = KEYCODE_KP_5;
    PS2_MAPSET2[0x74] = KEYCODE_KP_6;
    PS2_MAPSET2[0x69] = KEYCODE_KP_1;
    PS2_MAPSET2[0x72] = KEYCODE_KP_2;
    PS2_MAPSET2[0x7A] = KEYCODE_KP_3;
    PS2_MAPSET2[0x70] = KEYCODE_KP_0;
    PS2_MAPSET2[0x71] = KEYCODE_KP_DOT;

    PS2_MAPSET2_EXT[0x1F] = KEYCODE_LGUI;
    PS2_MAPSET2_EXT[0x11] = KEYCODE_LALT;
    PS2_MAPSET2_EXT[0x27] = KEYCODE_RGUI;
    PS2_MAPSET2_EXT[0x2F] = KEYCODE_MENU;
    PS2_MAPSET2_EXT[0x14] = KEYCODE_RCTRL;
    
    PS2_MAPSET2_EXT[0x70] = KEYCODE_INSERT;
    PS2_MAPSET2_EXT[0x6C] = KEYCODE_HOME;
    PS2_MAPSET2_EXT[0x7D] = KEYCODE_PAGEUP;
    PS2_MAPSET2_EXT[0x71] = KEYCODE_DELETE;
    PS2_MAPSET2_EXT[0x69] = KEYCODE_END;
    PS2_MAPSET2_EXT[0x7A] = KEYCODE_PAGEDOWN;

    PS2_MAPSET2_EXT[0x75] = KEYCODE_UP;
    PS2_MAPSET2_EXT[0x6B] = KEYCODE_LEFT;
    PS2_MAPSET2_EXT[0x72] = KEYCODE_DOWN;
    PS2_MAPSET2_EXT[0x74] = KEYCODE_RIGHT;

    PS2_MAPSET2_EXT[0x4A] = KEYCODE_KP_DIVIDE;
    PS2_MAPSET2_EXT[0x5A] = KEYCODE_KP_ENTER;

    println("done init ps2");
}


//finite state machine scancode parser
[__GLOBAL_FIRST__] u64 PS2_STATE_ENTRY      = 0x1;
[__GLOBAL_FIRST__] u64 PS2_STATE_F0         = 0x2;      // saw F0
[__GLOBAL_FIRST__] u64 PS2_STATE_E0         = 0x3;      // saw E0
[__GLOBAL_FIRST__] u64 PS2_STATE_E0_F0      = 0x4;      // saw E0 F0
[__GLOBAL_FIRST__] u64 PS2_STATE_PAUSE      = 0x5;      // saw E1, collecting bytes
[__GLOBAL_FIRST__] u64 PS2_STATE_PRTM       = 0x6;      // saw E0 12, collecting bytes
[__GLOBAL_FIRST__] u64 PS2_STATE_PRTB       = 0x7;      // saw E0 F0 7C, collecting bytes
[__GLOBAL_FIRST__] u64 PS2_SEQ_BYTES_LEFT;  //for long sequences (Pause, PrtScr)

[PS2] u64 PS2_PARSE_STATE = PS2_STATE_ENTRY;

[__GLOBAL_FIRST__] u32* PS2_MAPSET2;
[__GLOBAL_FIRST__] u32* PS2_MAPSET2_EXT;

//if extended is true, will translate all two-byte scancodes that are prefixed with 0xE0
//otherwise, only translates single byte scancodes
u32 ps2_map_set2(u8 code, i32 extended) {
    if(extended) return PS2_MAPSET2_EXT[code];
    else return PS2_MAPSET2[code];
}

//sends key events to kbinput controller
void ps2_accept_char(u8 c) {
    if(PS2_PARSE_STATE == PS2_STATE_ENTRY) {
        if(c == $u8 0xF0) {
            PS2_PARSE_STATE = PS2_STATE_F0;
        }
        else if(c == $u8 0xE0) {
            PS2_PARSE_STATE = PS2_STATE_E0;
        }
        else if(c == $u8 0xE1) {
            PS2_PARSE_STATE = PS2_STATE_PAUSE;
            PS2_SEQ_BYTES_LEFT = 0x7;
        }
        else {
            u32 keycode = ps2_map_set2(c, 0);
            kb_write_keyevent(keycode, KEYACTION_DOWN);
            PS2_PARSE_STATE = PS2_STATE_ENTRY;
        }
    }
    else if(PS2_PARSE_STATE == PS2_STATE_F0) {
        u32 keycode = ps2_map_set2(c, 0);
        kb_write_keyevent(keycode, KEYACTION_UP);
        PS2_PARSE_STATE = PS2_STATE_ENTRY;
    }
    else if(PS2_PARSE_STATE == PS2_STATE_E0) {
        if(c == $u8 0xF0) {
            PS2_PARSE_STATE = PS2_STATE_E0_F0;
        }
        else if(c == $u8 0x12) {
            PS2_PARSE_STATE = PS2_STATE_PRTM;
            PS2_SEQ_BYTES_LEFT = 0x2;
        }
        else {
            u32 keycode = ps2_map_set2(c, 1);
            kb_write_keyevent(keycode, KEYACTION_DOWN);
            PS2_PARSE_STATE = PS2_STATE_ENTRY;
        }
    }
    else if(PS2_PARSE_STATE == PS2_STATE_E0_F0) {
        if(c == $u8 0x7C) {
            PS2_PARSE_STATE = PS2_STATE_PRTB;
            PS2_SEQ_BYTES_LEFT = 0x3;
        }
        else {
            u32 keycode = ps2_map_set2(c, 1);
            kb_write_keyevent(keycode, KEYACTION_UP);
            PS2_PARSE_STATE = PS2_STATE_ENTRY;
        }
    }
    else if(PS2_PARSE_STATE == PS2_STATE_PAUSE) {
        if(PS2_SEQ_BYTES_LEFT == 0x7) {
            if(c == $u8 0x14) PS2_SEQ_BYTES_LEFT --;
            else PS2_PARSE_STATE = PS2_STATE_ENTRY;
        }
        else if(PS2_SEQ_BYTES_LEFT == 0x6) {
            if(c == $u8 0x77) PS2_SEQ_BYTES_LEFT --;
            else PS2_PARSE_STATE = PS2_STATE_ENTRY;
        }
        else if(PS2_SEQ_BYTES_LEFT == 0x5) {
            if(c == $u8 0xE1) PS2_SEQ_BYTES_LEFT --;
            else PS2_PARSE_STATE = PS2_STATE_ENTRY;
        }
        else if(PS2_SEQ_BYTES_LEFT == 0x4) {
            if(c == $u8 0xF0) PS2_SEQ_BYTES_LEFT --;
            else PS2_PARSE_STATE = PS2_STATE_ENTRY;
        }
        else if(PS2_SEQ_BYTES_LEFT == 0x3) {
            if(c == $u8 0x14) PS2_SEQ_BYTES_LEFT --;
            else PS2_PARSE_STATE = PS2_STATE_ENTRY;
        }
        else if(PS2_SEQ_BYTES_LEFT == 0x2) {
            if(c == $u8 0xE0) PS2_SEQ_BYTES_LEFT --;
            else PS2_PARSE_STATE = PS2_STATE_ENTRY;
        }
        else if(PS2_SEQ_BYTES_LEFT == 0x1) {
            if(c == $u8 0x77) PS2_SEQ_BYTES_LEFT --;
            else PS2_PARSE_STATE = PS2_STATE_ENTRY;
        }
        else panic("ps2_accept_char() : PS2_STATE_PAUSE invalid bytes left count");
        if(PS2_SEQ_BYTES_LEFT == 0x0) {
            kb_write_keyevent(KEYCODE_PAUSE, KEYACTION_DOWN);
            PS2_PARSE_STATE = PS2_STATE_ENTRY;
        }
    }
    else if(PS2_PARSE_STATE == PS2_STATE_PRTM) {
        if(PS2_SEQ_BYTES_LEFT == 0x2) {
            if(c == $u8 0xE0) PS2_SEQ_BYTES_LEFT --;
            else PS2_PARSE_STATE = PS2_STATE_ENTRY;
        }
        else if(PS2_SEQ_BYTES_LEFT == 0x1) {
            if(c == $u8 0x7C) PS2_SEQ_BYTES_LEFT --;
            else PS2_PARSE_STATE = PS2_STATE_ENTRY;
        }
        else panic("ps2_accept_char() : PS2_STATE_PRTM invalid bytes left count");
        if(PS2_SEQ_BYTES_LEFT == 0x0) {
            kb_write_keyevent(KEYCODE_PRINTSCREEN, KEYACTION_DOWN);
            PS2_PARSE_STATE = PS2_STATE_ENTRY;
        }
    }
    else if(PS2_PARSE_STATE == PS2_STATE_PRTB) {
        if(PS2_SEQ_BYTES_LEFT == 0x3) {
            if(c == $u8 0xE0) PS2_SEQ_BYTES_LEFT --;
            else PS2_PARSE_STATE = PS2_STATE_ENTRY;
        }
        else if(PS2_SEQ_BYTES_LEFT == 0x2) {
            if(c == $u8 0xF0) PS2_SEQ_BYTES_LEFT --;
            else PS2_PARSE_STATE = PS2_STATE_ENTRY;
        }
        else if(PS2_SEQ_BYTES_LEFT == 0x1) {
            if(c == $u8 0x12) PS2_SEQ_BYTES_LEFT --;
            else PS2_PARSE_STATE = PS2_STATE_ENTRY;
        }
        else panic("ps2_accept_char() : PS2_STATE_PRTB invalid bytes left count");
        if(PS2_SEQ_BYTES_LEFT == 0x0) {
            kb_write_keyevent(KEYCODE_PRINTSCREEN, KEYACTION_UP);
            PS2_PARSE_STATE = PS2_STATE_ENTRY;
        }
    }
    else panic("ps2_accept_char() : invalid parse state");
}



