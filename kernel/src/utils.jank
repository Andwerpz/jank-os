

[__GLOBAL_FIRST__] u32 EFER_MSR             = $u32 0xc0000080;
[__GLOBAL_FIRST__] u32 STAR_MSR             = $u32 0xc0000081;
[__GLOBAL_FIRST__] u32 LSTAR_MSR            = $u32 0xc0000082;
[__GLOBAL_FIRST__] u32 FMASK_MSR            = $u32 0xc0000084;  //auto clear RFLAGS bits on syscall
[__GLOBAL_FIRST__] u32 GS_BASE_MSR          = $u32 0xc0000101;  //swapgs swaps this and KERNEL_GS_BASE
[__GLOBAL_FIRST__] u32 KERNEL_GS_BASE_MSR   = $u32 0xc0000102;

void wrmsr(u32 reg, u64 val) {
    u32 low = $u32 val;
    u32 high = $u32 (val >> $u64 32);
    asm!("movl {reg}, %ecx");
    asm!("movl {low}, %eax");
    asm!("movl {high}, %edx");
    asm!("wrmsr");
}

u64 rdmsr(u32 reg) {
    u32 low;
    u32 high;
    asm!("movl {reg}, %ecx");   
    asm!("rdmsr");              
    asm!("movl %eax, {low}");
    asm!("movl %edx, {high}");
    return ($u64 high << $u64 32) | ($u64 low);
}

void outb(u16 port, u8 val) {
    asm!("movw {port}, %dx");
    asm!("movb {val}, %al");
    asm!("outb %al, %dx");
}

void outw(u16 port, u16 val) {
    asm!("movw {port}, %dx");
    asm!("movw {val}, %ax");
    asm!("outw %ax, %dx");
}

void outl(u16 port, u32 val) {
    asm!("movw {port}, %dx");
    asm!("movl {val}, %eax");
    asm!("outl %eax, %dx");
}

u8 inb(u16 port) {
    u8 ret;
    asm!("movw {port}, %dx");
    asm!("inb %dx, %al");
    asm!("movb %al, {ret}");
    return ret;
}

u32 inl(u16 port) {
    u32 ret;
    asm!("movw {port}, %dx");
    asm!("inl %dx, %eax");
    asm!("movl %eax, {ret}");
    return ret;
}

//prints 16 separated bytes on a line
template<T>
void hexdump(T* _buf, u64 amt_bytes) {
    u8* buf = $u8* _buf;
    for(u64 i = 0x1; i <= amt_bytes; i++){
        u64 low = ($u64 buf[i - 0x1]) & 0xf;
        u64 high = ($u64 buf[i - 0x1] >> $u64 4) & 0xf;
        if(high < $u64 10) cout << ('0' + $u8 high);
        else cout << ('a' + $u8 high - $u8 10);
        if(low < $u64 10) cout << ('0' + $u8 low);
        else cout << ('a' + $u8 low - $u8 10);
        cout << " ";
        if(i % 0x10 == 0x0) cout << "\n";
    }
    if(amt_bytes % 0x10) cout << "\n";
}

template<T>
void bitdump(T x) {
    print("0b");
    for(u64 i = sizeof(T) * 0x8 - 0x1; ; i--) {
        print($i32 (($u64 x >> i) & 0x1));
        if(i == 0x0) break;
    }
}

//assumes that the lowest significant bits in each byte come first
i32 bitmap_get_bit(void* bitmap, u64 index) {
    return $i32 ((($u8* bitmap)[index / $u64 8] >> $u8 (index % $u64 8)) & $u8 1);
}

void bitmap_set_bit(void* bitmap, u64 index) {
    ($u8* bitmap)[index / $u64 8] |= ($u8 1 << $u8 (index % $u64 8));
}

void bitmap_unset_bit(void* bitmap, u64 index) {
    bitmap_set_bit(bitmap, index);
    ($u8* bitmap)[index / $u64 8] ^= ($u8 1 << $u8 (index % $u64 8));
}


[__GLOBAL_FIRST__] u64 irq_disable_count = 0x0;
[__GLOBAL_FIRST__] u64 irq_saved_rflags;

void irq_disable() {
    if(irq_disable_count == 0x0) {  //this should be multiprocess safe?
        asm!("pushfq");     //need to push RFLAGS before cli to save actual RFLAGS
        asm!("cli");        //do cli before popq to make global variable safe
        asm!("popq irq_saved_rflags(%rip)");
    }
    irq_disable_count ++;
}

void irq_enable() {
    assert(irq_disable_count != 0x0, "irq_enable() : unmatched irq_enable");
    irq_disable_count --;
    if(irq_disable_count == 0x0) {
        asm!("pushq irq_saved_rflags(%rip)");
        asm!("popfq");
    }
}

//returns 0 on success, negative on failure
//expects kernel_pt to be active
i32 copy_to_user(pagetable_t user_pt, u8* kbuf, u8* ubuf, u64 amt) {
    u64 uptr = $u64 ubuf;
    uptr = (uptr / PAGE_SIZE) * PAGE_SIZE;  //round down to nearest page boundary
    u64 ubuf_end = $u64 ubuf + amt;
    u64 kptr = 0x0;

    while(uptr < ubuf_end) {
        //make sure page is mapped
        if(!pt_is_vaddr_mapped(user_pt, $void* uptr)) {
            return -ERR_FAULT;
        }

        //check flags
        u64 flags;
        void* paddr = pt_translate(user_pt, $void* uptr, flags);
        if(!(flags & PTE_WRITEABLE) || !(flags & PTE_USER)) {
            return -ERR_FAULT;
        }

        //copy data
        for(u64 i = 0x0; i < PAGE_SIZE; i++) {
            u64 cptr = uptr + i;
            if(cptr < $u64 ubuf || cptr >= ubuf_end) continue;
            ($u8* paddr)[i] = kbuf[kptr ++];
        }

        uptr += PAGE_SIZE;
    }

    return 0;
}

//returns 0 on success, negative on failure
//expects kernel_pt to be active
i32 copy_from_user(pagetable_t user_pt, u8* kbuf, u8* ubuf, u64 amt) {
    u64 uptr = $u64 ubuf;
    uptr = (uptr / PAGE_SIZE) * PAGE_SIZE;  //round down to nearest page boundary
    u64 ubuf_end = $u64 ubuf + amt;
    u64 kptr = 0x0;

    while(uptr < ubuf_end) {
        //make sure page is mapped
        if(!pt_is_vaddr_mapped(user_pt, $void* uptr)) {
            return -ERR_FAULT;
        }

        //check flags
        u64 flags;
        void* paddr = pt_translate(user_pt, $void* uptr, flags);
        if(!(flags & PTE_USER)) {
            return -ERR_FAULT;
        }

        //copy data
        for(u64 i = 0x0; i < PAGE_SIZE; i++) {
            u64 cptr = uptr + i;
            if(cptr < $u64 ubuf || cptr >= ubuf_end) continue;
            kbuf[kptr ++] = ($u8* paddr)[i];
        }

        uptr += PAGE_SIZE;
    }

    return 0;
}

u16 be_to_cpu(u16 x) {
    asm!("mov {x}, %rax");
    asm!("xchg %al, %ah");
    asm!("mov %rax, {x}");
    return x;
}

u32 be_to_cpu(u32 x) {
    asm!("mov {x}, %rax");
    asm!("bswap %eax");
    asm!("mov %rax, {x}");
    return x;
}

u64 be_to_cpu(u64 x) {
    asm!("mov {x}, %rax");
    asm!("bswap %rax");
    asm!("mov %rax, {x}");
    return x;
}

u16 cpu_to_be(u16 x) {
    asm!("mov {x}, %rax");
    asm!("xchg %al, %ah");
    asm!("mov %rax, {x}");
    return x;
}

u32 cpu_to_be(u32 x) {
    asm!("mov {x}, %rax");
    asm!("bswap %eax");
    asm!("mov %rax, {x}");
    return x;
}

u64 cpu_to_be(u64 x) {
    asm!("mov {x}, %rax");
    asm!("bswap %rax");
    asm!("mov %rax, {x}");
    return x;
}

void cpu_cache_flush(void* addr) {
    asm!("mov {addr}, %rax");
    asm!("clflush (%rax)");
}

//flushes size bytes of memory in virtual address space starting from addr from the CPU cache
void cpu_cache_flush(void* addr, u64 size) {
    // iterate through the range in 64-byte chunks (standard cache line size)
    // can use CPUID leaf 1 to get the exact line size
    for(u64 p = 0x0; p < size; p += $u64 64) {
        cpu_cache_flush($void* (p + $u64 addr));
    }
    
    // ensure flushes are finished before any store
    asm!("mfence");
}

[__GLOBAL_FIRST__] i32 DO_VGA_PRINT = 1;
void disable_vga_print() {
    DO_VGA_PRINT = 0;
    vga_clear_screen(COLOR_BLACK);
}

void enable_vga_print() {
    DO_VGA_PRINT = 1;
    VGA_DEBUG_CURSOR_ROW = 0x0;
    VGA_DEBUG_CURSOR_COL = 0x0;
    vga_clear_screen(COLOR_BLACK);
}

void print(u8 c) {
    write_serial(c);
    if(DO_VGA_PRINT) vga_debug_draw_char(c);
} 

void print(u8* str) {
    while(*str != $u8 0) {
        print(*str);
        str = $u8* ($u64 str + $u64 1);
    }
}

void print(string s) {
    for(u64 i = 0x0; i < s.size(); i++){
        print(s[i]);
    }
}

void print(u64 x) {
    print(to_string(x));
}

void print(u32 x){
    print(to_string(x));
}

void print(u16 x) {
    print(to_string(x));
}

void print(i64 x) {
    print(to_string(x));
}

void print(i32 x) {
    print(to_string(x));
}

template<T>
void print(T* ptr) {
    print("0x");
    u64 val = $u64 ptr;
    u64 mask = 0b1111;
    for(i32 i = 15; i >= 0; i--){
        u64 dig = (val & (mask << ($u64 i * $u64 4))) >> ($u64 i * $u64 4);
        u8 c;
        if(dig < $u64 10) {
            c = '0' + $u8 dig;
        }
        else {
            c = 'a' + $u8 dig - $u8 10;
        }
        print(c);
    }
}

void println() {
    print("\n");
}

template<T>
void println(T x) {
    print(x);
    print("\n");
}

template<T, U>
void print(T a, U b) {
    print(a);
    print(b);
}

template<T, U>
void println(T a, U b) {
    print(a, b);
    print("\n");
}

template<T, U, V>
void print(T a, U b, V c) {
    print(a);
    print(b);
    print(c);
}

template<T, U, V>
void println(T a, U b, V c) {
    print(a, b, c);
    print("\n");
}

template<T, U, V, W>
void print(T a, U b, V c, W d) {
    print(a);
    print(b);
    print(c);
    print(d);
}

template<T, U, V, W>
void println(T a, U b, V c, W d) {
    print(a, b, c, d);
    print("\n");
}


