#include <pair>;

// Virtual File System
//in-memory filesystem that mounts other filesystems onto itself. 

//assumptions about mounted filesystems:
// - must be able to answer the question "given this node, find this child"
// - directories are mappings from string -> inode number
// - should be able to implement all other utility functions in vfs_ops

//vfs_inode acts as an interface for filesystem ops
//vfs_dentry is persistent and forms the in-memory filesystem

//mounts should be handled by the VFS
//if we mount a filesystem, a vfs_inode is allocated for the mountpoint and persists until it's unmounted.

//I treat chains of mounts as 'one node'
//if a node is a mountpoint, then its mount_root should have the same name as it. 

//inode operation interface
struct vfs_ops {
    //mount ops
    fn<i32(vfs_inode*, void*, vfs_inode*&)> get_mount_root;     //find root of filesystem given mountpoint

    //directory ops
    fn<i32(vfs_inode*, string, vfs_inode*&)> lookup;    //given inode and child name, find child. Should pass in malloc'd buffer
    fn<i32(vfs_inode*, vector<string>&)> get_children;  //find names of all children

    //file ops
    fn<i32(vfs_inode*, u8*, u64, u64, u64&)> read_file; //read some amount of bytes from a file with offset
    fn<i32(vfs_inode*, u64&)> get_size;                 //get the size of the file in bytes
}

// -- VFS INODE --
//wrapper class for all nodes
//these get alloc'd when doing vfs_walk, and only dealloc'd when their subt_refcnt hits 0
struct vfs_inode {
    vfs_inode* parent;                                  //should always not be nullptr if not root
    vector<pair<string, vfs_inode*>> children;          //only stores children currently in memory
    string name;
    u64 type;       // a type defined in defs.jank
    u64 refcnt;
    u64 subt_refcnt;

    //when mounting, refcount of mount_root will be incremented. 
    //getting rid of mountpoints should be handled specially, so don't have to worry about storing 
    // mount_root in children. 
    i32 is_mountpoint;     //if this is true, this node is in 'hosting' fs
    void* mount_super;      //global context
    vfs_inode* mount_root;  //root of mounted fs

    //fs specific
    i32 is_virtual;
    u64 node_sz;
    void* node;     //if is not virtual, needs to be dealloced
    void* super;    //global context
    vfs_ops* ops;

    vfs_inode(string _name, u64 _type, void* _node, vfs_ops* _ops) {
        this.parent = $vfs_inode* nullptr;
        this.name = _name;
        this.type = _type;
        this.refcnt = 0x0;
        this.subt_refcnt = 0x0;

        this.is_mountpoint = 0;
        this.mount_super = nullptr;
        this.mount_root = $vfs_inode* nullptr;

        this.is_virtual = 1;
        this.node_sz = 0x0;
        this.node = _node;
        this.super = nullptr;
        this.ops = _ops;
    }

    vfs_inode(string _name, u64 _type, u64 _node_sz, void* _node, void* _super, vfs_ops* _ops) {
        this.parent = $vfs_inode* nullptr;
        this.name = _name;
        this.type = _type;
        this.refcnt = 0x0;
        this.subt_refcnt = 0x0;

        this.is_mountpoint = 0;
        this.mount_super = nullptr;
        this.mount_root = $vfs_inode* nullptr;

        this.is_virtual = 0;
        this.node_sz = _node_sz;
        this.node = _node;
        this.super = _super;
        this.ops = _ops;        
    }

    vfs_inode* get_child(string name) {
        for(u64 i = 0x0; i < this.children.size(); i++) {
            if(this.children[i].first == name) return this.children[i].second;
        }
        return $vfs_inode* nullptr;
    }

    void add_child(string name, vfs_inode* child) {
        passert($void* this.get_child(name) == nullptr, "vfs_inode::add_child() : child already exists");
        passert($void* child->parent == nullptr, "vfs_inode::add_child() : child already has parent");
        this.children.push_back(new pair<string, vfs_inode*>(name, child));
        child->parent = @this;
    }

    ~vfs_inode() {
        passert(@this != VFS_ROOT, "vfs_inode::~() : should never dealloc root");
        passert(this.subt_refcnt == 0x0, "vfs_inode::~() : should only dealloc non-referenced inodes");
        passert($void* this.parent != nullptr, "vfs_inode::~() : should always have parent");
        passert(this.children.size() == 0x0, "vfs_inode::~() : should not dealloc nodes with children");

        //if this is not virtual, need to dealloc underlying fs node
        if(!this.is_virtual) {
            passert(this.node != nullptr, "vfs_inode::~() : non-virtual nodes should have valid node pointer");
            passert(this.node_sz != 0x0, "vfs_inode::~() : node_sz should be non-zero on non-virtual nodes");
            free(this.node, this.node_sz);
            this.node = nullptr;
        }

        //remove reference of this node from parent
        {
            u64 ind = this.parent->children.size();
            for(u64 i = 0x0; i < this.parent->children.size(); i++) {
                if(this.parent->children[i].second == @this) {
                    passert(ind == this.parent->children.size(), "vfs_inode::~() : should only contain child once");
                    ind = i;
                }
            }
            passert(ind != this.parent->children.size(), "vfs_inode::~() : should find child");
            this.parent->children.erase(ind);
        }
    }

    i32 is_directory() {
        return this.type == DT_DIR;
    }

    i32 is_file() {
        return this.type == DT_REG;
    }
}

vfs_inode* VFS_ROOT;
void init_vfs() {
    sout << "start init vfs\n";

    init_vfs_dentry();
    init_ext2();

    //create vfs root node
    {
        vfs_dentry* root_dentry = $vfs_dentry* malloc(sizeof(vfs_dentry));
        new (root_dentry) vfs_dentry();

        VFS_ROOT = $vfs_inode* malloc(sizeof(vfs_inode));
        new (VFS_ROOT) vfs_inode(new string(""), DT_DIR, $void* root_dentry, VFS_DENTRY_OPS);
        vfs_inc_refcnt(VFS_ROOT);
    }

    init_vfs_fd_ops();

    sout << "done init vfs\n";
}

void vfs_inc_refcnt(vfs_inode* node) {
    node->refcnt ++;
    node->subt_refcnt ++;
    while($void* node->parent != nullptr) {
        node = node->parent;
        node->subt_refcnt ++;
    }
}

//if the subt_refcnt goes to 0, the nodes get dealloced. 
void vfs_dec_refcnt(vfs_inode* node) {
    passert(node->refcnt > 0x0, "vfs_dec_refcnt() : double ref decrement");

    //dec refcnt
    node->refcnt --;
    node->subt_refcnt --;
    vfs_inode* ptr = node;
    while($void* ptr->parent != nullptr) {
        ptr = ptr->parent;
        ptr->subt_refcnt --;
    }

    //dealloc nodes with 0 subt references 
    ptr = node;
    while(ptr->subt_refcnt == 0x0) {
        vfs_inode* par = ptr->parent;
        ptr->~();
        free($void* ptr, sizeof(vfs_inode));
        ptr = par;
    }
}

//given an inode, finds a child
//if create flag is set, will create virtual directory nodes if they do not exist
//currently, virtual nodes can only be created as children of other virtual nodes
//this should only be used within vfs_walk, use vfs_walk if you want to do lookups. 
i32 vfs_lookup(vfs_inode* node, string child, i32 create, vfs_inode*& res) {
    //special cases
    if(child == "..") {
        //walk up until we hit a non-mountpoint, or we can't anymore. 
        //if we are currently at the root, this should just return the input node
        vfs_inode* ptr = node;
        if($void* ptr->parent != nullptr) ptr = ptr->parent;
        while(ptr->is_mountpoint) {
            if($void* ptr->parent == nullptr) {
                free($void* res, sizeof(vfs_inode));
                res = node;
                return 0;
            }
            ptr = ptr->parent;
        }
        res = ptr;
        return 0;
    }
    else if(child == ".") {
        //do nothing
        res = node;
        return 0;
    }

    //after this point, must ensure that the current node is a directory
    if(!node->is_directory()) {
        return 1;
    }

    //see if child already exists
    while(1) {
        vfs_inode* child_node = node->get_child(child);
        if($void* child_node == nullptr) {
            break;
        }

        //walk child until it's not mountpoint
        while(child_node->is_mountpoint) {
            passert($void* child_node->mount_root != nullptr, "vfs_lookup() : mountpoint should always have valid mount_root");
            child_node = child_node->mount_root;
        }

        //free caller associated buffer
        free($void* res, sizeof(vfs_inode));
        res = child_node;
        return 0;
    }

    //use fs lookup op to create new instance of child
    if(node->ops->lookup#(node, child, res)) {
        if(create && node->is_virtual) {
            //create new child here
            vfs_dentry* dentry = $vfs_dentry* node->node;
            passert(!dentry->check_magic(), "vfs_lookup() : vfs_dentry magic mismatch");

            vfs_dentry* dentry_child = $vfs_dentry* malloc(sizeof(vfs_dentry));
            new (dentry_child) vfs_dentry();
            dentry->add_child(child, dentry_child);

            new (res) vfs_inode(child, DT_DIR, $void* dentry_child, VFS_DENTRY_OPS);
            res->is_virtual = 1;
        }
        else {
            //lookup failed
            return 1;
        }
    }

    //register as child 
    node->add_child(child, res);

    return 0;
}

i32 vfs_lookup(vfs_inode* node, string child, vfs_inode*& res) {
    return vfs_lookup(node, child, 0, res);
}

//should walk the filesystem using the relative path starting from 'root' 
//if create flag is set, will create virtual nodes if nodes do not exist via vfs_lookup
//at the end, increments refcount of resulting inode. 
//res should not be preallocated by caller. 
//returns 0 on success, 1 on failure
i32 vfs_walk(vfs_inode* root, string path, i32 create, vfs_inode*& res) {
    passert(root->subt_refcnt != 0x0, "vfs_walk() : root should be referenced");
    vector<string> parts = path.split('/');

    //walk root until it's not a mountpoint
    while(root->is_mountpoint) {
        passert($void* root->mount_root != nullptr, "vfs_walk() : mountpoint should always have valid mount_root");
        root = root->mount_root;
    }

    //do walk
    vfs_inode* cur = root;
    for(u64 i = 0x0; i < parts.size(); i++) {
        vfs_inode* next = $vfs_inode* malloc(sizeof(vfs_inode));
        if(vfs_lookup(cur, parts[i], create, next)) {
            //lookup failed, dealloc any temp nodes
            while(cur->subt_refcnt == 0x0) {
                passert($void* cur->parent != nullptr, "vfs_walk() : temp node should always have parent");
                vfs_inode* par = cur->parent;
                cur->~();
                free($void* cur, sizeof(vfs_inode));
                cur = par;
            }
            return 1;
        }

        //if cur has no references and our move was '..', dealloc cur
        if(parts[i] == ".." && cur->subt_refcnt == 0x0) {
            cur->~();
            free($void* cur, sizeof(vfs_inode));
        }

        cur = next;
    }

    //set res
    res = cur;
    passert(!res->is_mountpoint, "vfs_walk() : res should never be mountpoint");

    //increment res refcnt
    vfs_inc_refcnt(res);

    return 0;
}

i32 vfs_walk(vfs_inode* root, string path, vfs_inode*& res) {
    return vfs_walk(root, path, 0, res);
}

i32 vfs_walk(string path, i32 create, vfs_inode*& res) {
    return vfs_walk(VFS_ROOT, path, create, res);
}

i32 vfs_walk(string path, vfs_inode*& res) {
    return vfs_walk(VFS_ROOT, path, 0, res);
}

//can only mount on directories
//0 on success, 1 on failure
i32 vfs_mount(string path, void* super, vfs_ops* ops) {
    vfs_inode* walk_res;
    if(vfs_walk(path, 1, walk_res)) {
        //failed to walk path
        sout << "Mount failed to walk path\n";
        return 1;
    }
    passert(!walk_res->is_mountpoint, "vfs_mount() : result from walk should never be mountpoint");

    //check if underlying fs node is a directory
    if(!walk_res->is_directory()) {
        vfs_dec_refcnt(walk_res);
        sout << "Can only mount to directories\n";
        return 1;
    }

    //try to create root of mounted filesystem
    vfs_inode* mount_root = $vfs_inode* malloc(sizeof(vfs_inode));
    if(ops->get_mount_root#(walk_res, super, mount_root)) {
        //failed to create mount root
        vfs_dec_refcnt(walk_res);
        free($void* mount_root, sizeof(vfs_inode));
        sout << "Failed to create mount root\n";
        return 1;
    }

    //ok, go ahead and mount
    walk_res->is_mountpoint = 1;
    walk_res->mount_super = super;
    walk_res->mount_root = mount_root;

    vfs_inc_refcnt(mount_root);
    vfs_dec_refcnt(walk_res);

    return 0;
}
//TODO vfs_unmount()

i32 vfs_get_children(vfs_inode* node, vector<string>& res) {
    if(!node->is_directory()) return 1;
    return node->ops->get_children#(node, res);
}

i32 vfs_get_children(string path, vector<string>& res) {
    vfs_inode* root;
    if(vfs_walk(path, 0, root)) return 1;
    vfs_get_children(root, res);
    vfs_dec_refcnt(root);
    return 0;
}

i32 vfs_read_file(vfs_inode* node, u8* buf, u64 amt, u64 off, u64& res) {
    if(!node->is_file()) return 1;
    return node->ops->read_file#(node, buf, amt, off, res);
}

i32 vfs_read_file(string path, u8* buf, u64 amt, u64 off, u64& res) {
    vfs_inode* root;
    if(vfs_walk(path, 0, root)) return 1;
    vfs_read_file(root, buf, amt, off, res);
    vfs_dec_refcnt(root);
    return 0;
}

i32 vfs_get_size(vfs_inode* node, u64& res) {
    if(!node->is_file()) return 1;
    return node->ops->get_size#(node, res);
}

i32 vfs_get_size(string path, u64& res) {
    vfs_inode* root;
    if(vfs_walk(path, 0, root)) return 1;
    vfs_get_size(root, res);
    vfs_dec_refcnt(root);
    return 0;
}

i32 vfs_is_file(vfs_inode* node, i32& res) {
    res = node->is_file();
    return 0;
}

i32 vfs_is_file(string path, i32& res) {
    vfs_inode* node;
    if(vfs_walk(path, 0, node)) return 1;
    res = node->is_file();
    vfs_dec_refcnt(node);
    return 0;
}

i32 vfs_is_directory(vfs_inode* node, i32& res) {
    res = node->is_directory();
    return 0;
}

i32 vfs_is_directory(string path, i32& res) {
    vfs_inode* node;
    if(vfs_walk(path, 0, node)) return 1;
    res = node->is_directory();
    vfs_dec_refcnt(node);
    return 0;
}

i32 _vfs_print_tree(vfs_inode* root, u64 depth) {
    //gather all children of root
    vector<string> children;
    if(vfs_get_children(root, children)) {
        return 1;
    }

    for(u64 i = 0x0; i < children.size(); i++) {
        if(children[i] == "." || children[i] == "..") continue;

        //get child
        vfs_inode* child;
        if(vfs_walk(root, children[i], child)) {
            return 1;
        }
        for(u64 j = 0x0; j < depth; j++) sout << "    ";
        sout << children[i] << "\n";

        //if child is not directory, skip 
        if(!child->is_directory()) {
            vfs_dec_refcnt(child);
            continue;
        }

        //print child
        if(_vfs_print_tree(child, depth + 0x1)) {
            vfs_dec_refcnt(child);
            return 1;
        }

        vfs_dec_refcnt(child);
    }
    return 0;
}

i32 vfs_print_tree(string path) {
    vfs_inode* root;
    if(vfs_walk(path, 0, root)) return 1;
    i32 retval = _vfs_print_tree(root, 0x0);
    vfs_dec_refcnt(root);
    return retval;
}

//returns the absolute pathname of node in res
i32 vfs_get_pathname(vfs_inode* node, string& res) {
    vector<string> parts;
    parts.push_back(node->name);
    while(1) {
        vfs_inode* par;
        if(vfs_walk(node, new string(".."), par)) {
            //somehow walk failed
            return 1;
        }
        
        //if we're at the root, walk should return the same node
        if(par == node) {
            break;
        }

        parts.push_back(par->name);
        vfs_dec_refcnt(par);
        node = par;
    }
    passert(parts.size() >= 0x1, "vfs_get_pathname() : should have at least one part");
    passert(parts[parts.size() - 0x1] == "", "vfs_get_pathname() : root part should be empty string");
    
    if(parts.size() == 0x1) {
        //special case for root
        res = new string("/");
    }
    else {
        res = new string("");
        for(i32 i = $i32 parts.size() - 2; i >= 0; i--) {
            res = res + "/" + parts[i];
        }
    }
    return 0;
}

//returns parent and bumps its refcnt
i32 vfs_get_parent(vfs_inode* node, vfs_inode*& res) {
    if(vfs_walk(node, new string(".."), res)) return 1;
    return 0;
}

// -- VFS DENTRY --
//virtual directory node
struct vfs_dentry {
    u8[4] magic;  // "DENT"
    vfs_dentry* parent;
    vector<pair<string, vfs_dentry*>> children;

    vfs_dentry() {
        this.init_magic();
        this.children.push_back(new pair<string, vfs_dentry*>(new string("."), @this));
    }

    vfs_dentry(vfs_dentry* parent) {
        this.init_magic();
        this.children.push_back(new pair<string, vfs_dentry*>(new string("."), @this));
        this.children.push_back(new pair<string, vfs_dentry*>(new string(".."), this.parent));
        this.parent = parent;
    }

    void init_magic() {
        this.magic[0] = 'D';
        this.magic[1] = 'E';
        this.magic[2] = 'N';
        this.magic[3] = 'T';
    }

    i32 check_magic() {
        return this.magic[0] != 'D' || this.magic[1] != 'E' || this.magic[2] != 'N' || this.magic[3] != 'T';
    }

    void add_child(string name, vfs_dentry* child) {
        passert($void* child->parent == nullptr, "vfs_dentry::add_child() : child must have no parent");
        this.children.push_back(new pair<string, vfs_dentry*>(name, child));
        child->parent = @this;
        child->children.push_back(new pair<string, vfs_dentry*>(new string(".."), @this));
    }
}

vfs_ops* VFS_DENTRY_OPS;
void init_vfs_dentry() {
    VFS_DENTRY_OPS = $vfs_ops* malloc(sizeof(vfs_ops));

    VFS_DENTRY_OPS->get_mount_root = #<vfs_dentry_get_mount_root(vfs_inode*, void*, vfs_inode*&)>;

    VFS_DENTRY_OPS->lookup = #<vfs_dentry_lookup(vfs_inode*, string, vfs_inode*&)>;
    VFS_DENTRY_OPS->get_children = #<vfs_dentry_get_children(vfs_inode*, vector<string>&)>;

    VFS_DENTRY_OPS->read_file = #<vfs_dentry_read_file(vfs_inode*, u8*, u64, u64, u64&)>;
    VFS_DENTRY_OPS->get_size = #<vfs_dentry_get_size(vfs_inode*, u64&)>;
}

i32 vfs_dentry_get_mount_root(vfs_inode* _node, void* super, vfs_inode*& res) {
    vfs_dentry* node = $vfs_dentry* _node->node;
    passert(!node->check_magic(), "vfs_dentry_get_mount_root() : node magic not good");
    return 1;   //should never be mounting vfs onto something else
}

i32 vfs_dentry_is_directory(vfs_inode* _node, i32& ret) {
    vfs_dentry* node = $vfs_dentry* _node->node;
    passert(!node->check_magic(), "vfs_dentry_is_directory() : node magic not good");
    ret = 1;    //dentries are always directories
    return 0;
}

i32 vfs_dentry_lookup(vfs_inode* _node, string child, vfs_inode*& res) {
    vfs_dentry* node = $vfs_dentry* _node->node;
    passert(!node->check_magic(), "vfs_dentry_lookup() : node magic not good");

    for(u64 i = 0x0; i < node->children.size(); i++) { 
        if(node->children[i].first == child) {
            new (res) vfs_inode(child, DT_DIR, $void* node->children[i].second, VFS_DENTRY_OPS);
            res->is_virtual = 1;
            res->node_sz = sizeof(vfs_dentry);
            return 0;
        }
    }

    //failed to find child
    return 1;
}

i32 vfs_dentry_get_children(vfs_inode* _node, vector<string>& ret) {
    vfs_dentry* node = $vfs_dentry* _node->node;
    passert(!node->check_magic(), "vfs_dentry_get_children() : node magic not good");

    for(u64 i = 0x0; i < node->children.size(); i++) {
        ret.push_back(node->children[i].first);
    }
    return 0;
}

i32 vfs_dentry_is_file(vfs_inode* _node, i32& ret) {
    vfs_dentry* node = $vfs_dentry* _node->node;
    passert(!node->check_magic(), "vfs_dentry_is_file() : node magic not good");
    ret = 0;    //dentries are not files
    return 0;
}

i32 vfs_dentry_read_file(vfs_inode* _node, u8* buf, u64 amt, u64 off, u64& res) {
    vfs_dentry* node = $vfs_dentry* _node->node;
    passert(!node->check_magic(), "vfs_dentry_read_file() : node magic not good");
    return 1;   //can't read dentries 
}

i32 vfs_dentry_get_size(vfs_inode* _node, u64& res) {
    vfs_dentry* node = $vfs_dentry* _node->node;
    passert(!node->check_magic(), "vfs_dentry_get_size() : node magic not good");
    return 1;   //dentries aren't files
}


// -- FD OPS --
[__GLOBAL_FIRST__] fd_ops* FD_OPS_VFS;
void init_vfs_fd_ops() {
    FD_OPS_VFS = $fd_ops* malloc(sizeof(fd_ops));
    new (FD_OPS_VFS) fd_ops();
    FD_OPS_VFS->op_read = #<vfs_read(file_descriptor*, u8*, u64)>;
    FD_OPS_VFS->op_write = #<vfs_write(file_descriptor*, u8*, u64)>;
    FD_OPS_VFS->op_lseek = #<vfs_lseek(file_descriptor*, u64, i32)>;
    FD_OPS_VFS->op_getdents = #<vfs_getdents(file_descriptor*, u8*, u64)>;
    FD_OPS_VFS->op_close = #<vfs_close(file_descriptor*)>;
}

i64 vfs_read(file_descriptor* fd, u8* buf, u64 amt) {
    vfs_inode* node = $vfs_inode* fd->resource_ptr;

    if(!node->is_file()) {
        //can only read from file
        return $i64 -1;
    }

    u64 read_amt;
    i32 read_status = vfs_read_file(node, buf, amt, fd->position, read_amt);
    if(read_status) {
        //read failed
        return $i64 -1;
    }
    
    //read success
    fd->position += read_amt;

    return $i64 read_amt;
}

i64 vfs_write(file_descriptor* fd, u8* buf, u64 amt) {
    panic("vfs_write() : not implemented");
    return $i64 -1;
}

i64 vfs_lseek(file_descriptor* fd, u64 off, i32 whence) {
    vfs_inode* node = $vfs_inode* fd->resource_ptr;

    //just set position
    fd->position = off;

    return $i64 fd->position;
}

i64 vfs_getdents(file_descriptor* fd, u8* buf, u64 amt) {
    vfs_inode* node = $vfs_inode* fd->resource_ptr;
    u64 buf_ptr = 0x0;
    u64 pos = fd->position;

    //get children
    vector<string> children;
    if(vfs_get_children(node, children)) {
        return $i64 -1;
    }
    
    //write dirents to buffer
    while(pos < children.size()) {
        //compute size of next dirent
        u64 nsz = sizeof(dirent) + children[pos].size();

        //if next dirent can't fit, stop writing
        if(buf_ptr + nsz > amt) break;

        //get child node
        vfs_inode* child_node;
        if(vfs_walk(node, children[pos], child_node)) {
            passert(0, "vfs_getdents() : this lookup should not fail");
        }

        //write next dirent to buffer
        dirent* ndirent = $dirent* @(buf[buf_ptr]);
        ndirent->d_ino = $u64 0;
        ndirent->d_off = $i64 (pos + 0x1);
        ndirent->d_reclen = $u16 nsz;
        ndirent->d_type = $u8 child_node->type;
        memcpy($void* @(ndirent->d_name), $void* children[pos].jstr(), children[pos].size() + 0x1);

        //increment pointers, cleanup mem
        vfs_dec_refcnt(child_node);
        buf_ptr += nsz;
        pos ++;
    }

    //check if buffer is too small to fit next dirent
    if(buf_ptr == 0x0 && pos != children.size()) {
        return $i64 -ERR_INVAL;
    }

    fd->position = pos;
    return $i64 buf_ptr;
}

i32 vfs_close(file_descriptor* fd) {
    vfs_inode* node = $vfs_inode* fd->resource_ptr;

    //dec node refcount
    vfs_dec_refcnt(node);

    return 0;
}
