#include <pair>;

// Virtual File System
//in-memory filesystem that mounts other filesystems onto itself. 

//assumptions about mounted filesystems:
// - must be able to answer the question "given this node, find this child"
// - directories are mappings from string -> inode number

//wrapper class for all nodes
struct inode {
    //fs specific
    i32 is_virtual;
    u64 node_sz;
    void* node;     //if is not virtual, needs to be dealloced
    void* super;    //global context
    fn<i32(inode&, string, inode&)> lookup;

    inode(void* _node, fn<i32(inode&, string, inode&)> _lookup) {
        this.is_virtual = 0;
        this.node = _node;
        this.super = nullptr;
        this.lookup = _lookup;
    }

    inode(void* _node, void* _super, fn<i32(inode&, string, inode&)> _lookup) {
        this.is_virtual = 0;
        this.node = _node;
        this.super = _super;
        this.lookup = _lookup;
    }

    void dealloc_nonvirtual() {
        if(!this.is_virtual && this.node != nullptr) {
            passert(this.node_sz != 0x0, "inode::dealloc_nonvirtual() : node_sz should be non-zero");
            free(this.node, this.node_sz);
        }
    }
}

//virtual nodes
struct vfs_inode {
    u8[4] magic;  // "JVFS" : jank vfs
    vfs_inode* parent;
    vector<pair<string, vfs_inode*>> children;

    i32 is_mount_root;
    void* mount_node;
    void* mount_super;
    fn<i32(vfs_inode*, inode&)> mount_get_root; 

    vfs_inode() {
        this.init_magic();
        this.children.push_back(new pair<string, vfs_inode*>(new string("."), @this));
    }

    vfs_inode(vfs_inode* parent) {
        this.init_magic();
        this.children.push_back(new pair<string, vfs_inode*>(new string("."), @this));
        this.children.push_back(new pair<string, vfs_inode*>(new string(".."), this.parent));
        this.parent = parent;
    }

    void init_magic() {
        this.magic[0] = 'J';
        this.magic[1] = 'V';
        this.magic[2] = 'F';
        this.magic[3] = 'S';
    }

    i32 check_magic() {
        return this.magic[0] != 'J' || this.magic[1] != 'V' || this.magic[2] != 'F' || this.magic[3] != 'S';
    }

    void add_child(string name, vfs_inode* child) {
        passert(!this.is_mount_root, "vfs_inode::add_child() : cannot add children to mount directories");
        passert($void* child->parent == nullptr, "vfs_inode::add_child() : child must have no parent");
        this.children.push_back(new pair<string, vfs_inode*>(name, child));
        child->parent = @this;
        child->children.push_back(new pair<string, vfs_inode*>(new string(".."), @this));
    }

    void mount(void* _mount_super, fn<i32(vfs_inode*, inode&)> _mount_get_root) {
        passert(this.children.size() == 0x0, "vfs_inode::mount() : should only mount to empty directories");
        this.is_mount_root = 1;
        this.mount_super = _mount_super;
        this.mount_get_root = _mount_get_root;
    }
}

vfs_inode* VFS_ROOT;

void init_vfs() {
    VFS_ROOT = $vfs_inode* malloc(sizeof(vfs_inode));
    *VFS_ROOT := new vfs_inode();
}

i32 vfs_lookup(inode& _node, string child, inode& res) {
    vfs_inode* node = $vfs_inode* _node.node;
    if(node->magic[0] != 'J' || node->magic[1] != 'V' || node->magic[2] != 'F' || node->magic[3] != 'S') {
        panic("vfs_lookup() : node magic not good");
    }

    for(u64 i = 0x0; i < node->children.size(); i++) { 
        if(node->children[i].first == child) {
            res.is_virtual = 1;
            res.node_sz = sizeof(vfs_inode);
            res.node = $void* node->children[i].second;
            res.lookup = #<vfs_lookup(inode&, string, inode&)>;
            return 0;
        }
    }

    //failed to find child
    return 1;
}

//should walk the filesystem to the inode specified by path
//if create flag is set, will create virtual nodes if nodes do not exist
//returns 0 on success, 1 on failure
i32 vfs_walk(string path, i32 create, inode& res) {
    vector<string> parts = path.split('/');
    vector<inode> dir_stack;

    if(VFS_ROOT->is_mount_root) {
        inode root_node = new inode();
        VFS_ROOT->mount_get_root#(VFS_ROOT, root_node);
        dir_stack.push_back(root_node);
    }
    else {
        dir_stack.push_back(new inode($void* VFS_ROOT, #<vfs_lookup(inode&, string, inode&)>));
    }
    
    for(u64 i = 0x0; i < parts.size(); i++) {
        //look for next inode
        if(parts[i] == "..") {
            //check if we're trying to ascend past the root
            if(dir_stack.size() == 0x1) { 
                return 1;
            }

            //ascend
            dir_stack[dir_stack.size() - 0x1].dealloc_nonvirtual();
            dir_stack.pop_back();
        }
        else if(parts[i] == ".") {/* do nothing */}
        else {
            inode next = new inode();
            inode& prev = dir_stack[dir_stack.size() - 0x1];
            if(prev.lookup#(prev, parts[i], next)) {
                if(create && prev.is_virtual) {
                    //create new child here
                    vfs_inode* node = $vfs_inode* prev.node;
                    passert(!node->check_magic(), "vfs_walk() : vfs_node magic mismatch");
                    passert(!node->is_mount_root, "vfs_walk() : should not create new virtual node on mount root");

                    vfs_inode* child = $vfs_inode* malloc(sizeof(vfs_inode));
                    *child := new vfs_inode();
                    node->add_child(parts[i], child);

                    next = new inode($void* child, #<vfs_lookup(inode&, string, inode&)>);
                }
                else {
                    //walk failed
                    for(u64 j = 0x0; j < dir_stack.size(); j++) {
                        dir_stack[j].dealloc_nonvirtual();
                    }
                    return 1;
                }
            }

            //if this is mount point, replace this node with root node of mounted fs
            if(next.is_virtual) {
                vfs_inode* node = $vfs_inode* next.node;
                passert(!node->check_magic(), "vfs_walk() : vfs_node magic mismatch");
                if(node->is_mount_root) {
                    inode root_node = new inode();
                    node->mount_get_root#(node, root_node);
                    next = root_node;
                }
            }

            //add to dir stack
            dir_stack.push_back(next);
        }
    }

    //dealloc all non-virtual except for res
    for(u64 i = 0x0; i < dir_stack.size() - 0x1; i++) {
        dir_stack[i].dealloc_nonvirtual();
    }
    res = dir_stack[dir_stack.size() - 0x1];
    
    return 0;
}

//0 on success, 1 on failure
i32 vfs_mount(string path, void* root_node, fn<inode*(inode*, string, inode*)> lookup) {
    //TODO

    return 0;
}




