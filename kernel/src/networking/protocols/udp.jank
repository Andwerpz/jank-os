// https://en.wikipedia.org/wiki/User_Datagram_Protocol#UDP_datagram_structure

struct UDPHeader {
    u16 src_port;
    u16 dst_port;
    u16 length;
    u16 checksum;
}

void udp_handle(UDPHeader* udp, u16 len, u32 src_ip) {
    u16 src_port = be_to_cpu(udp->src_port);
    u16 dst_port = be_to_cpu(udp->dst_port);
    u16 length   = be_to_cpu(udp->length);

    if(length < $u16 sizeof(UDPHeader)) {
        println("udp_handle() : udp length shorter than header");
        return;
    }

    if($u32 dst_port >= MAX_PORTS || dst_port == $u16 0) {
        println("udp_handle() : invalid dst port, outside allowed range");
        return;
    }
    if(UDP_PORT_TABLE[dst_port] == nullptr) {
        println("udp_handle() : nothing listening on port, dropping");
        return;
    }

    void* payload = $void* ($u64 udp + sizeof(UDPHeader));
    u16 payload_len = length - $u16 sizeof(UDPHeader);

    // probably things that the OS needs here, rn just dhcp hijacks
    if(dst_port == DHCP_CLIENT_LISTEN_PORT) {
        DHCPHeader* dhcp = $DHCPHeader* payload; 
        dhcp_handle(dhcp, payload_len);
        return;
    }

    // place packet into socket queue
    println("udp_handle() : placing packet in socket rx queue");
    socket* sock = UDP_PORT_TABLE[dst_port];

    packet* pkt = $packet* malloc(sizeof(packet));
    pkt->src_ip = src_ip;
    pkt->src_port = src_port;
    pkt->dst_ip = CURRENT_INTERFACE->ip_address;
    pkt->dst_port = dst_port;
    pkt->len = payload_len;
    
    pkt->data = $u8* malloc($u64 payload_len);
    memcpy($void* pkt->data, payload, $u64 payload_len);
    
    socket_push_packet(sock, pkt);
}

void udp_send_packet(u32 dst_ip, u16 src_port, u16 dst_port, void* payload, u16 payload_len) {
    print("udp_send_packet() : sending UDP packet to: ");
    print_ipv4_addr(dst_ip);
    println("");

    u64 udp_packet_len = sizeof(UDPHeader) + $u64 payload_len;

    void* buffer = malloc(udp_packet_len);
    memset(buffer, 0, udp_packet_len);

    UDPHeader* udp = $UDPHeader* buffer;
    void* dst_payload = $void* ($u64 buffer + sizeof(UDPHeader));

    udp->src_port = cpu_to_be(src_port);
    udp->dst_port = cpu_to_be(dst_port);
    udp->length = cpu_to_be($u16 udp_packet_len);
    udp->checksum = $u16 0; // this is valid for ipv4, we can just not do it lol

    memcpy(dst_payload, payload, $u64 payload_len);

    ipv4_send_packet(dst_ip, IPv4_PROTOCOL_UDP, buffer, $u16 udp_packet_len);
    free(buffer, udp_packet_len);
}

[__GLOBAL_FIRST__] proto_ops* UDP_OPS;

void init_udp_ops() {
    UDP_OPS = $proto_ops* malloc(sizeof(proto_ops));
    new (UDP_OPS) proto_ops();
    UDP_OPS->send       = #<udp_send(socket*, u8*, u64, i32, sockaddr*)>;
    UDP_OPS->recieve    = #<udp_recieve(socket*, u8*, u64, i32, sockaddr*)>;
    UDP_OPS->connect    = #<udp_connect(socket*, sockaddr*, u64)>;
    UDP_OPS->bind       = #<udp_bind(socket*, sockaddr*, u64)>;
    UDP_OPS->close      = #<udp_close(socket*)>;
}

i32 udp_bind(socket* sock, sockaddr* addr, u64 len) {
    // check if incoming sockaddr len is valid ipv4 udp
    if(len < sizeof(sockaddr_in)) return -ERR_INVAL;

    sockaddr_in* sin = $sockaddr_in* addr;
    if(sin->sin_family != AF_INET) return -ERR_AFNOSUPPORT;

    // no support for ephermal ports yet...
    if(sin->sin_port == $u16 0) return -ERR_INVAL;
    if($u32 sin->sin_port >= MAX_PORTS) return -ERR_INVAL;

    if(UDP_PORT_TABLE[sin->sin_port] != nullptr) {
        return -ERR_ADDRINUSE;
    }

    print("udp_bind() : udp bind called for ");
    print_ipv4_addr(sin->sin_addr);
    print(" on port: ");
    println($u64 sin->sin_port);

    UDP_PORT_TABLE[sin->sin_port] = sock;
    sock->local_port = sin->sin_port;
    sock->local_addr = sin->sin_addr;

    return 0;
}

i32 udp_recieve(socket* sock, u8* buf, u64 len, i32 flags, sockaddr* src_addr) {
    // println("udp_recieve() : udp receive called");
    
    packet* pkt = socket_pop_packet(sock);

    if($void* pkt == nullptr) {
        return -ERR_AGAIN;
    }

    u8* temp = $u8* malloc($u64 pkt->len + 0x1);
    memcpy($void* temp, $void* pkt->data, $u64 pkt->len);
    temp[pkt->len] = $u8 0;
    println(temp);

    u64 copy_len = len;
    if($u64 pkt->len < len) {
        copy_len = $u64 pkt->len;
    }

    memcpy($void* buf, $void* pkt->data, copy_len);

    if($void* src_addr != nullptr) {
        sockaddr_in* sin = $sockaddr_in* src_addr;
        sin->sin_family = AF_INET;
        sin->sin_port = pkt->src_port;
        sin->sin_addr = pkt->src_ip;
        memset($void* @sin->sin_zero[0], 0, sizeof(sockaddr_in) - $u64 6); // calculate padding, sockaddr_in and sockaddr should be the same size.
    }

    u8* temp2 = $u8* malloc($u64 copy_len + 0x1);
    memcpy($void* temp2, $void* buf, $u64 copy_len);
    temp2[copy_len] = $u8 0;
    println(temp2);

    println($u64 copy_len);

    free($void* pkt->data, $u64 pkt->len);
    free($void* pkt, sizeof(packet));

    println($u64 copy_len);

    return $i32 copy_len;
}

i32 udp_send(socket* sock, u8* buf, u64 len, i32 flags, sockaddr* dest_addr) {
    if(len > $u64 65507) return -ERR_MSGSIZE; // max udp payload size

    u32 dst_ip = $u32 0;
    u16 dst_port = $u16 0;

    if(dest_addr != nullptr) {
        sockaddr_in* sin = $sockaddr_in* dest_addr;
        if(sin->sin_family != AF_INET) return -ERR_AFNOSUPPORT;

        dst_ip = sin->sin_addr;
        dst_port = sin->sin_port;
    } else {
        if(sock->remote_addr == $u32 0) return -ERR_DESTADDRREQ;

        dst_ip = sock->remote_addr;
        dst_port = sock->remote_port;
    }

    // if didnt call bind before
    if(sock->local_port == $u16 0) {
        i32 port = get_next_ephemeral_port(UDP_PORT_TABLE);
        if(port < 0) return -ERR_ADDRINUSE;

        UDP_PORT_TABLE[port] = sock;
        sock->local_port = $u16 port;
    }

    udp_send_packet(dst_ip, sock->local_port, dst_port, $void* buf, $u16 len);

    return $i32 len;
}

i32 udp_close(socket* sock) {
    if(sock->local_port != $u16 0) {
        assert(UDP_PORT_TABLE[sock->local_port] == sock, "udp_close() : current socket in table does not match associated port");
        UDP_PORT_TABLE[sock->local_port] = $socket* nullptr;
    }

    while(1) {
        packet* pkt = socket_pop_packet(sock);
        if(pkt->next == nullptr) break;

        free($void* pkt->data, $u64 pkt->len);
        free($void* pkt, sizeof(packet));
    }

    return 0;
}

i32 udp_connect(socket* sock, sockaddr* addr, u64 len) {
    if(len < sizeof(sockaddr_in)) return -ERR_INVAL;

    sockaddr_in* sin = $sockaddr_in* addr;
    if(sin->sin_family != AF_INET) return -ERR_AFNOSUPPORT;

    sock->remote_addr = sin->sin_addr;
    sock->remote_port = sin->sin_port;

    // update state...

    return 0;
}