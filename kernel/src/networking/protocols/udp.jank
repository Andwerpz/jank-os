// https://en.wikipedia.org/wiki/User_Datagram_Protocol#UDP_datagram_structure

struct UDPHeader {
    u16 src_port;
    u16 dst_port;
    u16 length;
    u16 checksum;
}

struct UDPPseudoHeader {
    u32 src_ip;
    u32 dst_ip;
    u8 zeroes;
    u8 protocol;
    u16 udp_length;
}

void udp_handle(UDPHeader* udp, u16 len, u32 src_ip) {
    u16 src_port = be_to_cpu(udp->src_port);
    u16 dst_port = be_to_cpu(udp->dst_port);
    u16 length   = be_to_cpu(udp->length);

    if(length < $u16 sizeof(UDPHeader)) {
        println("udp_handle() : udp length shorter than header");
        return;
    }

    void* payload = $void* ($u64 udp + sizeof(UDPHeader));
    u16 payload_len = length - $u16 sizeof(UDPHeader);

    if(be_to_cpu(udp->dst_port) == DHCP_CLIENT_LISTEN_PORT) {
        DHCPHeader* dhcp = $DHCPHeader* payload; 
        dhcp_handle(dhcp, payload_len);
    }
}

void udp_send_packet(u32 dst_ip, u16 src_port, u16 dst_port, void* payload, u16 payload_len) {
    print("udp_send_packet() : sending UDP packet to: ");
    print_ipv4_addr(dst_ip);
    println("");

    u64 udp_packet_len = sizeof(UDPHeader) + $u64 payload_len;

    void* buffer = malloc(udp_packet_len);
    memset(buffer, 0, udp_packet_len);

    UDPHeader* udp = $UDPHeader* buffer;
    void* dst_payload = $void* ($u64 buffer + sizeof(UDPHeader));

    udp->src_port = cpu_to_be(src_port);
    udp->dst_port = cpu_to_be(dst_port);
    udp->length = cpu_to_be($u16 udp_packet_len);
    udp->checksum = $u16 0; // this is valid for ipv4, we can just not do it lol

    memcpy(dst_payload, payload, $u64 payload_len);

    ipv4_send_packet(dst_ip, IPv4_PROTOCOL_UDP, buffer, $u16 udp_packet_len);
    free(buffer, udp_packet_len);
}