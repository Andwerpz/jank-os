[__GLOBAL_FIRST__] u16 ARP_HW_TYPE_ETHERNET     = $u16 0x0001;
[__GLOBAL_FIRST__] u16 ARP_PROTO_TYPE_IPV4      = $u16 0x0800;
[__GLOBAL_FIRST__] u16 ARP_OPCODE_REQUEST       = $u16 0x0001;
[__GLOBAL_FIRST__] u16 ARP_OPCODE_REPLY         = $u16 0x0002;

[__GLOBAL_FIRST__] PendingPacket* ARP_WAIT_QUEUE_HEAD = $PendingPacket* nullptr;
[__GLOBAL_FIRST__] u32 ARP_WAIT_QUEUE_MAX_RETRIES = $u32 5;
[__GLOBAL_FIRST__] u64 ARP_WAIT_QUEUE_RETRY_INTERVAL = (0x3B9ACA00 * $u64 1);

[__GLOBAL_FIRST__] u64 ARP_ENTRY_TTL = (0x3B9ACA00 * $u64 60);
hashmap<u32, ARPEntry*> ARP_TABLE;
vector<u32> ARP_TABLE_IPS; // used to keep track of ips for now... until i can iterate a hashmap (@andrewli)

struct ARPHeader {
    u16     hw_type;        // Hardware Type
    u16     proto_type;     // Protocol Type
    u8      hw_len;         // Hardware Length
    u8      proto_len;      // Protocol Length
    u16     opcode;         // Operation
    u8[6]   sender_mac;     // Sender Hardware Address
    u32     sender_ip;      // Sender Protocol Address
    u8[6]   target_mac;     // Target Hardware Address
    u32     target_ip;      // Target Protocol Address
}

struct ARPEntry {
    u8[6]   mac;
    u64     expire_at;
}

struct PendingPacket {
    u32 target_ip;
    u8* data;       // this is the entire packet, NOT packet->data (heh)
    u16 len;        // this is the length of the entire packet, NOT packet->data (heh)
    PendingPacket* next;

    u32 retries;
    u64 last_attempt;
}

void arp_handle(ARPHeader* arp) {
    println("arp_handle() : Handling incoming ARP message");

    u16 opcode = be_to_cpu(arp->opcode);
    u32 target_ip = be_to_cpu(arp->target_ip);

    if(opcode == ARP_OPCODE_REPLY) {
        println("arp_handle() : Detected ARP reply");
        u32 sender_ip = be_to_cpu(arp->sender_ip);

        print("arp_handle() : Sender IP [");
        print_ipv4_addr(sender_ip);
        print("] is at MAC [");
        print_mac_addr(arp->sender_mac);
        println("]");

        arp_flush_pending(sender_ip, arp->sender_mac);

    } else if(opcode == ARP_OPCODE_REQUEST) {
        println("arp_handle() : Detected ARP request");
        if(target_ip == CURRENT_INTERFACE->ip_address) {
            println("arp_handle() : Target IP matched with host, sending reply back");

            u64 size = sizeof(EthernetHeader) + sizeof(ARPHeader);
            u8* buffer = $u8* malloc(size);
            memset($void* buffer, 0, size);

            EthernetHeader* eth_reply = $EthernetHeader* buffer;
            ARPHeader* arp_reply = $ARPHeader* ($u64 buffer + sizeof(EthernetHeader));

            // set dst mac to sender mac
            set_mac(eth_reply->dst, arp->sender_mac);

            // set src mac
            set_mac(eth_reply->src, CURRENT_INTERFACE->mac_address);

            // set ethertype
            eth_reply->type = cpu_to_be(ETHERNET_TYPE_ARP);

            // arp header
            arp_reply->hw_type = cpu_to_be(ARP_HW_TYPE_ETHERNET);
            arp_reply->proto_type = cpu_to_be(ARP_PROTO_TYPE_IPV4);
            arp_reply->hw_len = $u8 6;
            arp_reply->proto_len = $u8 4;
            arp_reply->opcode = cpu_to_be(ARP_OPCODE_REPLY);

            // set self as sender
            set_mac(arp_reply->sender_mac, CURRENT_INTERFACE->mac_address);
            arp_reply->sender_ip = cpu_to_be(CURRENT_INTERFACE->ip_address);

            // set target, to src mac
            set_mac(arp_reply->target_mac, arp->sender_mac);
            arp_reply->target_ip = arp->sender_ip;

            CURRENT_INTERFACE->send#(buffer, $u16 size);
            
            free($void* buffer, size);
        } else {
            print("arp_handle() : Target IP is [");
            print_ipv4_addr(target_ip);
            println("], no match with host IP, ignoring");
        }
    } else {
        println("arp_handle() : Unknown ARP opcode");
    }
}

void send_arp_request(u32 target_ip) {
    print("send_arp_request() : Sending ARP request to [");
    print_ipv4_addr(target_ip);
    println("]");
    
    u64 size = sizeof(EthernetHeader) + sizeof(ARPHeader);
    u8* buffer = $u8* malloc(size);
    memset($void* buffer, 0, size);

    EthernetHeader* eth = $EthernetHeader* buffer;
    ARPHeader* arp = $ARPHeader* ($u64 buffer + sizeof(EthernetHeader));

    // set dst mac to FF:FF:FF:FF:FF:FF (broadcast)
    for(i32 i = 0; i < 6; i++) eth->dst[i] = $u8 0xFF;

    // set src mac
    set_mac(eth->src, CURRENT_INTERFACE->mac_address);

    // set ethertype
    eth->type = cpu_to_be(ETHERNET_TYPE_ARP);

    // arp header
    arp->hw_type = cpu_to_be(ARP_HW_TYPE_ETHERNET);
    arp->proto_type = cpu_to_be(ARP_PROTO_TYPE_IPV4);
    arp->hw_len = $u8 6;
    arp->proto_len = $u8 4;
    arp->opcode = cpu_to_be(ARP_OPCODE_REQUEST);

    // set self as sender
    set_mac(arp->sender_mac, CURRENT_INTERFACE->mac_address);
    arp->sender_ip = cpu_to_be(CURRENT_INTERFACE->ip_address);

    // set target, mac is unknown (00:00:00:00:00:00)
    for(i32 i = 0; i < 6; i++) arp->target_mac[i] = $u8 0;
    arp->target_ip = cpu_to_be(target_ip);

    // send
    CURRENT_INTERFACE->send#(buffer, $u16 size);
    
    free($void* buffer, size);
}

void arp_update(u32 ip, u8[6]& mac) {
    if(ARP_TABLE.contains(ip)) {
        ARPEntry* entry = ARP_TABLE.get(ip);
        set_mac(mac, entry->mac);
        entry->expire_at = hpet_get_ns() + ARP_ENTRY_TTL;
        return;
    }

    ARPEntry* entry = $ARPEntry* malloc(sizeof(ARPEntry));
    set_mac(entry->mac, mac);
    ARP_TABLE.insert(ip, entry);
    ARP_TABLE_IPS.push_back(ip);
}

i32 arp_lookup(u32 ip, u8[6]& mac) {
    if(ARP_TABLE.contains(ip)) {
        ARPEntry* entry = ARP_TABLE.get(ip);

        if(entry->expire_at < hpet_get_ns()) {
            return 0;
        }

        set_mac(mac, entry->mac);
        return 1;
    }
    return 0;
}

void arp_table_dump() {
    println("=-----=");
    println("Current ARP Table:");
    for(u64 i = 0x0; i < ARP_TABLE_IPS.size(); i++) {
        if(ARP_TABLE.contains(ARP_TABLE_IPS[i])) {
            ARPEntry* entry = ARP_TABLE.get(ARP_TABLE_IPS[i]);
            print_ipv4_addr(ARP_TABLE_IPS[i]);
            print(" - ");
            print_mac_addr(entry->mac);
            print(" | Expires at: ");
            println(entry->expire_at);
        }
    }
    println("=-----=");
}

void arp_queue_packet(u32 target_ip, u8* packet, u16 len) {
    PendingPacket* pp = $PendingPacket* malloc(sizeof(PendingPacket));
    pp->target_ip = target_ip;
    pp->len = len;

    pp->data = $u8* malloc($u64 len);
    memcpy($void* pp->data, $void* packet, $u64 len);

    pp->retries = $u32 0;
    pp->last_attempt = hpet_get_ns();

    pp->next = ARP_WAIT_QUEUE_HEAD;
    ARP_WAIT_QUEUE_HEAD = pp;
}

void arp_flush_pending(u32 resolved_ip, u8[6]& dst_mac) {
    println("arp_flush_pending() : Checking ARP queue for resolved IP");

    PendingPacket* curr = ARP_WAIT_QUEUE_HEAD;
    PendingPacket* prev = $PendingPacket* nullptr;

    while(curr != nullptr) {
        if(curr->target_ip == resolved_ip) {
            println("arp_flush_pending() : Found a match, sending queued packet out");

            // there is now an arp table entry for this
            ethernet_send_frame(dst_mac, curr->data, curr->len, ETHERNET_TYPE_IPV4);

            PendingPacket* to_free = curr;
            if(prev == nullptr) {
                ARP_WAIT_QUEUE_HEAD = curr->next;
                curr = ARP_WAIT_QUEUE_HEAD;
            } else {
                prev->next = curr->next;
                curr = curr->next;
            }

            free($void* to_free->data, $u64 to_free->len);
            free($void* to_free, sizeof(PendingPacket));
        } else {
            prev = curr;
            curr = curr->next;
        }
    }
}

void arp_check_timeouts() {
    u64 now = hpet_get_ns();

    PendingPacket* curr = ARP_WAIT_QUEUE_HEAD;
    PendingPacket* prev = $PendingPacket* nullptr;

    while(curr != nullptr) {
        if(now - curr->last_attempt >= ARP_WAIT_QUEUE_RETRY_INTERVAL) {
            if(curr->retries < ARP_WAIT_QUEUE_MAX_RETRIES) {
                println("arp_check_timeouts() : Retrying ARP request");
                send_arp_request(curr->target_ip);
                
                curr->retries++;
                curr->last_attempt = now;
                
                prev = curr;
                curr = curr->next;
            } else {
                print("arp_check_timeouts() : ARP resolution failed for [");
                print_ipv4_addr(curr->target_ip);
                println("], dropping packet");

                PendingPacket* to_free = curr;
                if(prev == nullptr) {
                    ARP_WAIT_QUEUE_HEAD = curr->next;
                    curr = ARP_WAIT_QUEUE_HEAD;
                } else {
                    prev->next = curr->next;
                    curr = curr->next;
                }

                free($void* to_free->data, $u64 to_free->len);
                free($void* to_free, sizeof(PendingPacket));
            }

        } else {
            prev = curr;
            curr = curr->next;
        }
    }
}