// https://man7.org/linux/man-pages/man2/socket.2.html
// https://man7.org/linux/man-pages/man7/address_families.7.html

[__GLOBAL_FIRST__] i32 SOCKET_STATE_CREATED = 0;
[__GLOBAL_FIRST__] i32 SOCKET_STATE_BOUND = 1;
[__GLOBAL_FIRST__] i32 SOCKET_STATE_CONNECTED = 2;

[__GLOBAL_FIRST__] file_ops* FILE_OPS_SOCKET;

[__GLOBAL_FIRST__] u32 MAX_PORTS = $u32 (1 << 16);
[__GLOBAL_FIRST__] u32 RESERVED_PORT_START = $u32 1;
[__GLOBAL_FIRST__] u32 RESERVED_PORT_END = $u32 1024;
[__GLOBAL_FIRST__] u32 EPHEMERAL_PORT_START = $u32 49152;
[__GLOBAL_FIRST__] u32 EPHEMERAL_PORT_END = $u32 (1 << 16);

socket** UDP_PORT_TABLE;
socket** TCP_PORT_TABLE;

struct socket {
    i32 domain;
    i32 type;
    i32 protocol;
    
    proto_ops* ops;

    i32 state;          // this will be used for all types probably
    void* proto_info;   // this will be used for protocol specific stuff

    u32 local_addr;
    u16 local_port;
    u32 remote_addr;
    u16 remote_port;
    
    waitq wait_queue;
}

struct Packet {
    u32 src_ip;
    u16 src_port;
    u32 dst_ip;
    u16 dst_port;
    
    u16 len;
    u8* data;
    
    Packet* next; 
}

struct proto_ops {
    fn<i32(socket*, sockaddr*, u64)> bind;
    fn<i32(socket*, i32)> listen;
    fn<i32(socket*, sockaddr*, u64*)> accept;
    fn<i32(socket*, sockaddr*, u64)> connect;
    fn<i32(socket*, u8*, u64, i32, sockaddr*)> send;
    fn<i32(socket*, u8*, u64, i32, sockaddr*)> receive;
    fn<i32(socket*)> close;
}

i32 get_next_ephemeral_port(socket** port_table) {
    for(u32 p = EPHEMERAL_PORT_START; p < EPHEMERAL_PORT_END; p++) {
        if(port_table[p] == nullptr) return $i32 p;
    }
    return -1;
}

void init_port_tables() {
    // init tables
    UDP_PORT_TABLE = $socket** malloc($u64 MAX_PORTS * sizeof(socket*));
    memset($void* UDP_PORT_TABLE, 0, $u64 MAX_PORTS * sizeof(socket*));
    TCP_PORT_TABLE = $socket** malloc($u64 MAX_PORTS * sizeof(socket*));
    memset($void* TCP_PORT_TABLE, 0, $u64 MAX_PORTS * sizeof(socket*));
}

void socket_push_packet(Packet*& head, Packet*& tail, Packet* pkt) {
    pkt->next = $Packet* nullptr;
    
    if(head == nullptr) {
        head = pkt;
        tail = pkt;
    } else {
        // queue, pkt->next is the next packet in line.
        tail->next = pkt;
        tail = pkt;
    }
}

Packet* socket_pop_packet(Packet*& head, Packet*& tail) {
    if(head == nullptr) {
        return $Packet* nullptr;
    }

    Packet* pkt = head;

    head = pkt->next;

    if(head == nullptr) {
        tail = $Packet* nullptr;
    }

    pkt->next = $Packet* nullptr;

    return pkt;
}

void init_socket_file_ops() {
    FILE_OPS_SOCKET = $file_ops* malloc(sizeof(file_ops));
    new (FILE_OPS_SOCKET) file_ops();
    FILE_OPS_SOCKET->op_read        = #<socket_read(file*, u8*, u64)>;
    FILE_OPS_SOCKET->op_write       = #<socket_write(file*, u8*, u64)>;
    FILE_OPS_SOCKET->op_lseek       = #<socket_lseek(file*, i64, i32)>;
    FILE_OPS_SOCKET->op_getdents    = #<socket_getdents(file*, u8*, u64)>;
    FILE_OPS_SOCKET->op_close       = #<socket_close(file*)>;
    FILE_OPS_SOCKET->op_truncate    = #<socket_truncate(file*, u64)>;
    FILE_OPS_SOCKET->op_fstat       = #<socket_fstat(file*, stat*)>;
}

i64 socket_read(file* f, u8* buf, u64 len) {
    socket* sock = $socket* f->resource_ptr;
    i32 ret = sock->ops->receive#(sock, buf, len, 0, $sockaddr* nullptr);
    return $i64 ret;
}

i64 socket_write(file* f, u8* buf, u64 len) {
    socket* sock = $socket* f->resource_ptr;
    i32 ret = sock->ops->send#(sock, buf, len, 0, $sockaddr* nullptr);
    return $i64 ret;
}

i64 socket_lseek(file* f, i64 offset, i32 whence) {
    // no seek in network
    return $i64 -1;
}

i64 socket_getdents(file* f, u8* buf, u64 len) {
    // socket is not a directory
    return $i64 -1;
}

i32 socket_close(file* f) {
    socket* sock = $socket* f->resource_ptr;
    i32 ret = sock->ops->close#(sock);
    sock->~();
    free($void* sock, sizeof(socket));
    return ret;
}

i32 socket_truncate(file* f, u64 len) {
    // not make the sense for the socket
    return -1;
}

i32 socket_fstat(file* f, stat* s) {
    memset($void* s, 0, sizeof(stat));

    s->st_dev = 0x0;
    s->st_ino = 0x0;
    s->st_nlink = 0x1;

    s->st_mode = S_IFSOCK | $mode_t 0o666;

    s->st_rdev = 0x0;
    s->st_size = $i64 0x0;
    s->st_blksize = $i64 PAGE_SIZE;
    s->st_blocks = $i64 0x0;

    return 0;
}