// https://man7.org/linux/man-pages/man2/socket.2.html
// https://man7.org/linux/man-pages/man7/address_families.7.html

[__GLOBAL_FIRST__] file_ops* FILE_OPS_SOCKET;

[__GLOBAL_FIRST__] u16 AF_INET = $u16 2;

[__GLOBAL_FIRST__] i32 SOCK_STREAM  = 1; // TCP
[__GLOBAL_FIRST__] i32 SOCK_DGRAM   = 2; // UDP
[__GLOBAL_FIRST__] i32 SOCK_RAW     = 3;

[__GLOBAL_FIRST__] i32 IPPROTO_ICMP = 1;
[__GLOBAL_FIRST__] i32 IPPROTO_TCP  = 6;
[__GLOBAL_FIRST__] i32 IPPROTO_UDP  = 17;

[__GLOBAL_FIRST__] u32 MAX_PORTS = $u32 (1 << 16);
socket** UDP_PORT_TABLE;
socket** TCP_PORT_TABLE;


void init_port_tables() {
    // init tables
    UDP_PORT_TABLE = $socket** malloc($u64 MAX_PORTS * sizeof(socket*));
    memset($void* UDP_PORT_TABLE, 0, $u64 MAX_PORTS * sizeof(socket*));
    TCP_PORT_TABLE = $socket** malloc($u64 MAX_PORTS * sizeof(socket*));
    memset($void* TCP_PORT_TABLE, 0, $u64 MAX_PORTS * sizeof(socket*));

}

struct packet {
    u32 src_ip;
    u16 src_port;
    u32 dst_ip;
    u16 dst_port;
    
    u16 len;
    u8* data;
    
    packet* next; 
}

struct proto_ops {
    fn<i32(socket*, sockaddr*, i32)> bind;
    fn<i32(socket*, sockaddr*)> connect;
    fn<i32(socket*, packet*)> send;
    fn<i32(socket*, u8*, u64, i32, sockaddr*)> recieve;
    fn<i32(socket*)> close;
}


// the sockaddr_in and the sockaddr are the same size so we can cast the more
// general sockaddr struct to the more specific sockaddr_in struct
// the address family will always(?) be the first 2 bytes for both.
// we can support more address families this way.

struct sockaddr {
    u16 sa_family;
    u8[14] sa_data;
}

struct sockaddr_in {
    u16 sin_family;
    u16 sin_port;
    u32 sin_addr;
    u8[8] sin_zero;
}


struct socket {
    i32 domain;
    i32 type;
    i32 protocol;
    
    proto_ops* ops;
    
    i32 state;
    u32 local_addr;
    u16 local_port;
    u32 remote_addr;
    u16 remote_port;
    
    packet* rx_head; 
    packet* rx_tail;
    u64 rx_count;

    socket() {
        this.rx_head = $packet* nullptr;
        this.rx_tail = $packet* nullptr;
    }
}

void socket_push_packet(socket* sock, packet* pkt) {
    pkt->next = $packet* nullptr;
    
    if(sock->rx_head == nullptr) {
        sock->rx_head = pkt;
        sock->rx_tail = pkt;
    } else {
        // queue, pkt->next is the next packet in line.
        sock->rx_tail->next = pkt;
        sock->rx_tail = pkt;
    }
}

packet* socket_pop_packet(socket* sock) {
    if(sock->rx_head == nullptr) {
        return $packet* nullptr;
    }

    packet* pkt = sock->rx_head;

    sock->rx_head = pkt->next;

    if(sock->rx_head == nullptr) {
        sock->rx_tail = $packet* nullptr;
    }

    pkt->next = $packet* nullptr;

    return pkt;
}

void init_socket_file_ops() {
    FILE_OPS_SOCKET = $file_ops* malloc(sizeof(file_ops));
    new (FILE_OPS_SOCKET) file_ops();
    FILE_OPS_SOCKET->op_read        = #<socket_read(file*, u8*, u64)>;
    FILE_OPS_SOCKET->op_write       = #<socket_write(file*, u8*, u64)>;
    FILE_OPS_SOCKET->op_lseek       = #<socket_lseek(file*, i64, i32)>;
    FILE_OPS_SOCKET->op_getdents    = #<socket_getdents(file*, u8*, u64)>;
    FILE_OPS_SOCKET->op_close       = #<socket_close(file*)>;
    FILE_OPS_SOCKET->op_truncate    = #<socket_truncate(file*, u64)>;
    FILE_OPS_SOCKET->op_fstat       = #<socket_fstat(file*, stat*)>;
}

i64 socket_read(file* f, u8* buf, u64 len) {
    socket* socket = $socket* f->resource_ptr;

    return $i64 0;
}

i64 socket_write(file* f, u8* buf, u64 len) {
    socket* socket = $socket* f->resource_ptr;

    return $i64 0;
}

i64 socket_lseek(file* f, i64 offset, i32 whence) {
    // no seek in network
    return $i64 -1;
}

i64 socket_getdents(file* f, u8* buf, u64 len) {
    // socket is not a directory
    return $i64 -1;
}

i32 socket_close(file* f) {
    socket* socket = $socket* f->resource_ptr;
    // return socket->ops->close();
    return -1;
}

i32 socket_truncate(file* f, u64 len) {
    // not make the sense for the socket
    return -1;
}

i32 socket_fstat(file* f, stat* s) {
    memset($void* s, 0, sizeof(stat));

    s->st_dev = 0x0;
    s->st_ino = 0x0;
    s->st_nlink = 0x1;

    s->st_mode = S_IFSOCK | $mode_t 0o666;

    s->st_rdev = 0x0;
    s->st_size = $i64 0x0;
    s->st_blksize = $i64 PAGE_SIZE;
    s->st_blocks = $i64 0x0;

    return 0;
}