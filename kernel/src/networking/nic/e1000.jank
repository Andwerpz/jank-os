// specs in docs/e1000.pdf
// online ver: https://courses.cs.washington.edu/courses/cse451/16au/readings/e1000.pdf

[__GLOBAL_FIRST__] u16 INTEL_VEND = $u16 0x8086;
[__GLOBAL_FIRST__] u16 E1000_DEV = $u16 0x100E;

[__GLOBAL_FIRST__] u8 EEPROM_EXISTS = $u8 0;
[__GLOBAL_FIRST__] u64 MMIO_BASE = 0x0;
[__GLOBAL_FIRST__] u8 E1000_IRQ = $u8 0;
[__GLOBAL_FIRST__] u64 INTNO_E1000 = 0x1000;

[__GLOBAL_FIRST__] u64 E1000_NUM_RDESC = $u64 32;
[__GLOBAL_FIRST__] E1000_RDESC* RDESC_RING;
[__GLOBAL_FIRST__] u16 CURR_RDESC = $u16 0;

[__GLOBAL_FIRST__] u64 E1000_NUM_TX_DESC = $u64 32;
[__GLOBAL_FIRST__] E1000_TDESC* TDESC_RING;
[__GLOBAL_FIRST__] u16 CURR_TDESC = $u16 0;

// registers
// table 13-2 contains the list of registers
[__GLOBAL_FIRST__] u32 REG_CTRL = $u32 0x00; // Device Control
[__GLOBAL_FIRST__] u32 REG_EERD = $u32 0x14; // EEPROM/Flash Control/Data
[__GLOBAL_FIRST__] u32 REG_FCAL = $u32 0x28; // Flow Control Address Low 
[__GLOBAL_FIRST__] u32 REG_FCAH = $u32 0x2C; // Flow Control Address High
[__GLOBAL_FIRST__] u32 REG_FCT = $u32 0x30; // Flow Control Type
[__GLOBAL_FIRST__] u32 REG_FCTTV = $u32 0x170; // Flow Control Transmit Timer Value
[__GLOBAL_FIRST__] u32 REG_ICR = $u32 0xC0; // Interrupt Cause Read
[__GLOBAL_FIRST__] u32 REG_IMS = $u32 0xD0; // Interrupt Mask Set/Read
[__GLOBAL_FIRST__] u32 REG_IMC = $u32 0xD8; // Interrupt Mask Clear

[__GLOBAL_FIRST__] u32 REG_RCTL = $u32 0x100; // Receive Control
[__GLOBAL_FIRST__] u32 REG_RDBAL = $u32 0x2800; // Receive Descriptor Base Low
[__GLOBAL_FIRST__] u32 REG_RDBAH = $u32 0x2804; // Receive Descriptor Base High
[__GLOBAL_FIRST__] u32 REG_RDLEN = $u32 0x2808; // Receive Descriptor Length
[__GLOBAL_FIRST__] u32 REG_RDH = $u32 0x2810; // Receive Descriptor Head
[__GLOBAL_FIRST__] u32 REG_RDT = $u32 0x2818; // Receive Descriptor Tail

[__GLOBAL_FIRST__] u32 REG_TCTL = $u32 0x400; // Transmit Control 
[__GLOBAL_FIRST__] u32 REG_TDBAL = $u32 0x3800; // Transmit Descriptor Base Low 
[__GLOBAL_FIRST__] u32 REG_TDBAH = $u32 0x3804; // Transmit Descriptor Base Low 
[__GLOBAL_FIRST__] u32 REG_TDLEN = $u32 0x3808; // Transmit Descriptor Base Low 
[__GLOBAL_FIRST__] u32 REG_TDH = $u32 0x3810; // Transmit Descriptor Base Low 
[__GLOBAL_FIRST__] u32 REG_TDT = $u32 0x3818; // Transmit Descriptor Base Low 

[__GLOBAL_FIRST__] u32 REG_MTA = $u32 0x5200; // Multicast Table Array

// CTRL bits
[__GLOBAL_FIRST__] u32 CTRL_LRST = $u32 0x8; // Link Reset, 0b = Normal; 1b = Link Reset
[__GLOBAL_FIRST__] u32 CTRL_ASDE = $u32 0x20; // Auto-Speed Detection Enable, needs to be set together with SLU
[__GLOBAL_FIRST__] u32 CTRL_SLU = $u32 0x40; // Set Link Up
[__GLOBAL_FIRST__] u32 CTRL_VME = $u32 0x40000000; // VLAN Mode Enable
[__GLOBAL_FIRST__] u32 CTRL_PHY_RST = $u32 0x80000000; // PHY Reset, 0b = Normal. 1b = Assert hardware reset to the internal PHY

// EERD bits
[__GLOBAL_FIRST__] u32 EERD_START = $u32 0x0; // Start Read, write 1b to read word in address field and write to data field. self clearing
[__GLOBAL_FIRST__] u32 EERD_DONE = $u32 0x10; // Read Done, set to 1b when done, set to 0b when in progess. software writes ignored.
[__GLOBAL_FIRST__] u32 EERD_DATA = $u32 0xFFFF0000; // Read Data, Data returned from EEPROM read.

// ICR, IMS, IMC bits
[__GLOBAL_FIRST__] u32 IMS_LSC = $u32 0x2; // Link Status Change, This bit is set each time the link status changes (either from up to down, or from down to up)
[__GLOBAL_FIRST__] u32 IMS_RXT0 = $u32 0x80; // Receiver Timer Interrupt, Set when the receiver timer expires.

// RCTL bits
[__GLOBAL_FIRST__] u32 RCTL_EN = $u32 0x2; // Receiver Enable, The receiver is enabled when this bit is 1b. Writing this bit to 0b stops reception after receipt of any in-progress packets
[__GLOBAL_FIRST__] u32 RCTL_MPE = $u32 0x10; // Multicast Promiscuous Enabled, 0b = Disabled. 1b = Enabled.
[__GLOBAL_FIRST__] u32 RCTL_BAM = $u32 0x8000; // Broadcast Accept Mode. 0 = ignore broadcast; 1 = accept broadcast packets
[__GLOBAL_FIRST__] u32 RCTL_BSIZE = $u32 0x30000; // Receive Buffer Size
[__GLOBAL_FIRST__] u32 RCTL_BSEX = $u32 0x2000000; // Buffer Size Extension, When set to one, the original BSIZE values are multiplied by 16
[__GLOBAL_FIRST__] u32 RCTL_SECRC = $u32 0x4000000; // Strip Ethernet CRC from incoming packet, 0b = Do not strip CRC field. 1b = Strip CRC field.

// RDBAL bits
[__GLOBAL_FIRST__] u32 RDBAL_RDBAL = $u32 0xFFFFFFF0; // Receive Descriptor Base Address Low.

// RDH bits
[__GLOBAL_FIRST__] u32 RDH_RDH = $u32 0xFFFF; // Receive Descriptor Head.

// RDT bits
[__GLOBAL_FIRST__] u32 RDT_RDT = $u32 0xFFFF; // Receive Descriptor Tail.

// TCTL bits
[__GLOBAL_FIRST__] u32 TCTL_EN = $u32 0x2; // Transmit Enable, The transmitter is enabled when this bit is set to 1b. Writing 0b to this bit stops transmission after any in progress packets are sent.
[__GLOBAL_FIRST__] u32 TCTL_PSP = $u32 0x8; // Pad Short Packets, 0b = Do not pad. 1b = Pad short packets.

// TDBAL bits
[__GLOBAL_FIRST__] u32 TDBAL_TDBAL = $u32 0xFFFFFFF0; // Transmit Descriptor Base Address Low [31:4].

// TDH bits
[__GLOBAL_FIRST__] u32 TDH_TDH = $u32 0xFFFF; // Transmit Descriptor Head.

// TDT bits
[__GLOBAL_FIRST__] u32 TDT_TDT = $u32 0xFFFF; // Transmit Descriptor Tail.

// recieve descriptor (3.2.3)
struct E1000_RDESC {
    u64 addr;
    u16 length;
    u16 checksum;
    u8  status;
    u8  errors;
    u16 special;
}

[__GLOBAL_FIRST__] u8 RDESC_STATUS_DD = $u8 0x1; // Descriptor Done, Indicates whether hardware is done with the descriptor. When set along with EOP, the received packet is complete in main memory.

// transmit descriptor (3.3.3)
struct E1000_TDESC {
    u64 addr;
    u16 length;
    u8  cso;
    u8  cmd;
    u8  status;
    u8  css;
    u16 special;
}

[__GLOBAL_FIRST__] u8 TDESC_CMD_EOP = $u8 0x1; // End Of Packet, When set, indicates the last descriptor making up the packet. One or many descriptors can be used to form a packet.
[__GLOBAL_FIRST__] u8 TDESC_CMD_IFCS = $u8 0x2; // Insert FCS, Controls the insertion of the FCS/CRC field in normal Ethernet packets. IFCS is valid only when EOP is set.

void e1000_init(u64 addr) {
    println("e1000_init() : beginning initializing NIC");

    NetInterface* nic = $NetInterface* malloc(sizeof(NetInterface));
    memset($void* nic, 0, sizeof(NetInterface));
    nic->name = "eth0"; // temp name for now

    e1000_pci_setup(addr);
    e1000_get_mac_address(nic->mac_address);
    e1000_startup();
    e1000_enable_interrupts();
    e1000_init_rx();
    e1000_init_tx();

    nic->ip_address = $u32 0;
    nic->subnet_mask = $u32 0;
    nic->gateway_ip = $u32 0;
    nic->dhcp_server = $u32 0;
    nic->dns_server = $u32 0;

    nic->send = #<e1000_send(void*, u16)>;

    net_interfaces.push_back(nic);
    CURRENT_INTERFACE = nic;

    println("e1000_init() : finished initializing NIC");

    if(1) {
        init_dhcp();
        e1000_recieve_poll();
    }
}

void e1000_pci_setup(u64 addr) {
    println("e1000_pci_setup() : finished PCI setup");

    PCIHeader0* pci_hdr = $PCIHeader0* addr;

    u64 BAR0 = $u64 pci_hdr->BAR0;
    u64 BAR1 = $u64 pci_hdr->BAR1;
    
    assert((BAR0 & 0x1) == 0x0, "e1000_pci_setup() : BAR0 is not a memory space");

    u64 mmio_base_addr = 0x0;
    u64 mmio_size = 0x0;

    u64 type = (BAR0 & 0x6) >> 0x1;
    if(type == 0x0) {
        // 32 bit
        println("e1000_pci_setup() : detected 32 bit memory register base address");
        mmio_base_addr = $u64 (BAR0 & 0xFFFFFFF0);

        // get size
        pci_hdr->BAR0 = $u32 0xFFFFFFFF;
        u32 mask = pci_hdr->BAR0;
        pci_hdr->BAR0 = $u32 BAR0;

        mask = ~(mask & $u32 0xFFFFFFF0);
        mmio_size = $u64 mask + 0x1;
    } else if(type == 0x2) {
        // 64 bit
        println("e1000_pci_setup() : detected 64 bit memory register base address");
        u64 lower = $u64 (BAR0 & 0xFFFFFFF0);
        u64 upper = BAR1 << $u64 32;
        mmio_base_addr = upper | lower;

        // get size
        pci_hdr->BAR0 = $u32 0xFFFFFFFF;
        u64 mask_lower = $u64 pci_hdr->BAR0;
        pci_hdr->BAR0 = $u32 BAR0;

        pci_hdr->BAR1 = $u32 0xFFFFFFFF;
        u64 mask_upper = $u64 pci_hdr->BAR1;
        pci_hdr->BAR1 = $u32 BAR1;

        u64 mask = (mask_upper << $u64 32) | (mask_lower & 0xFFFFFFF0);
        mmio_size = ~mask + 0x1;
    } else {
        panic("e1000_pci_setup() : unknown memory register base address space size");
    }

    // identity map
    pagetable_t pt = pt_get_current();
    for(u64 vaddr = mmio_base_addr; vaddr < mmio_base_addr + mmio_size; vaddr += PAGE_SIZE) {
        pt_map_page_if_not_mapped(pt, $void* vaddr, $void* vaddr, PTE_WRITEABLE | PTE_PCD | PTE_PWT);
    }
    MMIO_BASE = mmio_base_addr;

    // command register modifications
    u16 command = pci_hdr->command;
    command |= $u16 0x2; // Memory Access Enable
    command |= $u16 0x4; // Enable Mastering
    pci_hdr->command = command;

    // read irq line, no safety checks here
    E1000_IRQ = pci_hdr->interrupt_line;
    print("e1000_pci_setup() : using IRQ: ");
    print_hex(E1000_IRQ);
    println("");
    IRQ_clear_mask(E1000_IRQ);

    // convert the irq to int vec
    INTNO_E1000 = IRQ_to_int_vec(E1000_IRQ);

    println("e1000_pci_setup() : finished PCI setup");
}

// will write 6 bytes to mac
void e1000_get_mac_address(u8[6]& mac) {
    println("e1000_get_mac_address() : attempting to read MAC from NIC EEPROM");

    // check if eeprom exists
    e1000_eeprom_check();
    if(!EEPROM_EXISTS) {
        // handle this later?
        panic("e1000_get_mac_address() : no EEPROM detected");
    }

    // read EEPROM for MAC address
    u16 temp = $u16 0x0;
    i32 mac_idx = 0;
    for(i32 i = 0; i < 3; i++) {
        temp = e1000_eeprom_read($u8 i);
        mac[mac_idx++] = $u8 (temp & $u16 0xFF);
        mac[mac_idx++] = $u8 (temp >> $u16 8);
    }

    print("init_e1000() : nic MAC address is ");
    print("[");
    print_mac_addr(mac);
    print("]");
    println("");
}

void e1000_startup() {
    println("e1000_startup() : beginning general intialization");

    // general configuration (14.3 in specs)
    println("init_e1000() : general configuration begin");

    // disable flow control
    u32* fcal_ptr = $u32* (MMIO_BASE + $u64 REG_FCAL);
    *fcal_ptr = $u32 0x0;
    u32* fcah_ptr = $u32* (MMIO_BASE + $u64 REG_FCAH);
    *fcah_ptr = $u32 0x0;
    u32* fct_ptr = $u32* (MMIO_BASE + $u64 REG_FCT);
    *fct_ptr = $u32 0x0;
    u32* fcttv_ptr = $u32* (MMIO_BASE + $u64 REG_FCTTV);
    *fcttv_ptr = $u32 0x0;

    // enable auto speed detection and set link up
    // disable vlans
    // clear link reset
    // clear phy reset
    u32* ctrl_ptr = $u32* (MMIO_BASE + $u64 REG_CTRL);
    u32 ctrl = *ctrl_ptr;
    ctrl |= CTRL_ASDE;
    ctrl |= CTRL_SLU;
    ctrl &= ~CTRL_VME;
    ctrl &= ~CTRL_LRST;
    ctrl &= ~CTRL_PHY_RST;
    *ctrl_ptr = ctrl;

    // zero out Multicast Table Array
    for(i32 i = 0; i < 128; i++) {
        u32* mta_ptr = $u32* (MMIO_BASE + $u64 REG_MTA + $u64 (i * 4));
        *mta_ptr = $u32 0;
    }

    println("e1000_startup() : finished general intialization");
}

void e1000_enable_interrupts() {
    println("e1000_enable_interrupts() : enabling interrupts");

    // register the interrupt vector
    idt_set_entry($u64 INTNO_E1000, $u64 @network_packet_receive_interrupt_entry_stub, $u16 0x08, $u8 0x0, IST_ATTR_PRESENT | IST_ATTR_DPL_KERNEL | IST_ATTR_INTERRUPT_GATE, $IDTEntry* IDT_PAGE);

    // register the pic bit
    IRQ_clear_mask(E1000_IRQ);

    // disable all interrupts
    u32* imc_ptr = $u32* (MMIO_BASE + $u64 REG_IMC);
    *imc_ptr = $u32 0xFFFF;

    // clear pending interrupts
    u32* icr_ptr = $u32* (MMIO_BASE + $u64 REG_ICR);
    u32 dummy = *icr_ptr;

    // configure Interrupt Mask
    u32* ims_ptr = $u32* (MMIO_BASE + $u64 REG_IMS);
    u32 ims = IMS_LSC | IMS_RXT0;
    *ims_ptr = ims;
}

void e1000_eeprom_check() {
    println("e1000_eeprom_check() : checking NIC EEPROM");
    u32* eerd_ptr = $u32* (MMIO_BASE + $u64 REG_EERD + $u64 EERD_START);
    *eerd_ptr = $u32 0x1; // set start bit
    for(i32 i = 0; i < 10000; i++) {
        u32 val = *eerd_ptr;
        if(val & EERD_DONE) { // check for done bit
            EEPROM_EXISTS = $u8 0x1;
        }
    }

    if(EEPROM_EXISTS) {
        println("e1000_eeprom_check() : EEPROM found");
    } else {
        println("e1000_eeprom_check() : EEPROM not found");
    }

    return;
}

u16 e1000_eeprom_read(u8 addr) {
    if(!EEPROM_EXISTS) {
        return $u16 0x0;
    }

    u16 data = $u16 0x0;
    u32* eerd_ptr = $u32* (MMIO_BASE + $u64 REG_EERD + $u64 EERD_START);
    u32 command = (($u32 addr) << $u32 8) | $u32 0x1; // set address bits and start bit
    *eerd_ptr = command;

    u32 temp = $u32 0x0;
    while(0x1) {
        temp = *eerd_ptr;
        if(temp & EERD_DONE) {
            break;
        }
    }

    data = $u16 ((temp & EERD_DATA) >> $u32 16);
    return data;
}

void e1000_init_rx() {
    println("e1000_init_rx() : beginning RX initialization");
    
    // allocate ring memory
    void* ring_base = palloc();
    memset(ring_base, 0, PAGE_SIZE);
    RDESC_RING = $E1000_RDESC* ring_base;

    // fill ring with buffer addresses
    for(u64 i = 0x0; i < E1000_NUM_RDESC; i++) {
        void* buffer_page = palloc();
        memset(buffer_page, 0, PAGE_SIZE);

        RDESC_RING[i].addr = $u64 buffer_page;
        RDESC_RING[i].status = $u8 0;
    }

    // write ring address
    u32* rdbal_ptr = $u32* (MMIO_BASE + $u64 REG_RDBAL);
    *rdbal_ptr = $u32 ($u64 RDESC_RING);
    u32* rdbah_ptr = $u32* (MMIO_BASE + $u64 REG_RDBAH);
    *rdbah_ptr = $u32 (($u64 RDESC_RING) >> $u64 32);

    // write ring length
    u32* rdlen_ptr = $u32* (MMIO_BASE + $u64 REG_RDLEN);
    *rdlen_ptr = $u32 (sizeof(E1000_RDESC) * E1000_NUM_RDESC);

    // write head and tail
    u32* rdh_ptr = $u32* (MMIO_BASE + $u64 REG_RDH);
    *rdh_ptr = RDH_RDH & $u32 0;
    u32* rdt_ptr = $u32* (MMIO_BASE + $u64 REG_RDT);
    *rdt_ptr = RDT_RDT & $u32 (E1000_NUM_RDESC - 0x1);

    // enable receiver
    u32* rctl_ptr = $u32* (MMIO_BASE + $u64 REG_RCTL);
    u32 rctl = (RCTL_EN | RCTL_MPE | RCTL_BAM | RCTL_SECRC);
    rctl &= ~(RCTL_BSIZE | RCTL_BSEX);
    *rctl_ptr = rctl;

    println("e1000_init_rx() : finished RX initialization");
}

void e1000_init_tx() {
    println("e1000_init_tx() : beginning TX initialization");

    // allocate ring memory
    void* ring_base = palloc();
    memset(ring_base, 0, PAGE_SIZE);
    TDESC_RING = $E1000_TDESC* ring_base;

    // fill ring with buffer addresses
    for(u64 i = 0x0; i < E1000_NUM_TX_DESC; i++) {
        void* buffer_page = palloc();
        memset(buffer_page, 0, PAGE_SIZE);

        TDESC_RING[i].addr = $u64 buffer_page;
        TDESC_RING[i].cmd = $u8 0;
        TDESC_RING[i].status = $u8 1;
    }

    // write ring address
    u32* tdbal_ptr = $u32* (MMIO_BASE + $u64 REG_TDBAL);
    *tdbal_ptr = $u32 ($u64 TDESC_RING);
    u32* tdbah_ptr = $u32* (MMIO_BASE + $u64 REG_TDBAH);
    *tdbah_ptr = $u32 (($u64 TDESC_RING) >> $u64 32);

    // write ring length
    u32* tdlen_ptr = $u32* (MMIO_BASE + $u64 REG_TDLEN);
    *tdlen_ptr = $u32 (sizeof(E1000_TDESC) * E1000_NUM_TX_DESC);

    // write head and tail
    u32* tdh_ptr = $u32* (MMIO_BASE + $u64 REG_TDH);
    *tdh_ptr = TDH_TDH & $u32 0;
    u32* tdt_ptr = $u32* (MMIO_BASE + $u64 REG_TDT);
    *tdt_ptr = TDT_TDT & $u32 0;

    // enable transmitter
    u32* tctl_ptr = $u32* (MMIO_BASE + $u64 REG_TCTL);
    u32 tctl = (TCTL_EN | TCTL_PSP);
    *tctl_ptr = tctl;

    println("e1000_init_tx() : finished TX initialization");
}

// hardware moves the head and software writes to tail
// hardware will act when head != tail, otherwise it sleeps
void e1000_send(void* data, u16 len) {
    // get tail index from hardware
    u32* tdt_ptr = $u32* (MMIO_BASE + $u64 REG_TDT);
    u32 tx_idx = *tdt_ptr & TDT_TDT;

    // fill descriptor
    memcpy($void* TDESC_RING[tx_idx].addr, data, $u64 len);
    TDESC_RING[tx_idx].length = len;

    // set command bits
    TDESC_RING[tx_idx].cmd = (TDESC_CMD_EOP | TDESC_CMD_IFCS);

    // clear status
    TDESC_RING[tx_idx].status = $u8 0;

    // move the tail
    u32 next_idx = (tx_idx + $u32 1) % $u32 E1000_NUM_TX_DESC;
    *tdt_ptr = next_idx;
}

void e1000_recieve_poll() {
    u32* rdt_ptr = $u32* (MMIO_BASE + $u64 REG_RDT);
    
    i32 sent = 0;
    u64 init_time = hpet_get_ns();
    u64 curr_time = 0x0;

    while(1) {
        u8 status = RDESC_RING[CURR_RDESC].status;

        if((status & RDESC_STATUS_DD) != $u8 0) {
            u16 len = RDESC_RING[CURR_RDESC].length;
            u8* buffer = $u8* RDESC_RING[CURR_RDESC].addr;

            println("e1000_recieve_poll() : packet recieved");
            ethernet_handle_packet(buffer, len);

            RDESC_RING[CURR_RDESC].status = $u8 0;
            *rdt_ptr = $u32 CURR_RDESC;
            CURR_RDESC = (CURR_RDESC + $u16 1) % $u16 E1000_NUM_RDESC;
        }

        curr_time = hpet_get_ns();
        if(CURRENT_INTERFACE->ip_address != $u32 0 && !sent && ((curr_time - init_time) > 0xB2D05E00)) {
            // u32 test_ip = $u32 (1 << 24 | 1 << 16 | 1 << 8 | 1 << 0);
            u32 test_ip = CURRENT_INTERFACE->gateway_ip;
            icmp_send_request(test_ip, $u16 1, $u16 1);
            init_time = curr_time;
            // sent = 1;
        }
    }
}

void e1000_handle_receive() {
    println("e1000_handle_receive() : handling packet receive");
    u32* rdt_ptr = $u32* (MMIO_BASE + $u64 REG_RDT);

    while((RDESC_RING[CURR_RDESC].status & RDESC_STATUS_DD) != $u8 0) {
        println("e1000_handle_receive() : spinning");

        u16 len = RDESC_RING[CURR_RDESC].length;
        u8* buffer = $u8* RDESC_RING[CURR_RDESC].addr;

        ethernet_handle_packet(buffer, len);

        RDESC_RING[CURR_RDESC].status = $u8 0;
        *rdt_ptr = $u32 CURR_RDESC;
        CURR_RDESC = (CURR_RDESC + $u16 1) % $u16 E1000_NUM_RDESC;
    }
}

void e1000_interrupt_handler(trapframe* tf) {
    u32* icr_ptr = $u32* (MMIO_BASE + $u64 REG_ICR);
    u32 status = *icr_ptr;

    if(status & IMS_LSC) {
        println("e1000_interrupt_handler() : link status changed");
    }

    if(status & IMS_RXT0) {
        e1000_handle_receive();
        println("e1000_interrupt_handler() : packet recieved");
    }

    scheduler(tf);
}