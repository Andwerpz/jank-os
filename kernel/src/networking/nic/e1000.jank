// specs in docs/e1000.pdf
// online ver: https://courses.cs.washington.edu/courses/cse451/16au/readings/e1000.pdf

[__GLOBAL_FIRST__] u16 INTEL_VEND = $u16 0x8086;
[__GLOBAL_FIRST__] u16 E1000_DEV = $u16 0x100E;

[__GLOBAL_FIRST__] E1000* e1000; 

struct E1000 {
    u8 eeprom_exists;
    u64 mmio_base;
    u8 irq;
    u64 intno; 
    u64 num_rdesc;
    E1000_RDESC* rdesc_ring;
    u16 curr_rdesc;   
    u64 num_tdesc;
    E1000_TDESC* TDESC_RING;
    u16 curr_tdesc;
}

// registers
// table 13-2 contains the list of registers
[__GLOBAL_FIRST__] u32 E1000_REG_CTRL = $u32 0x00;            // Device Control
[__GLOBAL_FIRST__] u32 E1000_REG_EERD = $u32 0x14;            // EEPROM/Flash Control/Data
[__GLOBAL_FIRST__] u32 E1000_REG_FCAL = $u32 0x28;            // Flow Control Address Low 
[__GLOBAL_FIRST__] u32 E1000_REG_FCAH = $u32 0x2C;            // Flow Control Address High
[__GLOBAL_FIRST__] u32 E1000_REG_FCT = $u32 0x30;             // Flow Control Type
[__GLOBAL_FIRST__] u32 E1000_REG_FCTTV = $u32 0x170;          // Flow Control Transmit Timer Value
[__GLOBAL_FIRST__] u32 E1000_REG_ICR = $u32 0xC0;             // Interrupt Cause Read
[__GLOBAL_FIRST__] u32 E1000_REG_IMS = $u32 0xD0;             // Interrupt Mask Set/Read
[__GLOBAL_FIRST__] u32 E1000_REG_IMC = $u32 0xD8;             // Interrupt Mask Clear

[__GLOBAL_FIRST__] u32 E1000_REG_RCTL = $u32 0x100;           // Receive Control
[__GLOBAL_FIRST__] u32 E1000_REG_RDBAL = $u32 0x2800;         // Receive Descriptor Base Low
[__GLOBAL_FIRST__] u32 E1000_REG_RDBAH = $u32 0x2804;         // Receive Descriptor Base High
[__GLOBAL_FIRST__] u32 E1000_REG_RDLEN = $u32 0x2808;         // Receive Descriptor Length
[__GLOBAL_FIRST__] u32 E1000_REG_RDH = $u32 0x2810;           // Receive Descriptor Head
[__GLOBAL_FIRST__] u32 E1000_REG_RDT = $u32 0x2818;           // Receive Descriptor Tail

[__GLOBAL_FIRST__] u32 E1000_REG_TCTL = $u32 0x400;           // Transmit Control 
[__GLOBAL_FIRST__] u32 E1000_REG_TDBAL = $u32 0x3800;         // Transmit Descriptor Base Low 
[__GLOBAL_FIRST__] u32 E1000_REG_TDBAH = $u32 0x3804;         // Transmit Descriptor Base Low 
[__GLOBAL_FIRST__] u32 E1000_REG_TDLEN = $u32 0x3808;         // Transmit Descriptor Base Low 
[__GLOBAL_FIRST__] u32 E1000_REG_TDH = $u32 0x3810;           // Transmit Descriptor Base Low 
[__GLOBAL_FIRST__] u32 E1000_REG_TDT = $u32 0x3818;           // Transmit Descriptor Base Low 

[__GLOBAL_FIRST__] u32 E1000_REG_MTA = $u32 0x5200;           // Multicast Table Array

// CTRL bits
[__GLOBAL_FIRST__] u32 E1000_CTRL_LRST = $u32 0x8;            // Link Reset, 0b = Normal; 1b = Link Reset
[__GLOBAL_FIRST__] u32 E1000_CTRL_ASDE = $u32 0x20;           // Auto-Speed Detection Enable, needs to be set together with SLU
[__GLOBAL_FIRST__] u32 E1000_CTRL_SLU = $u32 0x40;            // Set Link Up
[__GLOBAL_FIRST__] u32 E1000_CTRL_VME = $u32 0x40000000;      // VLAN Mode Enable
[__GLOBAL_FIRST__] u32 E1000_CTRL_PHY_RST = $u32 0x80000000;  // PHY Reset, 0b = Normal. 1b = Assert hardware reset to the internal PHY

// EERD bits
[__GLOBAL_FIRST__] u32 E1000_EERD_START = $u32 0x0;           // Start Read, write 1b to read word in address field and write to data field. self clearing
[__GLOBAL_FIRST__] u32 E1000_EERD_DONE = $u32 0x10;           // Read Done, set to 1b when done, set to 0b when in progess. software writes ignored.
[__GLOBAL_FIRST__] u32 E1000_EERD_DATA = $u32 0xFFFF0000;     // Read Data, Data returned from EEPROM read.

// ICR, IMS, IMC bits
[__GLOBAL_FIRST__] u32 E1000_IMS_LSC = $u32 0x2;              // Link Status Change, This bit is set each time the link status changes (either from up to down, or from down to up)
[__GLOBAL_FIRST__] u32 E1000_IMS_RXT0 = $u32 0x80;            // Receiver Timer Interrupt, Set when the receiver timer expires.

// RCTL bits
[__GLOBAL_FIRST__] u32 E1000_RCTL_EN = $u32 0x2;              // Receiver Enable, The receiver is enabled when this bit is 1b. Writing this bit to 0b stops reception after receipt of any in-progress packets
[__GLOBAL_FIRST__] u32 E1000_RCTL_MPE = $u32 0x10;            // Multicast Promiscuous Enabled, 0b = Disabled. 1b = Enabled.
[__GLOBAL_FIRST__] u32 E1000_RCTL_BAM = $u32 0x8000;          // Broadcast Accept Mode. 0 = ignore broadcast; 1 = accept broadcast packets
[__GLOBAL_FIRST__] u32 E1000_RCTL_BSIZE = $u32 0x30000;       // Receive Buffer Size
[__GLOBAL_FIRST__] u32 E1000_RCTL_BSEX = $u32 0x2000000;      // Buffer Size Extension, When set to one, the original BSIZE values are multiplied by 16
[__GLOBAL_FIRST__] u32 E1000_RCTL_SECRC = $u32 0x4000000;     // Strip Ethernet CRC from incoming packet, 0b = Do not strip CRC field. 1b = Strip CRC field.

// RDBAL bits
[__GLOBAL_FIRST__] u32 E1000_RDBAL_RDBAL = $u32 0xFFFFFFF0;   // Receive Descriptor Base Address Low.

// RDH bits
[__GLOBAL_FIRST__] u32 E1000_RDH_RDH = $u32 0xFFFF;           // Receive Descriptor Head.

// RDT bits
[__GLOBAL_FIRST__] u32 E1000_RDT_RDT = $u32 0xFFFF;           // Receive Descriptor Tail.

// TCTL bits
[__GLOBAL_FIRST__] u32 E1000_TCTL_EN = $u32 0x2;              // Transmit Enable, The transmitter is enabled when this bit is set to 1b. Writing 0b to this bit stops transmission after any in progress packets are sent.
[__GLOBAL_FIRST__] u32 E1000_TCTL_PSP = $u32 0x8;             // Pad Short Packets, 0b = Do not pad. 1b = Pad short packets.

// TDBAL bits
[__GLOBAL_FIRST__] u32 E1000_TDBAL_TDBAL = $u32 0xFFFFFFF0;   // Transmit Descriptor Base Address Low [31:4].

// TDH bits
[__GLOBAL_FIRST__] u32 E1000_TDH_TDH = $u32 0xFFFF;           // Transmit Descriptor Head.

// TDT bits
[__GLOBAL_FIRST__] u32 E1000_TDT_TDT = $u32 0xFFFF;           // Transmit Descriptor Tail.

// receive descriptor (3.2.3)
struct E1000_RDESC {
    u64 addr;
    u16 length;
    u16 checksum;
    u8  status;
    u8  errors;
    u16 special;
}

[__GLOBAL_FIRST__] u8 E1000_RDESC_STATUS_DD = $u8 0x1;        // Descriptor Done, Indicates whether hardware is done with the descriptor. When set along with EOP, the received packet is complete in main memory.

// transmit descriptor (3.3.3)
struct E1000_TDESC {
    u64 addr;
    u16 length;
    u8  cso;
    u8  cmd;
    u8  status;
    u8  css;
    u16 special;
}

[__GLOBAL_FIRST__] u8 E1000_TDESC_CMD_EOP = $u8 0x1;          // End Of Packet, When set, indicates the last descriptor making up the packet. One or many descriptors can be used to form a packet.
[__GLOBAL_FIRST__] u8 E1000_TDESC_CMD_IFCS = $u8 0x2;         // Insert FCS, Controls the insertion of the FCS/CRC field in normal Ethernet packets. IFCS is valid only when EOP is set.

void e1000_init(u64 addr) {
    println("e1000_init() : Beginning NIC initialization");

    e1000 = $E1000* malloc(sizeof(E1000));
    e1000->eeprom_exists = $u8 0;
    e1000->mmio_base = 0x0;
    e1000->irq = $u8 0;
    e1000->intno = 0x1000;
    e1000->num_rdesc = $u64 32;
    e1000->curr_rdesc = $u16 0;
    e1000->num_tdesc = $u64 32;
    e1000->curr_tdesc = $u16 0;

    NetInterface* nic = $NetInterface* malloc(sizeof(NetInterface));
    memset($void* nic, 0, sizeof(NetInterface));
    nic->name = "eth0"; // temp name for now

    e1000_pci_setup(addr);
    e1000_get_mac_address(nic->mac_address);
    e1000_startup();
    e1000_enable_interrupts();
    e1000_init_rx();
    e1000_init_tx();

    nic->ip_address = $u32 0;
    nic->subnet_mask = $u32 0;
    nic->gateway_ip = $u32 0;
    nic->dhcp_server = $u32 0;
    nic->dns_server = $u32 0;

    nic->send = #<e1000_send(u8*, u16)>;

    net_interfaces.push_back(nic);
    CURRENT_INTERFACE = nic;

    println("e1000_init() : Finished NIC initialization");
}

void e1000_pci_setup(u64 addr) {
    println("e1000_pci_setup() : Beginning PCI setup");

    PCIHeader0* pci_hdr = $PCIHeader0* addr;

    u64 BAR0 = $u64 pci_hdr->BAR0;
    u64 BAR1 = $u64 pci_hdr->BAR1;
    
    assert((BAR0 & 0x1) == 0x0, "e1000_pci_setup() : BAR0 is not a memory space");

    u64 mmio_base_addr = 0x0;
    u64 mmio_size = 0x0;

    u64 type = (BAR0 & 0x6) >> 0x1;
    if(type == 0x0) {
        // 32 bit
        println("e1000_pci_setup() : Detected 32-bit memory register base address");
        mmio_base_addr = $u64 (BAR0 & 0xFFFFFFF0);

        // get size
        pci_hdr->BAR0 = $u32 0xFFFFFFFF;
        u32 mask = pci_hdr->BAR0;
        pci_hdr->BAR0 = $u32 BAR0;

        mask = ~(mask & $u32 0xFFFFFFF0);
        mmio_size = $u64 mask + 0x1;
    } else if(type == 0x2) {
        // 64 bit
        println("e1000_pci_setup() : Detected 64-bit memory register base address");
        u64 lower = $u64 (BAR0 & 0xFFFFFFF0);
        u64 upper = BAR1 << $u64 32;
        mmio_base_addr = upper | lower;

        // get size
        pci_hdr->BAR0 = $u32 0xFFFFFFFF;
        u64 mask_lower = $u64 pci_hdr->BAR0;
        pci_hdr->BAR0 = $u32 BAR0;

        pci_hdr->BAR1 = $u32 0xFFFFFFFF;
        u64 mask_upper = $u64 pci_hdr->BAR1;
        pci_hdr->BAR1 = $u32 BAR1;

        u64 mask = (mask_upper << $u64 32) | (mask_lower & 0xFFFFFFF0);
        mmio_size = ~mask + 0x1;
    } else {
        panic("e1000_pci_setup() : Unknown memory register base address space size");
    }

    // identity map
    pagetable_t pt = pt_get_current();
    for(u64 vaddr = mmio_base_addr; vaddr < mmio_base_addr + mmio_size; vaddr += PAGE_SIZE) {
        pt_map_page_if_not_mapped(pt, $void* vaddr, $void* vaddr, PTE_WRITEABLE | PTE_PCD | PTE_PWT);
    }
    e1000->mmio_base = mmio_base_addr;

    // command register modifications
    u16 command = pci_hdr->command;
    command |= $u16 (1 << 1); // Memory Access Enable
    command |= $u16 (1 << 2); // Enable Mastering
    pci_hdr->command = command;

    // read irq line, no safety checks here
    e1000->irq = pci_hdr->interrupt_line;
    print("e1000_pci_setup() : Using IRQ: 0x");
    print_hex(e1000->irq);
    println("");
    IRQ_clear_mask(e1000->irq);

    // convert the irq to int vec
    e1000->intno = IRQ_to_int_vec(e1000->irq);
    INTNO_E1000 = e1000->intno;

    println("e1000_pci_setup() : Finished PCI setup");
}

// will write 6 bytes to mac
void e1000_get_mac_address(u8[6]& mac) {
    println("e1000_get_mac_address() : Begin getting NIC MAC address");

    // check if eeprom exists
    e1000_eeprom_check();
    if(!e1000->eeprom_exists) {
        panic("e1000_get_mac_address() : No EEPROM detected");
    }

    // read EEPROM for MAC address
    u16 temp = $u16 0x0;
    i32 mac_idx = 0;
    for(i32 i = 0; i < 3; i++) {
        temp = e1000_eeprom_read($u8 i);
        mac[mac_idx++] = $u8 (temp & $u16 0xFF);
        mac[mac_idx++] = $u8 (temp >> $u16 8);
    }

    print("e1000_get_mac_address() : NIC MAC address is ");
    print("[");
    print_mac_addr(mac);
    print("]");
    println("");

    println("e1000_get_mac_address() : Finished getting NIC MAC address");
}

void e1000_startup() {
    println("e1000_startup() : Beginning general intialization");

    // general configuration (14.3 in specs)

    // disable flow control
    u32* fcal_ptr = $u32* (e1000->mmio_base + $u64 E1000_REG_FCAL);
    *fcal_ptr = $u32 0x0;
    u32* fcah_ptr = $u32* (e1000->mmio_base + $u64 E1000_REG_FCAH);
    *fcah_ptr = $u32 0x0;
    u32* fct_ptr = $u32* (e1000->mmio_base + $u64 E1000_REG_FCT);
    *fct_ptr = $u32 0x0;
    u32* fcttv_ptr = $u32* (e1000->mmio_base + $u64 E1000_REG_FCTTV);
    *fcttv_ptr = $u32 0x0;

    // enable auto speed detection and set link up
    // disable vlans
    // clear link reset
    // clear phy reset
    u32* ctrl_ptr = $u32* (e1000->mmio_base + $u64 E1000_REG_CTRL);
    u32 ctrl = *ctrl_ptr;
    ctrl |= E1000_CTRL_ASDE;
    ctrl |= E1000_CTRL_SLU;
    ctrl &= ~E1000_CTRL_VME;
    ctrl &= ~E1000_CTRL_LRST;
    ctrl &= ~E1000_CTRL_PHY_RST;
    *ctrl_ptr = ctrl;

    // zero out Multicast Table Array
    for(i32 i = 0; i < 128; i++) {
        u32* mta_ptr = $u32* (e1000->mmio_base + $u64 E1000_REG_MTA + $u64 (i * 4));
        *mta_ptr = $u32 0;
    }

    println("e1000_startup() : Finished general intialization");
}

void e1000_enable_interrupts() {
    println("e1000_enable_interrupts() : Beginning enabling interrupts");

    // register the interrupt vector
    idt_set_entry($u64 e1000->intno, $u64 @network_packet_receive_interrupt_entry_stub, $u16 0x08, $u8 0x0, IST_ATTR_PRESENT | IST_ATTR_DPL_KERNEL | IST_ATTR_INTERRUPT_GATE, $IDTEntry* IDT_PAGE);

    // register the pic bit
    IRQ_clear_mask(e1000->irq);

    // disable all interrupts
    u32* imc_ptr = $u32* (e1000->mmio_base + $u64 E1000_REG_IMC);
    *imc_ptr = $u32 0xFFFF;

    // clear pending interrupts
    u32* icr_ptr = $u32* (e1000->mmio_base + $u64 E1000_REG_ICR);
    u32 dummy = *icr_ptr;

    // configure Interrupt Mask
    u32* ims_ptr = $u32* (e1000->mmio_base + $u64 E1000_REG_IMS);
    u32 ims = E1000_IMS_LSC | E1000_IMS_RXT0;
    *ims_ptr = ims;

    println("e1000_enable_interrupts() : Finished enabling interrupts");
}

void e1000_eeprom_check() {
    println("e1000_eeprom_check() : Beginning checking NIC EEPROM");
    u32* eerd_ptr = $u32* (e1000->mmio_base + $u64 E1000_REG_EERD + $u64 E1000_EERD_START);
    *eerd_ptr = $u32 0x1; // set start bit
    for(i32 i = 0; i < 10000; i++) {
        u32 val = *eerd_ptr;
        if(val & E1000_EERD_DONE) { // check for done bit
            e1000->eeprom_exists = $u8 0x1;
        }
    }

    if(e1000->eeprom_exists) {
        println("e1000_eeprom_check() : EEPROM found");
    } else {
        println("e1000_eeprom_check() : EEPROM not found");
    }

    println("e1000_eeprom_check() : Finished checking NIC EEPROM");
}

u16 e1000_eeprom_read(u8 addr) {
    if(!e1000->eeprom_exists) {
        return $u16 0x0;
    }

    u16 data = $u16 0x0;
    u32* eerd_ptr = $u32* (e1000->mmio_base + $u64 E1000_REG_EERD + $u64 E1000_EERD_START);
    u32 command = (($u32 addr) << $u32 8) | $u32 0x1; // set address bits and start bit
    *eerd_ptr = command;

    u32 temp = $u32 0x0;
    while(0x1) {
        temp = *eerd_ptr;
        if(temp & E1000_EERD_DONE) {
            break;
        }
    }

    data = $u16 ((temp & E1000_EERD_DATA) >> $u32 16);
    return data;
}

void e1000_init_rx() {
    println("e1000_init_rx() : Beginning RX initialization");
    
    // allocate ring memory
    void* ring_base = palloc();
    memset(ring_base, 0, PAGE_SIZE);
    e1000->rdesc_ring = $E1000_RDESC* ring_base;

    // fill ring with buffer addresses
    for(u64 i = 0x0; i < e1000->num_rdesc; i++) {
        void* buffer_page = palloc();
        memset(buffer_page, 0, PAGE_SIZE);

        e1000->rdesc_ring[i].addr = $u64 buffer_page;
        e1000->rdesc_ring[i].status = $u8 0;
    }

    // write ring address
    u32* rdbal_ptr = $u32* (e1000->mmio_base + $u64 E1000_REG_RDBAL);
    *rdbal_ptr = $u32 ($u64 e1000->rdesc_ring);
    u32* rdbah_ptr = $u32* (e1000->mmio_base + $u64 E1000_REG_RDBAH);
    *rdbah_ptr = $u32 (($u64 e1000->rdesc_ring) >> $u64 32);

    // write ring length
    u32* rdlen_ptr = $u32* (e1000->mmio_base + $u64 E1000_REG_RDLEN);
    *rdlen_ptr = $u32 (sizeof(E1000_RDESC) * e1000->num_rdesc);

    // write head and tail
    u32* rdh_ptr = $u32* (e1000->mmio_base + $u64 E1000_REG_RDH);
    *rdh_ptr = E1000_RDH_RDH & $u32 0;
    u32* rdt_ptr = $u32* (e1000->mmio_base + $u64 E1000_REG_RDT);
    *rdt_ptr = E1000_RDT_RDT & $u32 (e1000->num_rdesc - 0x1);

    // enable receiver
    u32* rctl_ptr = $u32* (e1000->mmio_base + $u64 E1000_REG_RCTL);
    u32 rctl = (E1000_RCTL_EN | E1000_RCTL_MPE | E1000_RCTL_BAM | E1000_RCTL_SECRC);
    rctl &= ~(E1000_RCTL_BSIZE | E1000_RCTL_BSEX);
    *rctl_ptr = rctl;

    println("e1000_init_rx() : Finished RX initialization");
}

void e1000_init_tx() {
    println("e1000_init_tx() : Beginning TX initialization");

    // allocate ring memory
    void* ring_base = palloc();
    memset(ring_base, 0, PAGE_SIZE);
    e1000->TDESC_RING = $E1000_TDESC* ring_base;

    // fill ring with buffer addresses
    for(u64 i = 0x0; i < e1000->num_tdesc; i++) {
        void* buffer_page = palloc();
        memset(buffer_page, 0, PAGE_SIZE);

        e1000->TDESC_RING[i].addr = $u64 buffer_page;
        e1000->TDESC_RING[i].cmd = $u8 0;
        e1000->TDESC_RING[i].status = $u8 1;
    }

    // write ring address
    u32* tdbal_ptr = $u32* (e1000->mmio_base + $u64 E1000_REG_TDBAL);
    *tdbal_ptr = $u32 ($u64 e1000->TDESC_RING);
    u32* tdbah_ptr = $u32* (e1000->mmio_base + $u64 E1000_REG_TDBAH);
    *tdbah_ptr = $u32 (($u64 e1000->TDESC_RING) >> $u64 32);

    // write ring length
    u32* tdlen_ptr = $u32* (e1000->mmio_base + $u64 E1000_REG_TDLEN);
    *tdlen_ptr = $u32 (sizeof(E1000_TDESC) * e1000->num_tdesc);

    // write head and tail
    u32* tdh_ptr = $u32* (e1000->mmio_base + $u64 E1000_REG_TDH);
    *tdh_ptr = E1000_TDH_TDH & $u32 0;
    u32* tdt_ptr = $u32* (e1000->mmio_base + $u64 E1000_REG_TDT);
    *tdt_ptr = E1000_TDT_TDT & $u32 0;

    // enable transmitter
    u32* tctl_ptr = $u32* (e1000->mmio_base + $u64 E1000_REG_TCTL);
    u32 tctl = (E1000_TCTL_EN | E1000_TCTL_PSP);
    *tctl_ptr = tctl;

    println("e1000_init_tx() : Finished TX initialization");
}

// hardware moves the head and software writes to tail
// hardware will act when head != tail, otherwise it sleeps
void e1000_send(u8* data, u16 len) {
    println("e1000_send() : Beginning send operation");

    // get tail index from hardware
    u32* tdt_ptr = $u32* (e1000->mmio_base + $u64 E1000_REG_TDT);
    u32 tx_idx = *tdt_ptr & E1000_TDT_TDT;

    // fill descriptor
    memcpy($void* e1000->TDESC_RING[tx_idx].addr, $void* data, $u64 len);
    e1000->TDESC_RING[tx_idx].length = len;

    // set command bits
    e1000->TDESC_RING[tx_idx].cmd = (E1000_TDESC_CMD_EOP | E1000_TDESC_CMD_IFCS);

    // clear status
    e1000->TDESC_RING[tx_idx].status = $u8 0;

    // move the tail
    u32 next_idx = (tx_idx + $u32 1) % $u32 e1000->num_tdesc;
    *tdt_ptr = next_idx;

    println("e1000_send() : Beginning send operation");
}

void e1000_receive_poll() {
    println("e1000_receive_poll() : Polling receive");

    u32* rdt_ptr = $u32* (e1000->mmio_base + $u64 E1000_REG_RDT);
    
    while(1) {
        u8 status = e1000->rdesc_ring[e1000->curr_rdesc].status;

        if((status & E1000_RDESC_STATUS_DD) != $u8 0) {
            u16 len = e1000->rdesc_ring[e1000->curr_rdesc].length;
            u8* buffer = $u8* e1000->rdesc_ring[e1000->curr_rdesc].addr;

            println("e1000_receive_poll() : Frame received");
            ethernet_handle_frame(buffer, len);

            e1000->rdesc_ring[e1000->curr_rdesc].status = $u8 0;
            *rdt_ptr = $u32 e1000->curr_rdesc;
            e1000->curr_rdesc = (e1000->curr_rdesc + $u16 1) % $u16 e1000->num_rdesc;
        }
    }
}

void e1000_handle_receive() {
    println("e1000_handle_receive() : Handling frame receive");
    u32* rdt_ptr = $u32* (e1000->mmio_base + $u64 E1000_REG_RDT);

    while((e1000->rdesc_ring[e1000->curr_rdesc].status & E1000_RDESC_STATUS_DD) != $u8 0) {

        u16 len = e1000->rdesc_ring[e1000->curr_rdesc].length;
        u8* buffer = $u8* e1000->rdesc_ring[e1000->curr_rdesc].addr;

        ethernet_handle_frame(buffer, len);

        e1000->rdesc_ring[e1000->curr_rdesc].status = $u8 0;
        *rdt_ptr = $u32 e1000->curr_rdesc;
        e1000->curr_rdesc = (e1000->curr_rdesc + $u16 1) % $u16 e1000->num_rdesc;
    }
}

void e1000_interrupt_handler(trapframe* tf) {
    u32* icr_ptr = $u32* (e1000->mmio_base + $u64 E1000_REG_ICR);
    u32 status = *icr_ptr;

    if(status & E1000_IMS_LSC) {
        println("e1000_interrupt_handler() : Link status changed");
    }

    if(status & E1000_IMS_RXT0) {
        println("e1000_interrupt_handler() : Frame received");
        e1000_handle_receive();
    }

    scheduler(tf);
}