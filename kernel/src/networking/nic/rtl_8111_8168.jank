[__GLOBAL_FIRST__] u16 REALTEK_VEND = $u16 0x10EC;
[__GLOBAL_FIRST__] u16 RTL8168_DEV = $u16 0x8168;

[__GLOBAL_FIRST__] RTL8111* rtl8111;

struct RTL8111 {
    u64 mmio_base;

    u64 num_rdesc;
    RTL8111_RDESC* rdesc_ring;

    u64 num_tdesc;
    RTL8111_TDESC* tdesc_ring;
}

[__GLOBAL_FIRST__] u64 RTL8111_MAC_PHYAR = 0x60;        // PHY Access
[__GLOBAL_FIRST__] u8 RTL8111_PHY_BMCR = $u8 0x0;          // Basic mode control register

[__GLOBAL_FIRST__] u64 RTL8111_MAC_CR = 0x37;          // Command Register
[__GLOBAL_FIRST__] u8 RTL8111_MAC_CR_RST = $u8 (1 << 4); // Reset: Set this bit to 1 to force the RTL8111B/RTL8168B into a software reset state
[__GLOBAL_FIRST__] u8 RTL8111_MAC_CR_RE = $u8 (1 << 3); // Receiver Enable
[__GLOBAL_FIRST__] u8 RTL8111_MAC_CR_TE = $u8 (1 << 2); // Transmitter Enable

[__GLOBAL_FIRST__] u64 RTL8111_MAC_RDSAR = 0xE4;          // Receive Descriptor Start Address Register (256-byte alignment)
[__GLOBAL_FIRST__] u64 RTL8111_MAC_RCR = 0x44;          // Receive (Rx) Configuration Register
[__GLOBAL_FIRST__] u32 RTL8111_MAC_RCR_AB = $u32 (1 << 3);          // Accept Broadcast Packets
[__GLOBAL_FIRST__] u32 RTL8111_MAC_RCR_AM = $u32 (1 << 2);          // Accept Multicast Packets
[__GLOBAL_FIRST__] u32 RTL8111_MAC_RCR_APM = $u32 (1 << 1);          // Accept Physical Match Packets

[__GLOBAL_FIRST__] u64 RTL8111_MAC_TNPDS = 0x20; // Transmit Normal Priority Descriptors: Start address (64-bit). (256-byte alignment)
[__GLOBAL_FIRST__] u64 RTL8111_MAC_TCR = 0x40; // Transmit (Tx) Configuration Register

[__GLOBAL_FIRST__] u32 RTL8111_RDESC_OPT1_OWN = $u32 (1 << 31); // When set, indicates that the descriptor is owned by the NIC, and is ready to receive a packet.
[__GLOBAL_FIRST__] u32 RTL8111_RDESC_OPT1_EOR = $u32 (1 << 30); // End of Rx descriptor Ring.

[__GLOBAL_FIRST__] u32 RTL8111_TDESC_OPT1_OWN = $u32 (1 << 31); // When set, this bit indicates that the descriptor is owned by the NIC, and the data relative to this descriptor is ready to be transmitted.
[__GLOBAL_FIRST__] u32 RTL8111_TDESC_OPT1_EOR = $u32 (1 << 30); // End of Rx descriptor Ring.

[__GLOBAL_FIRST__] u64 RTL8111_MAC_IDR0 = 0x0;          // ID Register 0
[__GLOBAL_FIRST__] u64 RTL8111_MAC_IDR1 = 0x1;          // ID Register 1
[__GLOBAL_FIRST__] u64 RTL8111_MAC_IDR2 = 0x2;          // ID Register 2
[__GLOBAL_FIRST__] u64 RTL8111_MAC_IDR3 = 0x3;          // ID Register 3
[__GLOBAL_FIRST__] u64 RTL8111_MAC_IDR4 = 0x4;          // ID Register 4
[__GLOBAL_FIRST__] u64 RTL8111_MAC_IDR5 = 0x5;          // ID Register 5

struct RTL8111_RDESC {
    u32 opts1;
    u32 opts2;
    u32 addr_lo;
    u32 addr_hi;
}

struct RTL8111_TDESC {
    u32 opts1;
    u32 opts2;
    u32 addr_lo;
    u32 addr_hi;
}

void rtl8111_init(u64 addr) {
    println("rtl8111_init() : Beginning NIC initialization");

    rtl8111 = $RTL8111* malloc(sizeof(RTL8111));
    rtl8111->mmio_base = 0x0;
    rtl8111->num_rdesc = $u64 32;
    rtl8111->num_tdesc = $u64 32;

    NetInterface* nic = $NetInterface* malloc(sizeof(NetInterface));
    memset($void* nic, 0, sizeof(NetInterface));
    nic->name = "eth0"; // temp name for now

    rtl8111_pci_setup(addr);
    rtl8111_startup();
    rtl8111_get_mac_address(nic->mac_address);
    rtl8111_init_rx();
    rtl8111_init_tx();
}

void rtl8111_init_tx() {
    println("rtl8111_init_tx() : Beginning TX initialization");

    // Allocate ring memory
    void* ring_base = palloc();
    memset(ring_base, 0, PAGE_SIZE);
    rtl8111->tdesc_ring = $RTL8111_TDESC* ring_base;

    // Fill ring with buffer addresses
    for(u64 i = 0x0; i < rtl8111->num_tdesc; i++) {
        void* buffer_page = palloc();
        memset(buffer_page, 0, PAGE_SIZE);
        
        u32 opts1 = $u32 0;
        opts1 |= $u32 (0x1FF8 & PAGE_SIZE); // Buffer size, 0x1FF8 is the max. should mult of 8. bits 0-2 and 14 should be 0 
        
        rtl8111->tdesc_ring[i].opts1 = opts1;
        rtl8111->tdesc_ring[i].opts2 = $u32 0;
        rtl8111->tdesc_ring[i].addr_lo = $u32 $u64 buffer_page;
        rtl8111->tdesc_ring[i].addr_hi = $u32 ($u64 buffer_page >> $u64 32);
    }
    
    // Set EOR
    rtl8111->tdesc_ring[rtl8111->num_tdesc - 0x1].opts1 |= RTL8111_TDESC_OPT1_EOR;

    // Write ring address
    u64* tnpds = $u64* (rtl8111->mmio_base + RTL8111_MAC_TNPDS);
    *tnpds = $u64 rtl8111->tdesc_ring; 

    // Configure transmit register
    u32* tcr = $u32* (rtl8111->mmio_base + RTL8111_MAC_TCR);
    *tcr |= $u32 (0b111 << $u64 8); // MXDMA set to unlimited
    *tcr |= $u32 (0b011 << $u64 24); // IDG set?

    println("rtl8111_init_tx() : Finished TX initialization");
}

void rtl8111_init_rx() {
    println("rtl8111_init_rx() : Beginning RX initialization");
    
    // Allocate ring memory
    void* ring_base = palloc();
    memset(ring_base, 0, PAGE_SIZE);
    rtl8111->rdesc_ring = $RTL8111_RDESC* ring_base;

    // Fill ring with buffer addresses
    for(u64 i = 0x0; i < rtl8111->num_rdesc; i++) {
        void* buffer_page = palloc();
        memset(buffer_page, 0, PAGE_SIZE);
        
        u32 opts1 = $u32 0;
        opts1 |= RTL8111_RDESC_OPT1_OWN; // set OWN bit
        opts1 |= $u32 (0x1FF8 & PAGE_SIZE); // Buffer size, 0x1FF8 is the max. should mult of 8. bits 0-2 and 14 should be 0 
        
        rtl8111->rdesc_ring[i].opts1 = opts1;
        rtl8111->rdesc_ring[i].opts2 = $u32 0;
        rtl8111->rdesc_ring[i].addr_lo = $u32 $u64 buffer_page;
        rtl8111->rdesc_ring[i].addr_hi = $u32 ($u64 buffer_page >> $u64 32);
    }

    // Set EOR
    rtl8111->rdesc_ring[rtl8111->num_rdesc - 0x1].opts1 |= RTL8111_RDESC_OPT1_EOR;

    // Write ring address
    u64* rdsar = $u64* (rtl8111->mmio_base + RTL8111_MAC_RDSAR);
    *rdsar = $u64 rtl8111->rdesc_ring; 

    // Configure receive register
    u32* rcr = $u32* (rtl8111->mmio_base + RTL8111_MAC_RCR);
    *rcr |= (RTL8111_MAC_RCR_AB | RTL8111_MAC_RCR_AM | RTL8111_MAC_RCR_APM);

    println("rtl8111_init_rx() : Finished RX initialization");
}

void rtl8111_get_mac_address(u8[6]& mac) {
    println("rtl8111_get_mac_address() : Begin getting NIC MAC address");

    mac[0] = *($u8* (rtl8111->mmio_base + RTL8111_MAC_IDR0));
    mac[1] = *($u8* (rtl8111->mmio_base + RTL8111_MAC_IDR1));
    mac[2] = *($u8* (rtl8111->mmio_base + RTL8111_MAC_IDR2));
    mac[3] = *($u8* (rtl8111->mmio_base + RTL8111_MAC_IDR3));
    mac[4] = *($u8* (rtl8111->mmio_base + RTL8111_MAC_IDR4));
    mac[5] = *($u8* (rtl8111->mmio_base + RTL8111_MAC_IDR5));

    print("rtl8111_get_mac_address() : NIC MAC address is ");
    print("[");
    print_mac_addr(mac);
    print("]");
    println("");

    println("rtl8111_get_mac_address() : Finished getting NIC MAC address");
}

void rtl8111_startup() {
    println("rtl8111_startup() : Beginning general intialization");

    // Initiate software reset
    u8* cr = $u8* (rtl8111->mmio_base + RTL8111_MAC_CR);
    *cr |= RTL8111_MAC_CR_RST;
    while((*cr & RTL8111_MAC_CR_RST) == $u8 1) {
        // spin
    }

    // Enable tx and rx
    *cr |= (RTL8111_MAC_CR_RE | RTL8111_MAC_CR_TE);

    println("rtl8111_startup() : Finished general intialization");
}

void rtl8111_pci_setup(u64 addr) {
    println("rtl8111_pci_setup() : Beginning PCI setup");

    PCIHeader0* pci_hdr = $PCIHeader0* addr;

    u64 BAR2 = $u64 pci_hdr->BAR2;
    u64 BAR3 = $u64 pci_hdr->BAR3;
    
    assert((BAR2 & 0x1) == 0x0, "rtl8111_pci_setup() : BAR2 is not a memory space");
    // in the docs, 5.2, IO is BAR2, and MMIO is BAR2 

    u64 mmio_base_addr = 0x0;
    u64 mmio_size = 0x0;

    u64 type = (BAR2 & 0x6) >> 0x1;
    if(type == 0x0) {
        // 32 bit
        println("rtl8111_pci_setup() : Detected 32-bit memory register base address");
        mmio_base_addr = $u64 (BAR2 & 0xFFFFFFF0);

        // get size
        pci_hdr->BAR2 = $u32 0xFFFFFFFF;
        u32 mask = pci_hdr->BAR2;
        pci_hdr->BAR2 = $u32 BAR2;

        mask = ~(mask & $u32 0xFFFFFFF0);
        mmio_size = $u64 mask + 0x1;
    } else if(type == 0x2) {
        // 64 bit
        println("rtl8111_pci_setup() : Detected 64-bit memory register base address");
        u64 lower = $u64 (BAR2 & 0xFFFFFFF0);
        u64 upper = BAR3 << $u64 32;
        mmio_base_addr = upper | lower;

        // get size
        pci_hdr->BAR2 = $u32 0xFFFFFFFF;
        u64 mask_lower = $u64 pci_hdr->BAR2;
        pci_hdr->BAR2 = $u32 BAR2;

        pci_hdr->BAR3 = $u32 0xFFFFFFFF;
        u64 mask_upper = $u64 pci_hdr->BAR3;
        pci_hdr->BAR3 = $u32 BAR3;

        u64 mask = (mask_upper << $u64 32) | (mask_lower & 0xFFFFFFF0);
        mmio_size = ~mask + 0x1;
    } else {
        panic("rtl8111_pci_setup() : Unknown memory register base address space size");
    }

    // identity map
    pagetable_t pt = pt_get_current();
    for(u64 vaddr = mmio_base_addr; vaddr < mmio_base_addr + mmio_size; vaddr += PAGE_SIZE) {
        pt_map_page_if_not_mapped(pt, $void* vaddr, $void* vaddr, PTE_WRITEABLE | PTE_PCD | PTE_PWT);
    }
    rtl8111->mmio_base = mmio_base_addr;

    // command register modifications
    u16 command = pci_hdr->command;
    command |= $u16 0x2; // Memory Access Enable
    command |= $u16 0x4; // Enable Mastering
    command |= $u16 0x400; // Disable Legacy Interrupts
    pci_hdr->command = command;

    // Enabling MSI-(X?)
    // assert(pci_enable_msix(pci_hdr, $u8 INTNO_RTL8111) == 0, "rtl8111_pci_setup() : Failed to enable MSI-X");
    assert(pci_enable_msi(pci_hdr, $u8 INTNO_RTL8111) == 0, "rtl8111_pci_setup() : Failed to enable MSI");

    println("rtl8111_pci_setup() : Finished PCI setup");
}

void rtl8111_interrupt_handler(trapframe* tf) {
    println("rtl8111_interrupt_handler() : Called");
    scheduler(tf);
}

// // Untested. Didn't use?
// u16 rtl8111_phy_read(u8 reg) {
//     u32* phyar = $u32* (rtl8111->mmio_base + RTL8111_MAC_PHYAR);

//     u32 temp = $u32 0;
//     temp |= ($u32 reg << $u32 16);
//     *phyar = temp;

//     while(phyar & $u32 (1 << 31) == $u32 0) {
//         // spin
//     }

//     return $u16 *phyar;
// }

// // Untested. Didn't use?
// void rtl8111_phy_write(u8 reg, u16 data) {
//     u32* phyar = $u32* (rtl8111->mmio_base + RTL8111_MAC_PHYAR);

//     u32 temp = $u32 0;
//     temp |= $u32 (1 << 31);
//     temp |= ($u32 reg << $u32 16);
//     temp |= $u32 data;
//     *phyar = temp;

//     while(phyar & $u32 (1 << 31) == $u32 1) {
//         // spin
//     }
// }
