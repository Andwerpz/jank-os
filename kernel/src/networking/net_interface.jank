vector<NetInterface*> net_interfaces;
NetInterface* CURRENT_INTERFACE;

struct NetInterface {
    u8* name;

    // L2
    u8[6] mac_address;
    
    // L3
    u32 ip_address;
    u32 subnet_mask;
    u32 gateway_ip;
    u32 dhcp_server;
    u32 dns_server;

    // driver abstractions
    fn<void(void*, u16)> send;
}

i32 mac_address_is_equal(u8[6]& mac1, u8[6]& mac2) {
    if( mac1[0] != mac2[0] || 
        mac1[1] != mac2[1] ||
        mac1[2] != mac2[2] ||
        mac1[3] != mac2[3] ||
        mac1[4] != mac2[4] ||
        mac1[5] != mac2[5] ) return 0;
    return 1;
}

void set_mac(u8[6]& dst, u8[6]& src) {
    memcpy($void* @dst[0], $void* @src[0], $u64 6);
}

void print_mac_addr(u8[6]& mac) {
    for(i32 i = 0; i < 6; i++) {
        print_hex(mac[i]);
        if(i < 5) print(":");
    }
}

// little endian (cpu) input
void print_ipv4_addr(u32 ip) {
    print($u64 ((ip >> $u32 24) & $u32 0xFF)); 
    print(".");
    print($u64 ((ip >> $u32 16) & $u32 0xFF)); 
    print(".");
    print($u64 ((ip >> $u32 8) & $u32 0xFF)); 
    print(".");
    print($u64 ((ip >> $u32 0) & $u32 0xFF)); 
}

void dump_network_interface(NetInterface* net) {
    print("Device Name      ");
    print(net->name);
    println("");

    print("MAC Address:     ");
    print_mac_addr(net->mac_address);
    println("");

    print("ip_address:      ");
    print_ipv4_addr(net->ip_address);
    println("");

    print("subnet_mask:     ");
    print_ipv4_addr(net->subnet_mask);
    println("");

    print("gateway_ip:      ");
    print_ipv4_addr(net->gateway_ip);
    println("");

    print("dhcp_server:     ");
    print_ipv4_addr(net->dhcp_server);
    println("");

    print("dns_server:      ");
    print_ipv4_addr(net->dns_server);
    println("");
}

// group header into 16 bit words, sum them all up excluding the checksum field.
// ones complement sum, then return bitwise NOT of sum.
u16 ones_comp_checksum(void* data, u64 header_size, u64 checksum_index) {
    u16* header = $u16* data;
    
    u32 sum = $u32 0;
    for(u64 i = 0x0; i < header_size / 0x2; i++) {
        if(i != checksum_index) sum += $u32 header[i]; // ignore the checksum field.
    }

    while(sum > $u32 0xFFFF) {
        u32 carry = sum >> $u32 16;
        sum &= $u32 0xFFFF;
        sum += carry; 
    }

    return ~($u16 sum);
}

// returns 1 if ip is in subnet
// returns 0 if ip is not in subnet
i32 is_address_in_subnet(u32 ip, u32 network, u32 mask) {
    return (ip & mask) == (network & mask);
}