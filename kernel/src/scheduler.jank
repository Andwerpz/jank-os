

struct trapframe {
    u64 rax;        // 0
    u64 rbx;        // 8
    u64 rcx;        // 16
    u64 rdx;        // 24
    u64 rsi;        // 32
    u64 rdi;        // 40
    u64 rbp;        // 48
    u64 rsp;        // 56
    u64 r8;         // 64
    u64 r9;         // 72
    u64 r10;        // 80
    u64 r11;        // 88
    u64 r12;        // 96
    u64 r13;        // 104
    u64 r14;        // 112
    u64 r15;        // 120
    u64 rip;        // 128
    u64 rflags;     // 136
    u64 pt;         // 144
    u64 cs;         // 152
    u64 ss;         // 160
}

void print_trapframe(trapframe* tf) {
    sout << "%rax   : " << $void* tf->rax << "\n";
    sout << "%rbx   : " << $void* tf->rbx << "\n";
    sout << "%rcx   : " << $void* tf->rcx << "\n";
    sout << "%rdx   : " << $void* tf->rdx << "\n";
    sout << "%rsi   : " << $void* tf->rsi << "\n";
    sout << "%rdi   : " << $void* tf->rdi << "\n";
    sout << "%rbp   : " << $void* tf->rbp << "\n";
    sout << "%rsp   : " << $void* tf->rsp << "\n";
    sout << "%r8    : " << $void* tf->r8 << "\n";
    sout << "%r9    : " << $void* tf->r9 << "\n";
    sout << "%r10   : " << $void* tf->r10 << "\n";
    sout << "%r11   : " << $void* tf->r11 << "\n";
    sout << "%r12   : " << $void* tf->r12 << "\n";
    sout << "%r13   : " << $void* tf->r13 << "\n";
    sout << "%r14   : " << $void* tf->r14 << "\n";
    sout << "%r15   : " << $void* tf->r15 << "\n";
    sout << "%rip   : " << $void* tf->rip << "\n";
    sout << "rflags : " << $void* tf->rflags << "\n";
    sout << "pt     : " << $void* tf->pt << "\n";
    sout << "cs     : " << $void* tf->cs << "\n";
    sout << "ss     : " << $void* tf->ss << "\n";
}

//we shouldn't store processes anywhere else. 
vector<process*> all_processes;

deque<pid_t> process_queue; 
pid_t current_process = $pid_t 0;

//on success, returns a pointer to a process
//on failure, returns nullptr
process* find_process(pid_t pid) {
    u64 ind = all_processes.size();
    for(u64 i = 0x0; i < all_processes.size(); i++){
        if(all_processes[i]->pid != pid) continue;
        if(ind != all_processes.size()) panic("find_process() : found two processes with same pid");
        ind = i;
    }
    if(ind == all_processes.size()) return $process* nullptr;
    return all_processes[ind];
}

//should only be able to erase zombie processes
//just removes process from scheduler
//if it can't find the process, it panics
void erase_process(pid_t pid) {
    u64 ind = all_processes.size();
    for(u64 i = 0x0; i < all_processes.size(); i++){
        if(all_processes[i]->pid != pid) continue;
        if(ind != all_processes.size()) panic("erase_process() : found two processes with same pid");
        ind = i;
    }
    if(ind == all_processes.size()) panic("erase_process() : could not find process");
    all_processes.erase(ind);
}

export process* get_cur_proc() {
    process* proc = find_process(get_cur_pid());
    passert(proc != nullptr, "get_cur_proc() : failed to find current process");
    return proc;
}

export pid_t get_cur_pid() {
    passert(current_process != $pid_t 0, "get_cur_pid() : current_process is 0??");
    return current_process;
}

//should panic if there's no more processes to choose from
process* schedule_next_process() {
    //go until you see PROCESS_READY
    //should probably add a check to see if there's actually some process that's READY in the queue
    while(1) {
        passert(process_queue.size() != 0x0, "schedule_next_process() : no more processes!!");
        pid_t pid = process_queue.front();
        process_queue.push_back(process_queue.pop_front());

        process* proc = find_process(pid);
        passert(proc != nullptr, "schedule_next_process() : all processes in queue should exist");

        if(proc->status == PROCESS_READY) {
            return proc;
        }
        else if(proc->status == PROCESS_ZOMBIE) {
            //remove zombies from queue
            process_queue.pop_back();
        }
    }

    panic("schedule_next_process() : you shouldn\'t be here D:");
    return $process* nullptr;
}

//once we call this, the initial kernel startup phase has finished
//this function should never return. 
void init_scheduler() {
    sout << "start init scheduler\n";   

    //initialize shell process 

    //point %rsp to top of kernel stack
    asm!("mov BOOTBOOT_STACK_TOP(%rip), %rsp");

    //startup the scheduler
    scheduler();
}

//before jumping here, should make it so that %rsp points to a stack that we can safely
//  put garbage on. you can use the kernel stack for this
//this expects kernel pagetables to be active as we'll want to access kernel heap structures
//this should choose a process to run then jump to that process
//this should not have to cleanup, the saved execution context should make it so that 
//  any stuff leftover is treated as trash memory. 
export void scheduler() {
    //look for next process to run
    process* proc = schedule_next_process();
    passert(proc->status == PROCESS_READY, "scheduler() : should only schedule ready processes");
    current_process = proc->pid;
    u64 proc_trapframe_off = proc->kstack_bottom + KSTACK_TRAPFRAME; 

    //set process state to RUNNING
    proc->status = PROCESS_RUNNING;

    trapframe* tf = $trapframe* proc_trapframe_off;
    // print_trapframe(tf);

    //so syscalls know where this is
    GSData* gs_data = $GSData* GSDATA_PAGE;
    gs_data->cur_proc_kstack_top = proc->kstack_bottom + KSTACK_TOP;

    //need to do different stuff if we're returning to user or kernel mode
    if(tf->cs == 0x23) {
        //returning to user mode
        //swap to user GS
        asm!("swapgs");             

        //load trapframe
        asm!("movq {proc_trapframe_off}, %rax");   //%rax now holds trapframe base

        //iretq information
        asm!("pushq 160(%rax)");    // SS
        asm!("pushq 56(%rax)");     // %rsp
        asm!("pushq 136(%rax)");    // rflags
        asm!("pushq 152(%rax)");    // CS
        asm!("pushq 128(%rax)");    // %rip

        //push registers
        asm!("pushq 0(%rax)");      // %rax
        asm!("pushq 8(%rax)");      // %rbx
        asm!("pushq 16(%rax)");     // %rcx
        asm!("pushq 24(%rax)");     // %rdx
        asm!("pushq 32(%rax)");     // %rsi
        asm!("pushq 40(%rax)");     // %rdi
        asm!("pushq 48(%rax)");     // %rbp
                                    // skip %rsp
        asm!("pushq 64(%rax)");     // %r8
        asm!("pushq 72(%rax)");     // %r9
        asm!("pushq 80(%rax)");     // %r10
        asm!("pushq 88(%rax)");     // %r11
        asm!("pushq 96(%rax)");     // %r12
        asm!("pushq 104(%rax)");    // %r13
        asm!("pushq 112(%rax)");    // %r14
        asm!("pushq 120(%rax)");    // %r15
        asm!("pushq 144(%rax)");    // %cr3

        //pop registers
        asm!("popq %rax");
        asm!("movq %rax, %cr3");

        asm!("popq %r15");
        asm!("popq %r14");
        asm!("popq %r13");
        asm!("popq %r12");
        asm!("popq %r11");
        asm!("popq %r10");
        asm!("popq %r9");
        asm!("popq %r8");
                                    // skip %rsp
        asm!("popq %rbp");
        asm!("popq %rdi");
        asm!("popq %rsi");
        asm!("popq %rdx");
        asm!("popq %rcx");
        asm!("popq %rbx");
        asm!("popq %rax");

        asm!("iretq");
    }
    else if(tf->cs == 0x08) {
        //returning to kernel mode          
        //load trapframe
        asm!("movq {proc_trapframe_off}, %rax");   //%rax now holds trapframe base

        //swap to destination stack
        asm!("movq 56(%rax), %rsp");

        //iretq information
        asm!("pushq 136(%rax)");    // rflags
        asm!("pushq 152(%rax)");    // CS
        asm!("pushq 128(%rax)");    // %rip

        //push registers
        asm!("pushq 0(%rax)");      // %rax
        asm!("pushq 8(%rax)");      // %rbx
        asm!("pushq 16(%rax)");     // %rcx
        asm!("pushq 24(%rax)");     // %rdx
        asm!("pushq 32(%rax)");     // %rsi
        asm!("pushq 40(%rax)");     // %rdi
        asm!("pushq 48(%rax)");     // %rbp
                                    // skip %rsp
        asm!("pushq 64(%rax)");     // %r8
        asm!("pushq 72(%rax)");     // %r9
        asm!("pushq 80(%rax)");     // %r10
        asm!("pushq 88(%rax)");     // %r11
        asm!("pushq 96(%rax)");     // %r12
        asm!("pushq 104(%rax)");    // %r13
        asm!("pushq 112(%rax)");    // %r14
        asm!("pushq 120(%rax)");    // %r15
        asm!("pushq 144(%rax)");    // %cr3

        //pop registers
        asm!("popq %rax");
        asm!("movq %rax, %cr3");

        asm!("popq %r15");
        asm!("popq %r14");
        asm!("popq %r13");
        asm!("popq %r12");
        asm!("popq %r11");
        asm!("popq %r10");
        asm!("popq %r9");
        asm!("popq %r8");
                                    // skip %rsp
        asm!("popq %rbp");
        asm!("popq %rdi");
        asm!("popq %rsi");
        asm!("popq %rdx");
        asm!("popq %rcx");
        asm!("popq %rbx");
        asm!("popq %rax");

        asm!("iretq");
    }
    else {
        panic("scheduler() : invalid CS");
    }
}

//ends the current process's time slice, goes to the scheduler
void yield() {
    passert(irq_disable_count == 0x0, "yield() : interrupts should be enabled");
    asm!("int $0x20");
}

export void update_cur_proc_status() {
    process* proc = get_cur_proc();
    if(proc->status == PROCESS_RUNNING) proc->status = PROCESS_READY;
    else if(proc->status == PROCESS_BLOCKED) proc->status = PROCESS_BLOCKED;
    else panic("get_next_status() : unrecognized runtime status");
}

void debug_print() {
    sout << "debug print\n";
}

//TSS should make it so that this uses the kernel stack
[__GLOBAL_FIRST__] extern u8 timer_interrupt_entry;
void timer_interrupt_handler() {
    asm!("timer_interrupt_entry:"); //don't want stack frame messing stuff up

    //cpu will have pushed these things onto the stack:
    // SS           : from user mode only
    // %rsp         : from user mode only
    // RFLAGS
    // CS
    // %rip
    // error code   : only for some interrupts
    // trap id      : after we've changed around IDT

    //check if we are coming from kernel mode
    //we know that at least this is on the stack:
    // RFLAGS
    // CS
    // %rip
    asm!("pushq %rax");             // save %rax
    asm!("movq 16(%rsp), %rax");    // CS should be at +16 after pushing %rax
    asm!("test $3, %al");           // mask out 0b11
    asm!("jnz .from_user"); 
    
    //if we're coming from kernel mode, redo the things that are pushed
    //so we can handle it as if we came from user mode
    asm!("pushq $0x10");            // SS
    asm!("lea 40(%rsp), %rax");     // there are 5 things pushed after the execution %rsp
    asm!("pushq %rax");             // %rsp
    asm!("pushq 40(%rsp)");         // RFLAGS
    asm!("pushq 40(%rsp)");         // CS
    asm!("pushq 40(%rsp)");         // %rip
    asm!("movq 40(%rsp), %rax");    // restore %rax
    asm!("jmp .register_save");

    //coming from user mode
    asm!(".from_user:");
    asm!("popq %rax");              // restore %rax
    asm!("swapgs");                 // swap to kernel GS 

    asm!(".register_save:");
    //push registers onto stack
    asm!("pushq %rax");
    asm!("pushq %rbx");
    asm!("pushq %rcx");
    asm!("pushq %rdx");
    asm!("pushq %rsi");
    asm!("pushq %rdi");
    asm!("pushq %rbp");
                                // skip %rsp
    asm!("pushq %r8");
    asm!("pushq %r9");
    asm!("pushq %r10");
    asm!("pushq %r11");
    asm!("pushq %r12");
    asm!("pushq %r13");
    asm!("pushq %r14");
    asm!("pushq %r15");

    asm!("mov %cr3, %rax");
    asm!("pushq %rax");

    //setup kernel execution context
    asm!("movq %gs:0, %rax");       //swap to kernel pagetable
    asm!("mov %rax, %cr3");

    //update current process's status
    asm!("call update_cur_proc_status");

    //get current process
    asm!("call get_cur_proc");      //%rax now holds pointer to current process

    //put trapframe addr into %rax
    asm!("movq 8(%rax), %rax");     //%rax now holds proc->kstack_bottom
    asm!("movq KSTACK_TRAPFRAME(%rip), %rbx"); 
    asm!("add %rbx, %rax");         //%rax now holds trapframe addr

    //write to trapframe
    asm!("popq 144(%rax)");     // %cr3
    asm!("popq 120(%rax)");     // %r15
    asm!("popq 112(%rax)");     // %r14
    asm!("popq 104(%rax)");     // %r13
    asm!("popq 96(%rax)");      // %r12
    asm!("popq 88(%rax)");      // %r11
    asm!("popq 80(%rax)");      // %r10
    asm!("popq 72(%rax)");      // %r9
    asm!("popq 64(%rax)");      // %r8
                                // skip %rsp
    asm!("popq 48(%rax)");      // %rbp
    asm!("popq 40(%rax)");      // %rdi
    asm!("popq 32(%rax)");      // %rsi
    asm!("popq 24(%rax)");      // %rdx
    asm!("popq 16(%rax)");      // %rcx
    asm!("popq 8(%rax)");       // %rbx
    asm!("popq 0(%rax)");       // %rax

    asm!("popq 128(%rax)");     // %rip 
    asm!("popq 152(%rax)");     // CS
    asm!("popq 136(%rax)");     // RFLAGS
    asm!("popq 56(%rax)");      // %rsp
    asm!("popq 160(%rax)");     // SS

    //send EOI
    asm!("movb $0x20, %al");
    asm!("outb %al, $0x20");

    //here we should jump to actual interrupt handlers depending on trap id

    //jump to scheduler
    asm!("jmp scheduler");
}