
[__GLOBAL_FIRST__] u64 PROCESS_NEW          = 0x0;
[__GLOBAL_FIRST__] u64 PROCESS_READY        = 0x1;
[__GLOBAL_FIRST__] u64 PROCESS_RUNNING      = 0x2;
[__GLOBAL_FIRST__] u64 PROCESS_ZOMBIE       = 0x3;
[__GLOBAL_FIRST__] u64 PROCESS_IDLE         = 0x4;
[__GLOBAL_FIRST__] u64 PROCESS_BLOCKED      = 0x5;

[__GLOBAL_FIRST__] u64 PROCESS_MAX_FD = $u64 64;
struct process {
    pid_t pid;                      // 0
    u64 kstack_bottom;              // 8
    u64 brk;                        // 16
    u64 status;                     // 24
    pagetable_t pt;                 // 32
    i32 exit_status;                // 40
    file*[64] fd_table;             // empty fds will be nullptr
    process* parent;                // nullptr indicates this is init process
    vector<process*> children;
    vfs_inode* cwd;                 // current working directory
}

u64 kstack_ptr = KSTACK_AREA_BOTTOM; //for now, just incrementally map new kstacks
pid_t pid_ptr = $pid_t 1;

void process_pt_map_kernel(process* proc, pagetable_t user_pt) {
    pagetable_t kernel_pt = pt_get_current();

    //map kernel code and stack
    for(u64 i = BOOTBOOT_CORE; i != 0x0; i += PAGE_SIZE) {
        void* vaddr = $void* i;
        if(pt_is_vaddr_mapped(kernel_pt, vaddr)) {
            u64 perm_flags;
            void* paddr = pt_translate(kernel_pt, vaddr, perm_flags);
            pt_map_page(user_pt, vaddr, paddr, perm_flags);
        }
    }

    //map kernel data
    for(u64 i = KERNEL_DATA_BOTTOM; i < KERNEL_DATA_TOP; i += PAGE_SIZE) {
        void* vaddr = $void* i;
        passert(pt_is_vaddr_mapped(kernel_pt, vaddr), "process_pt_map_kernel() : kernel data should be mapped");
        u64 perm_flags;
        void* paddr = pt_translate(kernel_pt, vaddr, perm_flags);
        pt_map_page(user_pt, vaddr, paddr, perm_flags);
    }

    //map kstack (assumes that this is already allocated for the process)
    for(u64 i = PAGE_SIZE; i < KSTACK_SIZE; i += PAGE_SIZE) {
        u64 perm_flags;
        void* vaddr = $void* (proc->kstack_bottom + i);
        passert(pt_is_vaddr_mapped(kernel_pt, vaddr), "process_pt_map_kernel() : kstack should be mapped");
        void* paddr = pt_translate(kernel_pt, vaddr, perm_flags);
        pt_map_page(user_pt, vaddr, paddr, PTE_WRITEABLE);
    }
}

void process_pt_unmap_kernel(process* proc, pagetable_t user_pt) {
    pagetable_t kernel_pt = pt_get_current();

    //unmap kernel code and stack
    for(u64 i = BOOTBOOT_CORE; i != 0x0; i += PAGE_SIZE) {
        void* vaddr = $void* i;
        if(pt_is_vaddr_mapped(kernel_pt, vaddr)) {
            pt_unmap_page(user_pt, vaddr);
        }
    }

    //unmap kernel data
    for(u64 i = KERNEL_DATA_BOTTOM; i < KERNEL_DATA_TOP; i += PAGE_SIZE) {
        void* vaddr = $void* i;
        pt_unmap_page(user_pt, vaddr);
    }

    //unmap kstack (we'll wait to delete kstack as we're still currently using it)
    for(u64 i = PAGE_SIZE; i < KSTACK_SIZE; i += PAGE_SIZE){
        void* vaddr = $void* (proc->kstack_bottom + i);
        pt_unmap_page(user_pt, vaddr);
    }
}

//pushes all argument strings + environment strings onto stack, and sets %rsp to the correct position
//expects stack to already be allocated.
//         [environment strings...]
//         [argument strings...]
//         AT_NULL                          <- AT_NULL = {0, 0}
//         auxv[0] ... auxv[n-1]            <- {u64 type, void* ptr}
//         NULL
//         envp[0] ... envp[n-1]
//         NULL                           
//         argv[0] ... argv[argc-1]         <- array of pointers (on the stack)
// %rsp -> argc
void process_populate_stack(process* proc, u8** argv, u8** envp) {
    //gather counts, compute size of buffer needed
    u64 arg_sz = 0x0;   //in terms of bytes
    u64 argc = 0x0;
    while($void* argv[argc] != nullptr) {
        arg_sz += ((strlen(argv[argc]) + 0x1 + 0x7) / 0x8) * 0x8;
        argc ++;
    }
    arg_sz += 0x8 * (argc + 0x1);
    u64 envc = 0x0;
    while($void* envp[envc] != nullptr) {
        arg_sz += ((strlen(envp[envc]) + 0x1 + 0x7) / 0x8) * 0x8;
        envc ++;
    }
    arg_sz += 0x8 * (envc + 0x1);
    arg_sz += 0x10;     //AT_NULL
    arg_sz += 0x8;      //argc

    //build arg buffer
    passert(arg_sz % 0x8 == 0x0, "process_populate_stack() : arg_sz should be 8-byte aligned");
    passert(arg_sz <= USER_STACK_TOP - USER_STACK_BOTTOM, "process_populate_stack() : arg_sz exceeds stack size");
    u64* arg_buf = $u64* malloc(arg_sz);
    u64 buf_pos = USER_STACK_TOP - arg_sz;
    u64 buf_ptr = 0x0;
    {
        //argc
        arg_buf[buf_ptr ++] = argc;
        //argv
        buf_ptr += argc;
        arg_buf[buf_ptr ++] = $u64 nullptr;
        //envp
        buf_ptr += envc;
        arg_buf[buf_ptr ++] = $u64 nullptr;
        //AT_NULL
        arg_buf[buf_ptr ++]= $u64 nullptr;
        arg_buf[buf_ptr ++]= $u64 nullptr;
        //argv strings
        for(u64 i = 0x0; i < argc; i++) {
            u64 sz = strlen(argv[i]) + 0x1;
            memcpy($void* @(arg_buf[buf_ptr]), $void* argv[i], sz);
            arg_buf[0x1 + i] = buf_pos + buf_ptr * 0x8;
            buf_ptr += (sz + 0x7) / 0x8;
        }
        //envp strings
        for(u64 i = 0x0; i < envc; i++) {
            u64 sz = strlen(envp[i]) + 0x1;
            memcpy($void* @(arg_buf[buf_ptr]), $void* envp[i], sz);
            arg_buf[0x1 + argc + 0x1 + i] = buf_pos + buf_ptr * 0x8;
            buf_ptr += (sz + 0x7) / 0x8;
        }
    }
    passert(buf_ptr * 0x8 == arg_sz, "process_populate_stack() : buf_ptr should be at end of buffer");

    //copy arg buffer to user stack
    copy_to_user(proc->pt, $u8* arg_buf, $u8* buf_pos, arg_sz);

    //dealloc arg buffer
    free($void* arg_buf, arg_sz);

    //set user %rsp
    trapframe* tf = $trapframe* (proc->kstack_bottom + KSTACK_TRAPFRAME);
    tf->rsp = buf_pos;
}

void process_pt_alloc_userspace(process* proc, pagetable_t user_pt, u64 flags) {
    if(flags & PROCESS_CREATE_STACK) {
        //map user stack
        for(u64 i = USER_STACK_BOTTOM; i < USER_STACK_TOP; i += PAGE_SIZE) {
            pt_alloc_and_map_page(user_pt, $void* i, PTE_USER | PTE_WRITEABLE);
        }

        //map guard page
        pt_alloc_and_map_page(user_pt, $void* USER_GUARD_PAGE, 0x0);
    }
}

//saves the provided trapframe into process trapframe storage location. 
void process_set_trapframe(process* proc, trapframe* tf) {
    trapframe* ptf = $trapframe* (proc->kstack_bottom + KSTACK_TRAPFRAME);
    memcpy($void* ptf, $void* tf, sizeof(trapframe));
}

//creates a dummy process
//you still need to do some stuff, this just takes care of some busywork
[__GLOBAL_FIRST__] u64 PROCESS_CREATE_STACK     = $u64 1 << $u64 0;
[__GLOBAL_FIRST__] u64 PROCESS_CREATE_FDTABLE   = $u64 1 << $u64 1;
process* create_process(u64 flags) {
    pagetable_t kernel_pt = pt_get_current();

    process* proc = $process* malloc(sizeof(process));
    new (proc) process();
    proc->pt = pt_alloc_new();
    proc->pid = pid_ptr ++;
    proc->brk = USER_HEAP_BOTTOM;
    proc->status = PROCESS_NEW;

    //alloc new kstack for process, need to map in kernel
    passert(kstack_ptr + KSTACK_SIZE <= KSTACK_AREA_TOP, "create_process() : ran out of room for kstacks");
    proc->kstack_bottom = kstack_ptr;
    for(u64 i = PAGE_SIZE; i < KSTACK_SIZE; i += PAGE_SIZE) {
        void* paddr = palloc();
        pt_map_page(kernel_pt, $void* (kstack_ptr + i), paddr, PTE_WRITEABLE);
    }
    kstack_ptr += KSTACK_SIZE;

    //map kernel
    process_pt_map_kernel(proc, proc->pt);

    //alloc userspace
    process_pt_alloc_userspace(proc, proc->pt, flags);

    if(flags & PROCESS_CREATE_FDTABLE) {
        passert(proc->pid == $pid_t 0x1, "create_process() : should only create new fdtable for init process");
        
        tty* tty = $tty* malloc(sizeof(tty));
        new (tty) tty();
        tty->termios = tty_gen_default_termios();
        tty->backend = nullptr;
        tty->backend_ops = TTY_BACKEND_OPS_SERIAL;
        tty->refcount = 0x0;

        proc->fd_table[STDIN] = file_create_tty($u64 O_RDONLY, tty);
        proc->fd_table[STDOUT] = file_create_tty($u64 O_WRONLY, tty);
        proc->fd_table[STDERR] = file_create_tty($u64 O_WRONLY, tty);
    }

    //write initial execution context to trapframe
    trapframe* tf = $trapframe* (proc->kstack_bottom + KSTACK_TRAPFRAME);
    memset($void* tf, 0, sizeof(trapframe));
    tf->rsp = USER_STACK_TOP;
    tf->rflags = 0x202;     //enable timer interrupt
    tf->pt = $u64 proc->pt;
    tf->cs = 0x23;          //user mode selectors
    tf->ss = 0x1b;

    //add to process list
    all_processes.push_back(proc);

    return proc;
}

//create new process from file at path
//assumes it points to valid ELF binary
process* create_process(string path, u8** argv, u8** envp) {
    process* proc = create_process(PROCESS_CREATE_STACK | PROCESS_CREATE_FDTABLE);

    //load file
    u64 elf_size;
    if(vfs_get_size(path, elf_size)) {
        panic("create_process() : failed to get filesize");
    }
    u8* elf_buf = $u8* malloc(elf_size);
    u64 read_amt;
    if(vfs_read_file(path, elf_buf, elf_size, 0x0, read_amt)) {
        panic("create_process() : failed to read file");
    }
    passert(read_amt == elf_size, "create_process() : should read entire binary");
    
    //map elf
    u64 entry_off;
    if(elf_load(elf_buf, elf_size, proc->pt, entry_off)) {
        panic("create_process() : failed to load elf");
    }

    //set entry point
    trapframe* tf = $trapframe* (proc->kstack_bottom + KSTACK_TRAPFRAME);
    tf->rip = entry_off;

    //set CWD. Need to go to file's parent directory
    {
        vfs_inode* file_dir;
        if(vfs_walk(path, file_dir)) {
            panic("create_process() : failed to walk to file dir");
        }
        vfs_inode* par_dir;
        if(vfs_get_parent(file_dir, par_dir)) {
            panic("create_process() : failed to get file parent dir");
        }
        vfs_dec_refcnt(file_dir);
        proc->cwd = par_dir;
    }

    //populate stack
    process_populate_stack(proc, argv, envp);

    //make ready
    make_process_ready(proc);

    return proc;
}

//creates process with default arguments and environment variables
process* create_process(string path) {
    //just have argv[0] = path
    u8** argv = $u8** malloc(sizeof(u8*) * 0x2);
    argv[0] = $u8* malloc(path.size() + 0x1);
    memcpy($void* argv[0], $void* path.jstr(), path.size() + 0x1);
    argv[1] = $u8* nullptr;

    //have PATH in envp
    u8* PATH = "PATH=/bin/path";
    u8** envp = $u8** malloc(sizeof(u8*) * 0x2);
    envp[0] = $u8* malloc(strlen(PATH) + 0x1);
    memcpy($void* envp[0], $void* PATH, strlen(PATH) + 0x1);
    envp[1] = $u8* nullptr;

    //create process
    process* proc = create_process(path, argv, envp);

    //dealloc argv, envp
    for(u64 i = 0x0; ; i++) {
        if($void* argv[i] == nullptr) {
            free($void* argv, sizeof(u8*) * (i + 0x1));
            break;
        }
        free($void* argv[i], strlen(argv[i]) + 0x1);
    }
    for(u64 i = 0x0; ; i++) {
        if($void* envp[i] == nullptr){
            free($void* envp, sizeof(u8*) * (i + 0x1));
            break;
        }
        free($void* envp[i], strlen(envp[i]) + 0x1);
    }

    return proc;
}

//creates a clone of the parent process's user memory state and other stuff
//also needs trapframe for the register state
process* create_process(process* parent, trapframe* parent_tf) {
    process* child = create_process(0x0);

    //make sure this process is alive
    passert(parent->status != PROCESS_ZOMBIE, "create_process() : can only clone from alive process");

    //set child's parent 
    child->parent = parent;

    //set parent's child
    parent->children.push_back(child);

    //copy process info
    child->brk = parent->brk;
    child->fd_table = parent->fd_table;

    //copy CWD
    passert($void* parent->cwd != nullptr, "create_process() : alive process should have CWD");
    child->cwd = parent->cwd;
    vfs_inc_refcnt(child->cwd);

    //increment refcount of file descriptors
    for(u64 i = 0x0; i < PROCESS_MAX_FD; i++){
        if($void* child->fd_table[i] == nullptr) continue;
        child->fd_table[i]->refcount ++;
    }

    //copy parent lower half mappings
    pt_copy_lower_half(parent->pt, child->pt);

    //copy over trapframe
    trapframe* child_tf = $trapframe* (child->kstack_bottom + KSTACK_TRAPFRAME);
    memcpy($void* child_tf, $void* parent_tf, sizeof(trapframe));
    child_tf->pt = $u64 child->pt;   //note that pagetables are different

    //make ready
    make_process_ready(child);

    return child;
}

//all new processes should go through this to become ready
//does some last checks and setup
//panics on failure
void make_process_ready(process* proc) {
    passert(proc->status == PROCESS_NEW, "make_process_ready() : should only receive new processes");

    proc->status = PROCESS_READY;
    process_queue.push_back(proc->pid);

    // sout << "MAKING PROCESS READY : " << proc->pid << " : " << process_queue.size() << "\n";
}

//marks process as dead, cleans up process. 
//the process will still exist in the scheduler as a zombie
//TODO transfer children to init instead of this parents parent
void kill_process(pid_t pid, i32 status) {
    pagetable_t kernel_pt = pt_get_current();

    //update process status
    process* proc = find_process(pid);
    passert(proc != nullptr, "kill_process() : should be able to find process");
    proc->status = PROCESS_ZOMBIE;
    proc->exit_status = status;

    //reparent children (for now just reparent to grandparent)
    if(proc->parent != nullptr) {
        process* grandparent = proc->parent;
        for(u64 i = 0x0; i < proc->children.size(); i++) {
            grandparent->children.push_back(proc->children[i]);
        }
        proc->children.clear();
    }

    //unmap kernel
    process_pt_unmap_kernel(proc, proc->pt);

    //free pagetable + underlying pages
    pt_free(proc->pt);
    proc->pt = $pagetable_t nullptr;

    //free file descriptors
    for(u64 i = 0x0; i < PROCESS_MAX_FD; i++){
        if(proc->fd_table[i] == nullptr) continue;
        file_close(proc->fd_table[i]);
        proc->fd_table[i] = $file* nullptr;
    }

    //free cwd
    passert($void* proc->cwd != nullptr, "kill_process() : alive process should always have CWD");
    vfs_dec_refcnt(proc->cwd);
    proc->cwd = $vfs_inode* nullptr;
}

//this completely gets rid of the process from the scheduler
//should also delete kstack
//should only be able to remove zombie processes
void remove_process(pid_t pid) {
    //find process
    process* proc = find_process(pid);

    //make sure process is a zombie process
    passert(proc->status == PROCESS_ZOMBIE, "remove_process() : process must be zombie");

    //dealloc kstack
    pagetable_t kernel_pt = pt_get_current();
    for(u64 i = PAGE_SIZE; i < KSTACK_SIZE; i += PAGE_SIZE) {
        void* vaddr = $void* (proc->kstack_bottom + i);
        void* paddr = pt_translate(kernel_pt, vaddr);
        pt_unmap_page(kernel_pt, vaddr);
        pfree(paddr);
    }

    //remove from parent's child list
    if($void* proc->parent != nullptr) {
        u64 ind = proc->parent->children.size();
        for(u64 i = 0x0; i < proc->parent->children.size(); i++) {
            if(proc->parent->children[i]->pid == pid) {
                passert(ind == proc->parent->children.size(), "remove_process() : parent should only contain child once");
                ind = i;
            }
        }
        passert(ind != proc->parent->children.size(), "remove_process() : should be able to find child in parent");
        proc->parent->children.erase(ind);
    }

    //remove process from scheduler
    erase_process(pid);
    free($void* proc, sizeof(process));
}

