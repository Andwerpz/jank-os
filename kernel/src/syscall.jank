
i32 init_syscall() {
    sout << "start init syscalls\n";

    //setup STAR
    //syscall and sysret automatically loads new segment from descriptor table based off of these values
    u64 SELECTOR_1 = 0x08;  //kernel code
    u64 SELECTOR_2 = 0x13;  //kernel data
    wrmsr(STAR_MSR, (SELECTOR_1 << $u64 32) | (SELECTOR_2 << $u64 48));
    sout << "STAR : " << $void* ((SELECTOR_1 << $u64 32) | (SELECTOR_2 << $u64 48)) << "\n";

    //setup LSTAR
    wrmsr(LSTAR_MSR, $u64 @syscall_handler_entry);

    //setup FMASK (clear interrupt flag on syscall entry)
    wrmsr(FMASK_MSR, 0x200);  // Clear IF (bit 9) on syscall
    
    //enable syscalls
    u64 efer = rdmsr(EFER_MSR);
    efer |= 0x1;
    wrmsr(EFER_MSR, efer);

    //setup GS_BASE
    pagetable_t kernel_pt = pt_get_current();
    pt_map_page(kernel_pt, $void* GSDATA_PAGE, palloc(), PTE_WRITEABLE);

    GSData* gs_data = $GSData* GSDATA_PAGE;
    gs_data->kernel_pt = kernel_pt;
    wrmsr(GS_BASE_MSR, $u64 gs_data);

    sout << "done init syscalls\n";
    return 0;
}

//returns 0 on success, negative on failure
//expects kernel_pt to be active
i32 copy_to_user(pagetable_t user_pt, u8* kbuf, u8* ubuf, u64 amt) {
    u64 uptr = $u64 ubuf;
    uptr = (uptr / PAGE_SIZE) * PAGE_SIZE;  //round down to nearest page boundary
    u64 ubuf_end = $u64 ubuf + amt;
    u64 kptr = 0x0;

    while(uptr < ubuf_end) {
        //make sure page is mapped
        if(!pt_is_vaddr_mapped(user_pt, $void* uptr)) {
            return -ERR_FAULT;
        }

        //check flags
        u64 flags;
        void* paddr = pt_translate(user_pt, $void* uptr, flags);
        if(!(flags & PTE_WRITEABLE) || !(flags & PTE_USER)) {
            return -ERR_FAULT;
        }

        //copy data
        for(u64 i = 0x0; i < PAGE_SIZE; i++) {
            u64 cptr = uptr + i;
            if(cptr < $u64 ubuf || cptr >= ubuf_end) continue;
            ($u8* paddr)[i] = kbuf[kptr ++];
        }

        uptr += PAGE_SIZE;
    }

    return 0;
}

//returns 0 on success, negative on failure
//expects kernel_pt to be active
i32 copy_from_user(pagetable_t user_pt, u8* kbuf, u8* ubuf, u64 amt) {
    u64 uptr = $u64 ubuf;
    uptr = (uptr / PAGE_SIZE) * PAGE_SIZE;  //round down to nearest page boundary
    u64 ubuf_end = $u64 ubuf + amt;
    u64 kptr = 0x0;

    while(uptr < ubuf_end) {
        //make sure page is mapped
        if(!pt_is_vaddr_mapped(user_pt, $void* uptr)) {
            return -ERR_FAULT;
        }

        //check flags
        u64 flags;
        void* paddr = pt_translate(user_pt, $void* uptr, flags);
        if(!(flags & PTE_USER)) {
            return -ERR_FAULT;
        }

        //copy data
        for(u64 i = 0x0; i < PAGE_SIZE; i++) {
            u64 cptr = uptr + i;
            if(cptr < $u64 ubuf || cptr >= ubuf_end) continue;
            kbuf[kptr ++] = ($u8* paddr)[i];
        }

        uptr += PAGE_SIZE;
    }

    return 0;
}

// -- SYSCALL IDENTIFIERS --
//linux syscalls
[__GLOBAL_FIRST__] u64 SYS_READ             = $u64 0;
[__GLOBAL_FIRST__] u64 SYS_WRITE            = $u64 1;
[__GLOBAL_FIRST__] u64 SYS_CLOSE            = $u64 3;
[__GLOBAL_FIRST__] u64 SYS_MMAP             = $u64 9;
[__GLOBAL_FIRST__] u64 SYS_MUNMAP           = $u64 11;
[__GLOBAL_FIRST__] u64 SYS_SCHED_YIELD      = $u64 24;
[__GLOBAL_FIRST__] u64 SYS_GETPID           = $u64 39;
[__GLOBAL_FIRST__] u64 SYS_FORK             = $u64 57;
[__GLOBAL_FIRST__] u64 SYS_EXIT             = $u64 60;
[__GLOBAL_FIRST__] u64 SYS_WAIT4            = $u64 61;
[__GLOBAL_FIRST__] u64 SYS_CLOCK_GETTIME    = $u64 228;

//jank syscalls
//TODO add talk-to-jank 

//gets the calling user process's saved trapframe when they just entered syscall
//assumes we saved trapframe near top of process kernel stack
trapframe* get_user_trapframe() {
    trapframe* ret;
    asm!("movq %gs:16, %rax");  //%rax now holds top of process kstack
    asm!("sub $192, %rax");     //192 = 168 + 24
    asm!("movq %rax, {ret}");
    return ret;
}   

//for now, this is just using the user stack to save the execution context
[__GLOBAL_FIRST__] extern u8 syscall_handler_entry;
void syscall_handler_asm() {    //this generates label "syscall_handler_asm:", but we shouldn't use it
    //this assumes we come from user mode

    //cpu should put this stuff in these registers:
    //%rsp : user %rsp
    //%r11 : user RFLAGS
    //%rcx : user %rip
    
    asm!("syscall_handler_entry:");
    asm!("swapgs");

    //switch to process kstack
    asm!("movq %rsp, %gs:8");       //save original %rsp
    asm!("movq %gs:16, %rsp");      //%rsp now points to top of process kstack

    //push sysret info
    asm!("pushq %gs:8");    //user stack pointer
    asm!("pushq %r11");     //user rflags
    asm!("pushq %rcx");     //user RIP

    //push trapframe (make sure trapframe is correct size)
    asm!("sub $168, %rsp");
    asm!("movq %rcx,  128(%rsp)");  //%rip

    asm!("movq %rax,  0(%rsp)");
    asm!("movq %rbx,  8(%rsp)");
    asm!("movq %rcx,  16(%rsp)");
    asm!("movq %rdx,  24(%rsp)");
    asm!("movq %rsi,  32(%rsp)");
    asm!("movq %rdi,  40(%rsp)");
    asm!("movq %rbp,  48(%rsp)");
    asm!("movq %gs:8, %rcx");
    asm!("movq %rcx,  56(%rsp)");
    asm!("movq %r8,   64(%rsp)");
    asm!("movq %r9,   72(%rsp)");
    asm!("movq %r10,  80(%rsp)");
    asm!("movq %r11,  88(%rsp)");
    asm!("movq %r12,  96(%rsp)");
    asm!("movq %r13,  104(%rsp)");
    asm!("movq %r14,  112(%rsp)");
    asm!("movq %r15,  120(%rsp)");
    //already set %rip    
    asm!("movq %r11,  136(%rsp)");
    asm!("movq %cr3, %rcx");
    asm!("movq %rcx,  144(%rsp)");
    asm!("movq $0x1B, 152(%rsp)");  //user mode selectors
    asm!("movq $0x23, 160(%rsp)");  

    //call higher level syscall handler
    asm!("call syscall_handler");

    //pop trapframe
    asm!("add $8, %rsp");   //skip %rax
    asm!("popq %rbx");
    asm!("popq %rcx");
    asm!("popq %rdx");
    asm!("popq %rsi");
    asm!("popq %rdi");
    asm!("popq %rbp");
    asm!("add $8, %rsp");   //skip %rsp
    asm!("popq %r8");
    asm!("popq %r9");
    asm!("popq %r10");
    asm!("popq %r11");
    asm!("popq %r12");
    asm!("popq %r13");
    asm!("popq %r14");
    asm!("popq %r15");
    asm!("add $8, %rsp");   //skip %rip
    asm!("add $8, %rsp");   //skip RFLAGS
    asm!("add $8, %rsp");   //assume we're currently using user_pt
    asm!("add $8, %rsp");   //skip CS
    asm!("add $8, %rsp");   //skip SS

    //pop sysret info
    asm!("popq %rcx");  //user RIP
    asm!("popq %r11");  //user RFLAGS
    asm!("popq %rsp");  //switch back to user stack

    asm!("swapgs");
    asm!("sysretq");
}

//this should generate label 'syscall_handler:'
//when adding syscall preemption, interrupt flag should be enabled/disabled in here
export u64 syscall_handler() {
    u64 sys_id;
    u64 arg1;
    u64 arg2;
    u64 arg3;
    u64 arg4;
    u64 arg5;
    u64 arg6;

    asm!("movq %rax, {sys_id}");
    asm!("movq %rdi, {arg1}");
    asm!("movq %rsi, {arg2}");
    asm!("movq %rdx, {arg3}");
    asm!("movq %r10, {arg4}");
    asm!("movq %r8,  {arg5}");
    asm!("movq %r9,  {arg6}");

    if(0) {
        pagetable_t user_pt = pt_get_current();
        pt_switch_to_kernel();
        sout << "SYSCALL : " << sys_id << "\n";
        pt_switch(user_pt);
    }

    //asm!("sti");      //enable timer interrupts

    u64 ans;
    if(sys_id == SYS_READ)                  ans = $u64 sys_read($i32 arg1, $u8* arg2, arg3);
    else if(sys_id == SYS_WRITE)            ans = $u64 sys_write($i32 arg1, $u8* arg2, arg3);
    else if(sys_id == SYS_CLOSE)            ans = $u64 sys_close($i32 arg1);
    else if(sys_id == SYS_EXIT)             ans = $u64 sys_exit($i32 arg1);
    else if(sys_id == SYS_SCHED_YIELD)      ans = $u64 sys_sched_yield();
    else if(sys_id == SYS_MMAP)             ans = $u64 sys_mmap($void* arg1, $u64 arg2, $u64 arg3, $u64 arg4, $i32 arg5, $u64 arg6);
    else if(sys_id == SYS_MUNMAP)           ans = $u64 sys_munmap($void* arg1, $u64 arg2);
    else if(sys_id == SYS_GETPID)           ans = $u64 sys_getpid();
    else if(sys_id == SYS_FORK)             ans = $u64 sys_fork();
    else if(sys_id == SYS_WAIT4)            ans = $u64 sys_wait4($pid_t arg1, $i32* arg2, $i32 arg3, $void* arg4);
    else if(sys_id == SYS_CLOCK_GETTIME)    ans = $u64 sys_clock_gettime($u64 arg1, $timespec* arg2);

    else panic("unrecognized sys_id");

    //asm!("cli");      //disable timer interrupts

    return $u64 ans;
}

//on success, populates ts with the current time in the requested clock and returns 0
//on failure, returns some negative error code
//currently only supports CLOCK_REALTIME
u64 sys_clock_gettime(u64 clock_id, timespec* ts) {
    pagetable_t user_pt = pt_get_current();
    pt_switch_to_kernel();

    passert(clock_id == CLOCK_REALTIME, "sys_clock_gettime() : currently only support CLOCK_REALTIME");

    timespec* kts = $timespec* malloc(sizeof(timespec));
    hpet_get_sys_time(kts);
    i64 tv_sec = kts->tv_sec;
    i64 tv_nsec = kts->tv_nsec;
    free($void* kts, sizeof(timespec));

    pt_switch(user_pt);

    ts->tv_sec = tv_sec;
    ts->tv_nsec = tv_nsec;

    return 0x0;
}

//on success, returns the pid of the child that got WAIT'd
//if WNOHANG was specified and no child was WAIT'd, returns 0
//on failure some negative error code is returned
pid_t sys_wait4(pid_t pid, i32* wstatus, i32 options, void* rusage) {
    pagetable_t user_pt = pt_get_current();
    pt_switch_to_kernel();

    passert(rusage == nullptr, "sys_wait4() : no support for rusage");
    passert(wstatus == nullptr, "sys_wait4() : no support for wstatus");
    passert(pid > $pid_t -1 && pid != $pid_t 0, "sys_wait4() : pgids not supported");

    pid_t retval = $pid_t 0;
    process* proc = get_cur_proc();
    if(proc->children.size() == 0x0) {
        pt_switch(user_pt);
        return $pid_t -ERR_CHILD;
    }
    while(retval == $pid_t 0) {
        for(u64 i = 0x0; i < proc->children.size(); i++){
            process* child = proc->children[i];
            if(child->status != PROCESS_ZOMBIE) continue;
            if(pid == $pid_t -1 || pid == child->pid) {
                retval = child->pid;
                remove_process(child->pid);
                break;
            }
        }
        if(options & WNOHANG) break;
    }

    pt_switch(user_pt);
    return retval;
}

i64 sys_read(i32 fd_ind, u8* buf, u64 amt) {
    // switch to kernel pt
    pagetable_t user_pt = pt_get_current();
    pt_switch_to_kernel();

    process* proc = get_cur_proc();
    file_descriptor* fd = proc->fd_table[fd_ind];

    // check if file descriptor exists
    if(fd == nullptr) {
        pt_switch(user_pt);
        return $i64 -ERR_BADF;
    }

    // check if file descriptor has read flags
    if(!(fd->flags == O_RDONLY || fd->flags == O_RDWR)) {
        pt_switch(user_pt);
        return $i64 -ERR_BADF;
    }

    //do read
    u8* kbuf = $u8* malloc(amt);
    i64 retval = fd_read(fd, kbuf, amt);

    //transfer data to user buffer
    if(retval > $i64 0) {
        i64 cpy_status = $i64 copy_to_user(user_pt, kbuf, buf, $u64 retval);
        if(cpy_status < $i64 0) retval = cpy_status;
    }

    //free kbuf
    free($void* kbuf, amt);

    // set user pt back
    pt_switch(user_pt);

    return $i64 retval;
}

i64 sys_write(i32 fd_ind, u8* buf, u64 amt) {
    // switch to kernel pt
    pagetable_t user_pt = pt_get_current();
    pt_switch_to_kernel();

    process* proc = get_cur_proc();
    file_descriptor* fd = proc->fd_table[fd_ind];

    // check if file descriptor exists
    if(fd == nullptr) {
        pt_switch(user_pt);
        return $i64 -ERR_BADF;
    }

    // check if file descriptor has write flags
    if(!(fd->flags == O_WRONLY || fd->flags == O_RDWR || fd->flags == O_APPEND)) {
        pt_switch(user_pt);
        return $i64 -ERR_BADF;
    }

    //transfer data from user buffer
    u8* kbuf = $u8* malloc(amt);
    i64 cpy_status = $i64 copy_from_user(user_pt, kbuf, buf, amt);
    if(cpy_status < $i64 0) {
        free($void* kbuf, amt);
        pt_switch(user_pt);
        return cpy_status;
    }

    //do write
    i64 retval = fd_write(fd, kbuf, amt);

    //free kbuf
    free($void* kbuf, amt);

    // set user pt back
    pt_switch(user_pt);

    return $i64 retval;
}

i32 sys_close(i32 fd_ind) {
    // switch to kernel_pt
    pagetable_t user_pt = pt_get_current();
    pt_switch_to_kernel();

    process* proc = get_cur_proc();
    file_descriptor* fd = proc->fd_table[fd_ind];
    proc->fd_table[fd_ind] = $file_descriptor* nullptr;
    
    if($u64 fd == $u64 nullptr) {
        pt_switch(user_pt);
        return -1;
    }

    i32 retval = fd_close(fd);

    // set user pt back
    pt_switch(user_pt);

    return retval;
}

//terminates the calling process
u64 sys_exit(i32 status) {
    //switch to kernel_pt
    pt_switch_to_kernel();

    //kill current process
    kill_process(get_cur_pid(), status);

    //point %rsp to top of kernel stack
    asm!("mov BOOTBOOT_STACK_TOP(%rip), %rsp");

    //jump to scheduler
    scheduler();

    return 0x0;
}

//returns the pid of the calling process
pid_t sys_getpid() {
    return get_cur_pid();
}

//creates clone of this process, the 'child'. the calling process is the 'parent'
//in the parent, fork returns with pid of the child
//in the child, fork returns with 0
pid_t sys_fork() {
    // switch to kernel_pt
    pagetable_t user_pt = pt_get_current();
    pt_switch_to_kernel();

    // create child process
    process* parent = get_cur_proc();
    trapframe* parent_tf = get_user_trapframe();
    process* child = create_process(parent, parent_tf);
    pid_t retval = child->pid;

    // set child return value to 0
    trapframe* child_tf = $trapframe* (child->kstack_bottom + KSTACK_TRAPFRAME);
    child_tf->rax = 0x0;

    // set user pt back
    pt_switch(user_pt);

    return retval;
}

//current process is yielding control to the scheduler
u64 sys_sched_yield() {
    pagetable_t user_pt = pt_get_current();
    pt_switch_to_kernel();
    
    yield();

    pt_switch(user_pt);
    return 0x0;
}

void* sys_mmap(void* addr, u64 len, u64 prot_flags, u64 map_flags, i32 fd, u64 offset) {
    // switch to kernel_pt
    pagetable_t user_pt = pt_get_current();
    pt_switch_to_kernel();

    process* proc = get_cur_proc();

    // check if len is page aligned
    if(len % PAGE_SIZE != 0x0) {
        pt_switch(user_pt);
        return $void* $u64 -1;
    }

    // check if we've ran out of heap space
    if(proc->brk + len > USER_HEAP_TOP) {
        pt_switch(user_pt);
        return $void* $u64 -1;
    }

    // alloc mem
    void* vaddr = $void* proc->brk;
    for(u64 i = 0x0; i < len; i += PAGE_SIZE) {
        pt_alloc_and_map_page(user_pt, $void* ($u64 vaddr + i), map_flags | PTE_USER);
    }
    proc->brk += len;

    // set user pt back
    pt_switch(user_pt);

    return vaddr; 
}

i32 sys_munmap(void* addr, u64 len) {
    // switch to kernel_pt
    pagetable_t user_pt = pt_get_current();
    pt_switch_to_kernel();

    if($u64 addr % PAGE_SIZE != 0x0 || len % PAGE_SIZE != 0x0) return -1;
    for(u64 i = 0x0; i < len; i += PAGE_SIZE) {
        void* curr_vaddr = $void* ($u64 addr + i);
        if(!pt_is_vaddr_mapped(user_pt, curr_vaddr)) panic("sys_munmap: double free");
        void* paddr = pt_translate(user_pt, curr_vaddr);
        pt_unmap_page(user_pt, curr_vaddr);
        pfree(paddr);
    }

    // set user pt back
    pt_switch(user_pt);

    return 0;
}