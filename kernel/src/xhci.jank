// eXtensible Host Controller Interface (xHCI)
// this interface is implemented by hardware
// this driver is just responsible for using this interface 

// https://wiki.osdev.org/EXtensible_Host_Controller_Interface

// intel official xHCI specification
// https://www.intel.com/content/dam/www/public/us/en/documents/technical-specifications/extensible-host-controler-interface-usb-xhci.pdf

[__GLOBAL_FIRST__] u32 XHCI_HCSPARAMS1_MAXSLOTS = $u32 0b0000000011111111;  // maximum device slots the host controller can support
[__GLOBAL_FIRST__] u32 XHCI_HCCPARAMS1_AC64 = $u32 0b0000000000000001;      // 64-bit addressing capability

// capability registers
// located at the start of xHCI mmio space
struct xHCI_cap_regs {
    u8 CAPLENGTH;           // capability register length
    u8 RSVD;                // reserved
    u16 HCIVERSION;         // interface version number
    u32 HCSPARAMS1;         // structural parameters 1
    u32 HCSPARAMS2;         // structural parameters 2
    u32 HCSPARAMS3;         // structural parameters 3
    u32 HCCPARAMS1;         // capability parameters 1
    u32 DBOFF;              // doorbell offset, low 2 bits are reserved
    u32 RTSOFF;             // runtime registers offset, low 5 bits are reserved
    u32 HCCPARAMS2;         // capability parameters 2
}

// USBCMD bits defined in section 5.4.1 of intel manual
[__GLOBAL_FIRST__] u32 XHCI_USBCMD_RS       = $u32 0b0000000000000001;      // run / stop : When set to 1, xHC starts operating
[__GLOBAL_FIRST__] u32 XHCI_USBCMD_HCRST    = $u32 0b0000000000000010;      // host controller reset : When set, xHC resets itself, writing 0 to this bit when completed
[__GLOBAL_FIRST__] u32 XHCI_USBCMD_INTE     = $u32 0b0000000000000100;      // interrupter enable 

// USBSTS bits defined in section 5.4.2 of intel manual
[__GLOBAL_FIRST__] u32 XHCI_USBSTS_HCH      = $u32 0b0000000000000001;      // xHC Halted : this is 0 whenever XHCI_USBCMD_RS is 1
[__GLOBAL_FIRST__] u32 XHCI_USBSTS_HSE      = $u32 0b0000000000000100;      // host system error : set whenever a serious error is detected, xHC is halted
[__GLOBAL_FIRST__] u32 XHCI_USBSTS_EINT     = $u32 0b0000000000001000;      // event interrupt : xHC sets this bit to 1 when the Interrupt Pending (IP) of any interrupter transitions from 0 to 1
[__GLOBAL_FIRST__] u32 XHCI_USBSTS_PCD      = $u32 0b0000000000010000;      // port change detected : xHC sets this bit to 1 when any port has a change bit go from 0 to 1
[__GLOBAL_FIRST__] u32 XHCI_USBSTS_CNR      = $u32 0b0000100000000000;      // controller not ready 

// CRCR bits defined in section 5.4.5 of intel manual
[__GLOBAL_FIRST__] u64 XHCI_CRCR_RCS        = 0b0000000000000001;           // ring cycle state : cycle consumer state of xHC

[__GLOBAL_FIRST__] u32 XHCI_CONFIG_MAXSLOTS = $u32 0b0000000011111111;      // maximum number of enabled device slots

// operational registers
// located directly after the capability registers in xHCI mmio space
struct xHCI_op_regs {
    u32 USBCMD;             // USB command
    u32 USBSTS;             // USB status
    u32 PAGESIZE;           // page size
    u32[2] reserved0;       
    u32 DNCTRL;             // device notification control
    u64 CRCR;               // command ring control register, low 6 bits are flags, upper bits is pointer to command ring
    u32[4] reserved1;        
    u64 DCBAAP;             // device context base address array pointer, low 6 bits are reserved
    u32 CONFIG;             // config
}

// port registers
// located at +0x400 relative to start of operational registers
struct xHCI_port_regs {
    u32 PORTSC;
    u32 PORTPMSC;
    u32 PORTLI;
    u32 reserved;
}

// runtime registers
// located at offset +RTSOFF from xHCI MMIO base
struct xHCI_runtime_regs {
    u32 MFINDEX;             // microframe index
    u8[28] reserved;    
}

// doorbell registers
// located at offset + DBOFF from xHCI MMIO base
// these registers are all 32-bits, and should only be written to in their entirety (dword accesses)
// for this reason, I have not provided a struct for doorbell registers
[__GLOBAL_FIRST__] u32 XHCI_DB_TARGET = $u32 0x000000FF;
[__GLOBAL_FIRST__] u32 XHCI_DB_TASKID = $u32 0xFFFF0000;

[__GLOBAL_FIRST__] u32 XHCI_IMAN_IP = $u32 0b0001;  // interrupt pending - RW1C : if set to 1, an interrupt is pending for this interrupter
[__GLOBAL_FIRST__] u32 XHCI_IMAN_IE = $u32 0b0010;  // interrupt enable : when IE and IP are 1, an interrupt should be generated

[__GLOBAL_FIRST__] u64 XHCI_ERDP_EHB = 0b1000;      // event handler busy - RW1C : set to 1 when IP is set to 1, should be cleared to 0 when writing to ERDP

// interrupter register set
// directly after runtime registers in memory, there will be up to 1024 contiguous interrupter registers
// an interrupter register points to a ERST. When the xHC writes an event to an event ring, the corresponding interrupter
// will have a flag enabled so the host knows to go read the event ring for new TRBs.
struct xHCI_INTRS {
    u32 IMAN;           // interrupter management
    u32 IMOD;           // interrupter moderation
    u32 ERSTSZ;         // event ring segment table size, how many ERST entries this event ring uses
    u32 reserved;       
    u64 ERSTBA;         // event ring segment table base address
    u64 ERDP;           // event ring dequeue pointer, physical deque pointer to event ring. controlled by host
}


// Transfer Request Block
// used in ring buffers so that host and xHC can communicate
// there are many types, but they mostly follow the same general structure
// in the command ring, host writes and hardware reads
// in the event ring, hardware writes and host reads

[__GLOBAL_FIRST__] u32 XHCI_TRB_TYPE_LINK           = $u32 6;
[__GLOBAL_FIRST__] u32 XHCI_TRB_TYPE_ENABLE_SLOT    = $u32 9;

// TRB control bits
[__GLOBAL_FIRST__] u32 XHCI_TRB_C           = $u32 0b0000000000000001;      // cycle : determines if this TRB is new or stale for this lap
[__GLOBAL_FIRST__] u32 XHCI_TRB_TYPE        = $u32 0b1111110000000000;      // type : starts at bit 10

[__GLOBAL_FIRST__] u32 XHCI_TRB_LINK_TC     = $u32 0b0000000000000010;      // toggle cycle : if this is set, internal cycle state should be toggled after processing this link TRB

struct xHCI_TRB {
    u64 parameter;
    u32 status;
    u32 control;
}

// Event Ring Segment Table 
// used to define multi-segment event rings and enable runtime expansion and shrinking of the event ring
struct xHCI_ERST_ent {
    u64 ring_segment_base_addr;         // the low 6 bits are reserved
    u16 ring_segment_size;              // the number of TRBs in this ring, this must be in range [16, 4096]
    u16 reserved0;
    u32 reserved1;
}

//the main method of communication between the host and hardware is via TRBs in ring buffers
//since we don't have a synchronized 'start' and 'end' buffer pointer, the way that the consumer
//knows to keep reading entries is the cycle flag on each TRB. 
//the consumer has an internal 'cycle state', and if the cycle flag on the TRB matches the cycle state,
//then the TRB is considered fresh. Otherwise it's stale and the consumer should stop reading. 
//when the producer writes a new TRB, they'll write the TRB and assign the cycle flag to their internal cycle state.
//when the consumer/producer reaches the end of the ring buffer, it should encounter a link TRB with the TC flag on, 
//this should cause the producer and consumer to toggle their internal states. 
//when initializing the ring buffers, we want to initialize them with all stale TRBs. For ease of initialization,
//we'll just initialize the consumer/producer cycle state to 1, this way cycle=0 is stale and we can just zero 
//out the TRB ring buffers. 
[__GLOBAL_FIRST__] u32 XHCI_COMMAND_PRODUCER_CYCLE_STATE;
[__GLOBAL_FIRST__] u64 XHCI_COMMAND_PRODUCER_INDEX;
[__GLOBAL_FIRST__] u64 XHCI_COMMAND_RING_SIZE;  //number of TRBs in command ring

[__GLOBAL_FIRST__] xHCI_cap_regs* XHCI_CAP_REGS;
[__GLOBAL_FIRST__] xHCI_op_regs* XHCI_OP_REGS;
[__GLOBAL_FIRST__] xHCI_port_regs* XHCI_PORT_REGS;
[__GLOBAL_FIRST__] xHCI_runtime_regs* XHCI_RUNTIME_REGS;
[__GLOBAL_FIRST__] xHCI_INTRS* XHCI_INTERRUPTERS;
[__GLOBAL_FIRST__] u32* XHCI_DB_REGS;

//should be 1-to-1 with interrupters
[__GLOBAL_FIRST__] u64* XHCI_EVENT_RING_PTRS;   
[__GLOBAL_FIRST__] u32* XHCI_EVENT_RING_STATES;

//notifies xHC that there is some available TRBs to read at the corresponding transfer ring
void xhci_ring_transfer_doorbell(u64 ind) {
    assert(ind != 0x0, "xhci_ring_transfer_doorbell() : ind 0 is reserved for command ring");
    //TODO
}

//notifies xHC that there is some available TRBs to read on the command ring
void xhci_ring_command_doorbell() {
    asm!("mfence"); //ensure any TRB writes before this are flushed
    XHCI_DB_REGS[0] = $u32 0;
}

//writes a TRB to the command ring and rings the command ring doorbell
void xhci_write_command() {
    xHCI_TRB* ring = $xHCI_TRB* command_ring_addr;

    //write TRB
    xHCI_TRB* t = @(ring[XHCI_COMMAND_PRODUCER_INDEX]);
    t->parameter = $u64 0;
    t->status    = $u32 0;
    t->control   = (XHCI_COMMAND_PRODUCER_CYCLE_STATE) | (XHCI_TRB_TYPE_ENABLE_SLOT << $u32 10);              

    //advance
    XHCI_COMMAND_PRODUCER_INDEX ++;
    if(XHCI_COMMAND_PRODUCER_INDEX == XHCI_COMMAND_RING_SIZE - 0x1) {
        //should be at link TRB
        xHCI_TRB* link_trb = @(ring[XHCI_COMMAND_PRODUCER_INDEX]);
        u32 type = ((link_trb->control & XHCI_TRB_TYPE) >> $u32 10);
        assert(type == XHCI_TRB_TYPE_LINK, "xhci_write_command() : this TRB should be the link TRB");

        //set cycle state equal to producer state
        link_trb->control = (link_trb->control & ~XHCI_TRB_C) | XHCI_COMMAND_PRODUCER_CYCLE_STATE;

        //see if we need to toggle producer state
        if(link_trb->control & XHCI_TRB_LINK_TC) {
            XHCI_COMMAND_PRODUCER_CYCLE_STATE ^= XHCI_TRB_C;
        }

        //go back to beginning
        XHCI_COMMAND_PRODUCER_INDEX = 0x0;
    }

    //ring doorbell
    xhci_ring_command_doorbell();
}

//retrieves the next TRB from the given event ring
//does not check IMAN.IP
//returns 0 on success, 1 on failure
i32 xhci_read_event(u64 ind, xHCI_TRB* out_trb) {
    xHCI_INTRS* intr = @(XHCI_INTERRUPTERS[ind]);
    u64 ev_ptr = XHCI_EVENT_RING_PTRS[ind];
    u32 ev_state = XHCI_EVENT_RING_STATES[ind];
    assert(intr->ERSTSZ == $u32 1, "xhci_read_event() : only support event rings with one segment for now");

    xHCI_ERST_ent* erst = $xHCI_ERST_ent* intr->ERSTBA;
    xHCI_TRB* event_ring = $xHCI_TRB* erst->ring_segment_base_addr;
    u64 ring_sz = $u64 erst->ring_segment_size;
    assert(ev_ptr < ring_sz, "xhci_read_event() : ev_ptr is out of bounds");
    xHCI_TRB* trb = @(event_ring[ev_ptr]);

    //check TRB freshness
    if((trb->control & XHCI_TRB_C) != ev_state) {
        return 1;   
    }

    //copy to out_trb
    out_trb->parameter = trb->parameter;
    out_trb->status    = trb->status;
    out_trb->control   = trb->control;

    //advance dequeue
    ev_ptr ++;
    if(ev_ptr == ring_sz) {
        ev_ptr = 0x0;
        ev_state ^= XHCI_TRB_C;
    }

    //update ERDP
    u64 new_ERDP = (($u64 event_ring + ev_ptr * sizeof(xHCI_TRB)) & ~0xF) | XHCI_ERDP_EHB;
    intr->ERDP = new_ERDP;

    //update consumer state
    XHCI_EVENT_RING_PTRS[ind] = ev_ptr;
    XHCI_EVENT_RING_STATES[ind] = ev_state;

    return 0;
}

void init_xhci(u64 addr) {
    println("start init xhci");

    //initialize host command producer
    XHCI_COMMAND_PRODUCER_CYCLE_STATE = 0x1;
    XHCI_COMMAND_PRODUCER_INDEX = 0x0;

    //need to find address and size of xHCI MMIO from PCI header
    PCIHeader0* pci_hdr = $PCIHeader0* addr;
    u64 BAR0 = $u64 pci_hdr->BAR0;
    u64 BAR1 = $u64 pci_hdr->BAR1;
    assert((BAR0 & 0x1) == 0x0, "init_xhci() : make sure this is a memory BAR");
    u64 type = (BAR0 >> 0x1) & 0x3;
    u64 xhci_mmio = 0x0;
    u64 xhci_mmio_size = 0x0;
    if(type == 0x0) {
        // 32-bit 
        xhci_mmio = BAR0 & ~0xF;

        //get size
        pci_hdr->BAR0 = $u32 0xFFFFFFFF;
        u32 mask = pci_hdr->BAR0;
        pci_hdr->BAR0 = $u32 BAR0;
        xhci_mmio_size = $u64 (~(mask & $u32 ~0xF) + $u32 1);
    }
    else if(type == 0x2) {
        // 64-bit
        xhci_mmio = (BAR1 << $u64 32) | (BAR0 & ~0xF);

        //get size
        pci_hdr->BAR0 = $u32 0xFFFFFFFF;
        pci_hdr->BAR1 = $u32 0xFFFFFFFF;
        u32 mask0 = pci_hdr->BAR0;
        u32 mask1 = pci_hdr->BAR1;
        pci_hdr->BAR0 = $u32 BAR0;
        pci_hdr->BAR1 = $u32 BAR1;

        u64 mask = ($u64 mask1 << $u64 32) | ($u64 mask0 & ~0xF);
        xhci_mmio_size = (~mask) + 0x1;
    }
    else panic("init_xhci() : unknown type value");
    assert(xhci_mmio != 0x0, "init_xhci() : xhci mmio base shouldn\'t be 0?");
    assert(xhci_mmio_size != 0x0, "init_xhci() : xhci size should not be 0");

    println("xHCI MMIO size : ", xhci_mmio_size);

    //if xHCI MMIO isn't identity mapped, map it here
    pagetable_t pt = pt_get_current();
    for(u64 i = 0x0; i < xhci_mmio_size; i += PAGE_SIZE) {
        void* vaddr = $void* (xhci_mmio + i);
        pt_map_page_if_not_mapped(pt, vaddr, vaddr, PTE_WRITEABLE | PTE_PCD | PTE_PWT);
    }

    //set bits in command register
    {
        u16 cmd = pci_hdr->command; 
        cmd |= $u16 (1 << 1);   // MSE (memory space enable)
        cmd |= $u16 (1 << 2);   // BME (bus master enable)
        pci_hdr->command = cmd;
    }

    //gather xHCI registers
    xHCI_cap_regs* cap_regs = $xHCI_cap_regs* xhci_mmio;
    u64 rtsoff = $u64 cap_regs->RTSOFF & ~0x1F;
    u64 dboff = $u64 cap_regs->DBOFF & ~0x3;

    xHCI_op_regs* op_regs = $xHCI_op_regs* (xhci_mmio + $u64 cap_regs->CAPLENGTH);
    xHCI_port_regs* port_regs = $xHCI_port_regs* ($u64 op_regs + 0x400);
    xHCI_runtime_regs* runtime_regs = $xHCI_runtime_regs* (xhci_mmio + rtsoff);
    assert(sizeof(xHCI_runtime_regs) == 0x20, "init_xhci() : runtime regs should be size 0x20");
    xHCI_INTRS* interrupters = $xHCI_INTRS* ($u64 runtime_regs + sizeof(xHCI_runtime_regs));
    u32* db_regs = $u32* (xhci_mmio + dboff);

    XHCI_CAP_REGS = cap_regs;
    XHCI_OP_REGS = op_regs;
    XHCI_PORT_REGS = port_regs;
    XHCI_RUNTIME_REGS = runtime_regs;
    XHCI_INTERRUPTERS = interrupters;
    XHCI_DB_REGS = db_regs;

    //only support 64-bit addressing for now
    assert((cap_regs->HCCPARAMS1 & XHCI_HCCPARAMS1_AC64) != $u32 0x0, "init_xhci() : only support 64-bit addressing for now");

    //host controller should not be running currently
    assert((op_regs->USBCMD & XHCI_USBCMD_RS) == $u32 0, "init_xhci() : host controller should not be running");

    //reset host controller
    op_regs->USBCMD |= XHCI_USBCMD_HCRST;
    while(op_regs->USBCMD & XHCI_USBCMD_HCRST) {
        // spin
    }

    //wait until controller is ready
    while(op_regs->USBSTS & XHCI_USBSTS_CNR) {
        // spin
    }

    //alloc stuff for host controller 
    {
        // Device Context Base Address Array
        //256 64-bit pointers = 2048 bytes
        u64 DCBAA_addr = $u64 palloc();
        memset($void* DCBAA_addr, 0, PAGE_SIZE);
        {
            //find max number of scratchpads
            u64 nr_scratch_lo = ($u64 cap_regs->HCSPARAMS2 >> $u64 27) & 0x1F;
            u64 nr_scratch_hi = ($u64 cap_regs->HCSPARAMS2 >> $u64 21) & 0x1F;
            u64 nr_scratch = (nr_scratch_hi << $u64 5) | nr_scratch_lo;
            println("Nr Scratchpads : ", nr_scratch);
            
            //need to alloc scratchpad buffer
            if (nr_scratch != 0x0) {
                assert(nr_scratch <= $u64 512, "init_xhci() : currently can\'t alloc more than 4096 contiguous physical bytes");

                // Scratchpad Buffer Array (SBA)
                u64 sba_addr = $u64 palloc();
                memset($void* sba_addr, 0, PAGE_SIZE);

                // allocate scratchpad buffers and store their physical addresses in SBA
                u64* sba = $u64* sba_addr;
                for (u64 i = 0x0; i < nr_scratch; i++) {
                    u64 buf = $u64 palloc();                       // 4KB scratchpad buffer
                    memset($void* buf, 0, PAGE_SIZE);
                    sba[i] = buf; 
                }

                // DCBAA[0] points to SBA 
                ($u64* DCBAA_addr)[0] = sba_addr;
            }
        }
        op_regs->DCBAAP = DCBAA_addr;

        // Command TRB Ring
        // used by the host to communicate with xHC
        // 256 16-byte TRBs = 4096 bytes
        u64 command_ring_addr = $u64 palloc();
        memset($void* command_ring_addr, 0, PAGE_SIZE);
        {
            //initialize last TRB in command ring as a link TRB pointing back to the start
            xHCI_TRB* link_trb = $xHCI_TRB* (command_ring_addr + PAGE_SIZE - sizeof(xHCI_TRB));
            link_trb->parameter = command_ring_addr;    //point link TRB back to first TRB
            link_trb->status = $u32 0;
            link_trb->control = $u32 (XHCI_TRB_TYPE_LINK << $u32 10) | XHCI_TRB_LINK_TC;    //link TRB should toggle cycle state
        }
        op_regs->CRCR = (command_ring_addr & ~0x3F) | XHCI_CRCR_RCS;    //initialize hardware consumer with cycle=1
        assert(sizeof(xHCI_TRB) == 0x10, "init_xhci() : sizeof(TRB) should be 16");
        XHCI_COMMAND_RING_SIZE = PAGE_SIZE / sizeof(xHCI_TRB);

        // Event TRB Ring + ERST
        // 256 16-byte TRBs = 4096 bytes
        // for now, just allocate one ERST entry
        u64 event_ring_addr = $u64 palloc();
        u64 ERST_addr = $u64 palloc();
        memset($void* event_ring_addr, 0, PAGE_SIZE);
        memset($void* ERST_addr, 0, PAGE_SIZE);
        {
            xHCI_ERST_ent* ents = $xHCI_ERST_ent* ERST_addr;

            //just point first entry to event_ring_addr
            ents[0].ring_segment_base_addr = event_ring_addr;
            ents[0].ring_segment_size = $u16 (PAGE_SIZE / sizeof(xHCI_TRB));

            //point first interrupter to this ERST
            interrupters[0].ERSTSZ = $u32 1;
            interrupters[0].ERSTBA = ERST_addr;
            interrupters[0].ERDP = event_ring_addr;
        }

        //allocate room for event ring consumer state storage
        XHCI_EVENT_RING_PTRS = $u64* palloc();
        XHCI_EVENT_RING_STATES = $u32* palloc();
        memset($void* XHCI_EVENT_RING_PTRS, 0, PAGE_SIZE);
        memset($void* XHCI_EVENT_RING_STATES, 0, PAGE_SIZE);

        //initialize all consumer states to 1
        for(u64 i = 0x0; i * sizeof(u32) < PAGE_SIZE; i++) {
            XHCI_EVENT_RING_STATES[i] = XHCI_TRB_C;
        }

        //set max device slots in CONFIG
        u32 max_slots = cap_regs->HCSPARAMS1 & XHCI_HCSPARAMS1_MAXSLOTS;
        op_regs->CONFIG = (op_regs->CONFIG & ~XHCI_CONFIG_MAXSLOTS) | max_slots;
        println("xHCI Max Slots : ", max_slots);
    }

    //start host controller
    op_regs->USBCMD |= XHCI_USBCMD_RS;
    while(op_regs->USBSTS & XHCI_USBSTS_HCH) {
        // spin
    }

    assert((op_regs->USBSTS & XHCI_USBSTS_HSE) == $u32 0x0, "init_xhci() : should not have error D:");
    

    println("done init xhci");
}
