
// https://wiki.osdev.org/8259_PIC
// 8259 PIC (Programmable Interrupt Controller)
// legacy chip to manage hardware interrupts. 
// replaced by APIC in modern systems

// the 8259 PIC comes as two chips chained together so you can handle 16 IRQ lines instead of 8
// Master handles IRQ0 - IRQ7 and Slave handles IRQ8 - IRQ15
// the Slave is wired into the Master via IRQ2
// when a Slave interrupt happens, it triggers the Master's IRQ2, and the CPU queries both to identify the real IRQ

// IRQ0 : PIT
// IRQ1 : usually keyboard?
// IRQ2 : Cascade for slave

[__GLOBAL_FIRST__] u16 PIC_MASTER_COMMAND   = $u16 0x0020;
[__GLOBAL_FIRST__] u16 PIC_MASTER_DATA      = $u16 0x0021;
[__GLOBAL_FIRST__] u16 PIC_SLAVE_COMMAND    = $u16 0x00a0;
[__GLOBAL_FIRST__] u16 PIC_SLAVE_DATA       = $u16 0x00a1;

// When you enter protected mode (or even before hand, if you're not using GRUB) the first command you will need to give the two PICs is the initialise command (code 0x11). This command makes the PIC wait for 3 extra "initialisation words" on the data port. These bytes give the PIC:
// - Its vector offset on the IDT. (ICW2)
// - Tell it how it is wired to master/slaves. (ICW3)
// - Gives additional information about the environment. (ICW4)
[__GLOBAL_FIRST__] u8 PIC_INIT_CODE     = $u8 0x11;

[__GLOBAL_FIRST__] u8 ICW1_ICW4         = $u8 0x01; // Indicates that ICW4 will be present
[__GLOBAL_FIRST__] u8 ICW1_SINGLE       = $u8 0x02; // Single (cascade) mode
[__GLOBAL_FIRST__] u8 ICW1_INTERVAL4    = $u8 0x04; // Call address interval 4 (8)
[__GLOBAL_FIRST__] u8 ICW1_LEVEL        = $u8 0x08; // Level triggered (edge) mode
[__GLOBAL_FIRST__] u8 ICW1_INIT         = $u8 0x10; // Initialization - required!

[__GLOBAL_FIRST__] u8 ICW4_8086         = $u8 0x01; // 8086/88 (MCS-80/85) mode
[__GLOBAL_FIRST__] u8 ICW4_AUTO         = $u8 0x02; // Auto (normal) EOI
[__GLOBAL_FIRST__] u8 ICW4_BUF_SLAVE    = $u8 0x08; // Buffered mode/slave
[__GLOBAL_FIRST__] u8 ICW4_BUF_MASTER   = $u8 0x0C; // Buffered mode/master
[__GLOBAL_FIRST__] u8 ICW4_SFNM         = $u8 0x10; // Special fully nested (not)
[__GLOBAL_FIRST__] u8 CASCADE_IRQ       = $u8 2; // Slave cascade IRQ

// offset1 - vector offset for master PIC
//     vectors on the master become offset1..offset1+7
// offset2 - same for slave PIC: offset2..offset2+7
[__GLOBAL_FIRST__] u8 ICW2_OFFSET_1     = $u8 0x20; // ICW2: Master PIC vector offset
[__GLOBAL_FIRST__] u8 ICW2_OFFSET_2     = $u8 0x28; // ICW2: Slave PIC vector offset

// for future li andrew, probably want to handle Spurious IRQs
i32 init_pic() {
    println("start init pic");

    //initialize
    outb(PIC_MASTER_COMMAND, PIC_INIT_CODE);
    // io_wait();
    outb(PIC_SLAVE_COMMAND, PIC_INIT_CODE);
    // io_wait();

    //ICW2
    outb(PIC_MASTER_DATA, ICW2_OFFSET_1);
    // io_wait();
    outb(PIC_SLAVE_DATA, ICW2_OFFSET_2);
    // io_wait();

    //ICW3
    outb(PIC_MASTER_DATA, $u8 1 << CASCADE_IRQ); //tell master there is slave pic at IRQ2
    // io_wait();
    outb(PIC_SLAVE_DATA, CASCADE_IRQ); //tell slave its cascade identity
    // io_wait();

    //ICW4, have PICs use 8086 mode
    outb(PIC_MASTER_DATA, ICW4_8086);
    // io_wait();
    outb(PIC_SLAVE_DATA, ICW4_8086);
    // io_wait();

    // set initial PIC masks, only cascade line allowed 
    // which IRQs are allowed to interrupt the CPU? (not set is allowed)
    outb(PIC_MASTER_DATA, $u8 0b11111011);
    outb(PIC_SLAVE_DATA,  $u8 0b11111111);

    // Set masks here
    IRQ_clear_mask($u8 0); // PIT
    IRQ_clear_mask($u8 1); // keyboard

    println("done init pic");
    return 0;
}

void IRQ_set_mask(u8 IRQline) {
    assert(IRQline < $u8 16, "IRQ_set_mask() : IRQline out of bounds");
    u16 port;
    u8 value;

    if(IRQline < $u8 8) {
        port = PIC_MASTER_DATA;
    } else {
        port = PIC_SLAVE_DATA;
        IRQline -= $u8 8;
    }
    value = inb(port) | ($u8 1 << IRQline);
    outb(port, value);
}

void IRQ_clear_mask(u8 IRQline) {
    assert(IRQline < $u8 16, "IRQ_clear_mask() : IRQline out of bounds");
    u16 port;
    u8 value;

    if(IRQline < $u8 8) {
        port = PIC_MASTER_DATA;
    } else {
        port = PIC_SLAVE_DATA;
        IRQline -= $u8 8;
    }
    value = inb(port) & ~($u8 1 << IRQline);
    print("IRQ_clear_mask() : ");
    bitdump(value);
    println();
    outb(port, value);
}

u64 IRQ_to_int_vec(u8 IRQline) {
    return $u64 IRQline + $u64 ICW2_OFFSET_1;
}