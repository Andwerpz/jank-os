
// Physical Memory Allocator
// uses a free list to keep track of userspace memory

[__GLOBAL_FIRST__] phys_page_node* pma_head = $phys_page_node* $u64 -1;
[__GLOBAL_FIRST__] u64 PMA_PAGES_LEFT = 0x0;

struct phys_page_node {
    phys_page_node* prev;
    u8 checksum;    // bitwise xor of all bits should equal 0
}

//find all the memory that is marked as EfiConventionalMemory and mark it as free
i32 init_pma() {
    MMapEnt* mmap = $MMapEnt* @(bootinfo->mmap);
    u64 freepg_cntr = 0x0;

    for(u64 i = 0x0; i < $u64 bootinfo->mmap_entries; i++) {
        u64 base = mmap->base;
        u64 size = mmap->size;
        u64 type = $u64 mmap->type;

        //EFI conventional memory
        if(type == 0x7) {
            u64 pgptr = (base + PAGE_SIZE - 0x1) & ~(PAGE_SIZE - 0x1);
            while(pgptr + PAGE_SIZE <= base + size) {
                freepg_cntr ++;
                pfree($void* pgptr);
                pgptr += PAGE_SIZE;
            }
        }

        mmap = $MMapEnt* ($u64 mmap + $u64 sizeof(MMapEnt));
    }
    
    return 0;
}

//remove the top of the free list and return it
//if we're out of memory, panic
void* palloc() {
    if($u64 pma_head == $u64 -1){
        panic("palloc() : PMA out of memory");
    }

    //check checksum
    u8 checksum = $u8 0;
    for(u64 i = 0x0; i < sizeof(phys_page_node) - 0x1; i++) {
        checksum ^= ($u8* pma_head)[i];
    }
    assert(pma_head->checksum == checksum, "palloc() : checksum failed");

    PMA_PAGES_LEFT --;
    void* ret = $void* pma_head;
    pma_head = pma_head->prev;
    return ret;
}

//just take the page and add it onto the top of the free list
//if the supplied address is not page aligned, panic
void pfree(void* page) {
    if(($u64 page % PAGE_SIZE) != $u64 0) {
        panic("pfree() : address not page aligned");
    }

    PMA_PAGES_LEFT ++;
    phys_page_node* nhead = $phys_page_node* page;
    nhead->prev = pma_head;
    nhead->checksum = $u8 0;
    for(u64 i = 0x0; i < sizeof(phys_page_node) - 0x1; i++) {
        nhead->checksum ^= ($u8* nhead)[i];
    }
    pma_head = nhead;
}