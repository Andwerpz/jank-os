#include "panic.jank";
#include "memlayout.jank";

// Physical Memory Allocator
// uses a free list to keep track of userspace memory

[__GLOBAL_FIRST__] phys_page_node* pma_head = $phys_page_node* $u64 -1;
[__GLOBAL_FIRST__] u64 PMA_PAGES_LEFT = 0x0;

struct phys_page_node {
    phys_page_node* prev;
}

//find all the memory that is marked as MMAP_FREE, and add it to the physical memory allocator. 
//note that above 2MB, there might be a pagetable page every 2MB, so skip those pages to be safe. 
i32 init_pma() {
    print("init_pma\n");

    MMapEnt* mmap = $MMapEnt* @(bootinfo->mmap);
    u64 freepg_cntr = 0x0;

    print("Got MMAP\n");
    println("Ent loc : ", $void* @(bootinfo->mmap_entries));
    println("MMAP entries : ", $void* $u64 bootinfo->mmap_entries);

    for(u64 i = 0x0; i < $u64 bootinfo->mmap_entries; i++) {
        u64 base = mmap->base;
        u64 size = mmap->size;
        u64 type = $u64 mmap->type;

        println("base : ", $void* base);
        println("size : ", $void* size);
        println("type : ", $void* type);
        println("");

        //EFI conventional memory
        if(type == 0x7) {
            u64 pgptr = (base + PAGE_SIZE - 0x1) & ~(PAGE_SIZE - 0x1);
            while(pgptr + PAGE_SIZE <= base + size) {
                freepg_cntr ++;
                pfree($void* pgptr);
                pgptr += PAGE_SIZE;
            }
        }

        mmap = $MMapEnt* ($u64 mmap + $u64 sizeof(MMapEnt));
    }

    print("FREE PAGES : ");
    println($void* freepg_cntr);

    print("done init pma\n");
    return 0;
}

//remove the top of the free list and return it
//if we're out of memory, panic
void* palloc() {
    if($u64 pma_head == $u64 -1){
        panic("palloc() : PMA out of memory");
    }

    PMA_PAGES_LEFT --;
    void* ret = $void* pma_head;
    pma_head = pma_head->prev;
    return ret;
}

//just take the page and add it onto the top of the free list
//if the supplied address is not page aligned, panic
void pfree(void* page) {
    if(($u64 page % PAGE_SIZE) != $u64 0) {
        panic("pfree() : address not page aligned");
    }

    PMA_PAGES_LEFT ++;
    phys_page_node* nhead = $phys_page_node* page;
    nhead->prev = pma_head;
    pma_head = nhead;
}