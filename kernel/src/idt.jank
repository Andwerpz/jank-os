//https://wiki.osdev.org/Interrupt_Descriptor_Table

[__GLOBAL_FIRST__] u8 IST_ATTR_PRESENT          = $u8 0b10000000;   //must be set
[__GLOBAL_FIRST__] u8 IST_ATTR_DPL_KERNEL       = $u8 0b00000000;   //only kernel can directly invoke via 'int' 
[__GLOBAL_FIRST__] u8 IST_ATTR_DPL_USER         = $u8 0b01100000;   //user can directly invoke via 'int'
[__GLOBAL_FIRST__] u8 IST_ATTR_INTERRUPT_GATE   = $u8 0b00001110;   //marks as interrupt gate, will auto clear IF flags on entry
[__GLOBAL_FIRST__] u8 IST_ATTR_TRAP_GATE        = $u8 0b00001111;   //marks as trap gate, will not clear IF flags on entry

struct IDTPointer {
    u16 limit;
    u64 base;
}

struct IDTEntry {
   u16 offset_1;        // offset bits 0..15
   u16 selector;        // a code segment selector in GDT or LDT
   u8  ist;             // bits 0..2 holds Interrupt Stack Table offset, rest of bits zero.
   u8  type_attr;       // gate type, dpl, and p fields
   u16 offset_2;        // offset bits 16..31
   u32 offset_3;        // offset bits 32..63
   u32 zero;            // reserved
}

[__GLOBAL_FIRST__] u64 INTNO_DIVIDE_ERROR       = 0x00;
[__GLOBAL_FIRST__] u64 INTNO_INVALID_OPCODE     = 0x06;
[__GLOBAL_FIRST__] u64 INTNO_INVALID_TSS        = 0x0A;
[__GLOBAL_FIRST__] u64 INTNO_GENERAL_PROTECTION = 0x0D;
[__GLOBAL_FIRST__] u64 INTNO_PAGE_FAULT         = 0x0E;
[__GLOBAL_FIRST__] u64 INTNO_TIMER              = 0x20;

i32 init_idt() {
    serial_println("start init idt");
    pagetable_t kernel_pt = pt_get_current();

    //map page for IDT
    pt_map_page(kernel_pt, $void* IDT_PAGE, palloc(), PTE_WRITEABLE);
    memset($void* IDT_PAGE, 0, PAGE_SIZE);  //clear page
    IDTEntry* idt = $IDTEntry* IDT_PAGE;

    //create IDTPointer
    IDTPointer* idt_ptr = $IDTPointer* malloc(sizeof(IDTPointer));

    //setup IDTPointer
    idt_ptr->limit = $u16 sizeof(IDTEntry) * $u16 256 - $u16 1;
    idt_ptr->base = $u64 idt;    

    //IDT entries
    idt_set_entry(INTNO_PAGE_FAULT, $u64 @page_fault_interrupt_entry_stub, $u16 0x08, $u8 0x0, IST_ATTR_PRESENT | IST_ATTR_DPL_KERNEL | IST_ATTR_TRAP_GATE, idt);
    idt_set_entry(INTNO_TIMER, $u64 @timer_interrupt_entry_stub, $u16 0x08, $u8 0x0, IST_ATTR_PRESENT | IST_ATTR_DPL_KERNEL | IST_ATTR_INTERRUPT_GATE, idt);

    //flush changes
    idt_flush(idt_ptr);

    serial_println("done init idt");
    return 0;
}

void idt_set_entry(u64 idx, u64 handler_addr, u16 selector, u8 ist, u8 type_attr, IDTEntry* idt) {
    idt[idx].offset_1     = $u16 (handler_addr & 0xffff);
    idt[idx].selector     = selector;
    idt[idx].ist          = ist & $u8 0x7;
    idt[idx].type_attr    = type_attr;
    idt[idx].offset_2     = $u16 ((handler_addr >> $u64 16) & 0xffff);
    idt[idx].offset_3     = $u32 ((handler_addr >> $u64 32) & 0xffffffff);
    idt[idx].zero         = $u32 0;
}

void idt_flush(IDTPointer* ptr) {
    asm!("movq {ptr}, %rax");
    asm!("lidt (%rax)");
}

//just here to inject some assembly
[__GLOBAL_FIRST__] extern u8 timer_interrupt_entry_stub;
[__GLOBAL_FIRST__] extern u8 page_fault_interrupt_entry_stub;
void interrupt_entry_stubs() {
    //we need to make sure these things are pushed onto stack before jumping to context handler
    // SS           : from user mode only
    // %rsp         : from user mode only
    // RFLAGS
    // CS
    // %rip
    // error code   : if interrupt doesn't push this itself, this should be 0
    // trap id      : equal to idt entry index

    //page fault
    asm!("page_fault_interrupt_entry_stub:");
    asm!("pushq {INTNO_PAGE_FAULT}");
    asm!("jmp interrupt_handler_entry");

    //timer
    asm!("timer_interrupt_entry_stub:");
    asm!("pushq $0");           // doesn't push error code
    asm!("pushq {INTNO_TIMER}");    
    asm!("jmp interrupt_handler_entry");

    //we should always go to handler
    panic("interrupt_entry_stubs() : should not be here");
}

//this should save context to current active process kernel trapframe
//pass that as argument to dedicated interrupt handler. 
void interrupt_handler() {
    //cpu will have pushed these things onto the stack:
    // SS           : from user mode only
    // %rsp         : from user mode only
    // RFLAGS
    // CS
    // %rip
    // error code   : if interrupt doesn't push this itself, this should be 0
    // trap id      : equal to idt entry index
    
    asm!("interrupt_handler_entry:");

    //check if we are coming from kernel mode
    //we know that at least this is on the stack:
    // RFLAGS
    // CS
    // %rip
    // error code  
    // trap id     
    asm!("pushq %rax");             // save %rax
    asm!("movq 32(%rsp), %rax");    // CS should be at +32 after pushing %rax
    asm!("test $3, %al");           // mask out 0b11
    asm!("jnz .interrupt_from_user"); 
    
    //if we're coming from kernel mode, redo the things that are pushed
    //so we can handle it as if we came from user mode
    asm!("pushq $0x10");            // SS               216
    asm!("lea 56(%rsp), %rax");     // there are 7 things pushed after the execution %rsp
    asm!("pushq %rax");             // %rsp             208
    asm!("pushq 56(%rsp)");         // RFLAGS           200
    asm!("pushq 56(%rsp)");         // CS               192
    asm!("pushq 56(%rsp)");         // %rip             184
    asm!("pushq 56(%rsp)");         // error code       176
    asm!("pushq 56(%rsp)");         // trap id          168
    asm!("movq 56(%rsp), %rax");    // restore %rax
    asm!("jmp .interrupt_trapframe_create");

    //coming from user mode
    asm!(".interrupt_from_user:");
    asm!("popq %rax");              // restore %rax
    asm!("swapgs");                 // swap to kernel GS 

    //create trapframe
    asm!(".interrupt_trapframe_create:");
    asm!("sub $168, %rsp");
    
    asm!("movq %rax,  0(%rsp)");
    asm!("movq %rbx,  8(%rsp)");
    asm!("movq %rcx,  16(%rsp)");
    asm!("movq %rdx,  24(%rsp)");
    asm!("movq %rsi,  32(%rsp)");
    asm!("movq %rdi,  40(%rsp)");
    asm!("movq %rbp,  48(%rsp)");
    asm!("movq 208(%rsp), %rax");
    asm!("movq %rax,  56(%rsp)");
    asm!("movq %r8,   64(%rsp)");
    asm!("movq %r9,   72(%rsp)");
    asm!("movq %r10,  80(%rsp)");
    asm!("movq %r11,  88(%rsp)");
    asm!("movq %r12,  96(%rsp)");
    asm!("movq %r13,  104(%rsp)");
    asm!("movq %r14,  112(%rsp)");
    asm!("movq %r15,  120(%rsp)");
    asm!("movq 184(%rsp), %rax");
    asm!("movq %rax,  128(%rsp)");
    asm!("movq 200(%rsp), %rax");
    asm!("movq %rax,  136(%rsp)");
    asm!("mov %cr3, %rax");
    asm!("movq %rax,  144(%rsp)");
    asm!("movq 192(%rsp), %rax");
    asm!("movq %rax,  152(%rsp)");
    asm!("movq 216(%rsp), %rax");
    asm!("movq %rax,  160(%rsp)");

    //swap to kernel pagetable (need to do this after we save old pagetable)
    asm!("movq %gs:0, %rax");       
    asm!("mov %rax, %cr3");
    
    //send EOI
    //if interrupts were disabled, this shouldn't enable interrupts? 
    //before jumping to interrupt handler, CPU should've cleared interrupt in RFLAGS which this doesn't modify
    asm!("movb $0x20, %al");
    asm!("outb %al, $0x20");

    //gather arguments for high level interrupt handler
    asm!("movq %rsp, %rax");        //%rax now holds trapframe base
    asm!("movq 168(%rsp), %rbx");   //%rbx now holds trap_id
    asm!("movq 176(%rsp), %rcx");   //%rcx now holds error_code

    //go to higher level interrupt disambiguator
    asm!("pushq %rax");         // trapframe* tf
    asm!("pushq %rbx");         // u64 trap_id
    asm!("pushq %rcx");         // u64 error_code
    asm!("call interrupt_handler_disambiguator");

    //disambiguator should not return
    panic("interrupt_handler() : should not be here");
}

export void interrupt_handler_disambiguator(trapframe* tf, u64 trap_id, u64 error_code) {
    if(trap_id == INTNO_PAGE_FAULT) page_fault_handler(tf, error_code);
    if(trap_id == INTNO_TIMER) timer_interrupt_handler(tf);
    panic("interrupt_handler_disambiguator() : should not be here");
}

void page_fault_handler(trapframe* tf, u64 error_code) {
    if(tf->cs & 0x03) { //user mode
        //disable interrupts
        asm!("cli");    

        sout << "user mode page fault handler\n";

        //terminate the offending process
        pid_t pid = get_cur_pid();
        kill_process(pid, 1);

        //jump to scheduler
        scheduler();
    }
    else {              //kernel mode
        sout << "KERNEL MODE PAGE FAULT!!!\n";
        sout << "ERROR CODE : " << $void* error_code << "\n";
        u64 cr2;
        asm!("mov %cr2, %rax");
        asm!("movq %rax, {cr2}");
        sout << "CR2 : " << ($void* cr2) << "\n";
        print_trapframe(tf);
        panic("KERNEL MODE PAGE FAULT!!!\n");
    }
}

//just jump to scheduler
void timer_interrupt_handler(trapframe* tf) {
    scheduler(tf);
}