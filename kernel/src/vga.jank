//ways to improve speed of VGA
// - reading from VGA is very slow (looking at the shift-up operation), should instead keep a parallel copy
//   of the VGA buffer that we can do the shift up, then memcpy it into the VGA buffer
// - can allow the CPU to more aggressively group memory operations by mapping the VGA memory as WC (write-combining)
//   will need to set up the PAT to do this. 
// - look into writing custom assembly for memcpy and memmove operations:
//     rep movsq, rep movsd
//     rep stosq, rep stosd
// - instead of flushing to FB every time we write, have an interrupt fire 60 times a second and flush in the interrupt. 

[__GLOBAL_FIRST__] u32* VGA_FB = $u32* 0xfffffffffc000000;
[VGA] u64 VGA_FB_SCANLINE = $u64 bootinfo->fb_ppsl;
[VGA] u64 VGA_FB_WIDTH = $u64 bootinfo->fb_width;
[VGA] u64 VGA_FB_HEIGHT = $u64 bootinfo->fb_height;

[__GLOBAL_FIRST__] u32 COLOR_WHITE = $u32 0x00ffffff;
[__GLOBAL_FIRST__] u32 COLOR_BLACK = $u32 0x00000000;
[__GLOBAL_FIRST__] u32 COLOR_GRAY = $u32 0x00aaaaaa;

[__GLOBAL_FIRST__] extern u8 _binary_font_psf_start;

[__GLOBAL_FIRST__] vga_scroll_buffer* VGA_KERNEL_SCROLL_BUFFER;
[__GLOBAL_FIRST__] vga_scroll_buffer* VGA_USER_SCROLL_BUFFER;

struct psf_header {
    u32 magic;
    u32 version;
    u32 headersize;
    u32 flags;
    u32 numglyph;
    u32 bytesperglyph;
    u32 height;
    u32 width;
    u8 glyphs;  //glyph starting byte
}

[__GLOBAL_FIRST__] i32 VGA_DID_INIT = 0;
void init_vga() {
    //set VGA framebuffer MMIO to be WC
    {
        u64 ptr = $u64 VGA_FB;
        pagetable_t pt = pt_get_current();
        assert((ptr % PAGE_SIZE) == 0x0, "init_vga() : expect VGA FB to be page-aligned");
        for(u64 i = 0x0; i < sizeof(u32) * VGA_FB_SCANLINE * VGA_FB_HEIGHT; i += PAGE_SIZE) {
            void* vaddr = $void* (ptr + i);
            pt_set_leaf_flags(pt, vaddr, pte_pat_bits(PAT_WC) | PTE_WRITEABLE);
        }
    }

    //allocate user and kernel staging buffers
    VGA_KERNEL_SCROLL_BUFFER = $vga_scroll_buffer* malloc(sizeof(vga_scroll_buffer));
    VGA_USER_SCROLL_BUFFER = $vga_scroll_buffer* malloc(sizeof(vga_scroll_buffer));
    if(DEBUG_MODE) {
        new (VGA_KERNEL_SCROLL_BUFFER) vga_scroll_buffer(VGA_FB_WIDTH / 0x2, VGA_FB_WIDTH / 0x2);
        new (VGA_USER_SCROLL_BUFFER) vga_scroll_buffer(VGA_FB_WIDTH / 0x2, 0x0);
    }
    else {
        new (VGA_KERNEL_SCROLL_BUFFER) vga_scroll_buffer(VGA_FB_WIDTH, 0x0);
        new (VGA_USER_SCROLL_BUFFER) vga_scroll_buffer(VGA_FB_WIDTH, 0x0);
    }


    VGA_DID_INIT = 1;
    println("done init vga");
}

[__GLOBAL_FIRST__] u64 VGA_DEBUG_CURSOR_COL = 0x0;
[__GLOBAL_FIRST__] u64 VGA_DEBUG_CURSOR_ROW = 0x0;
void vga_debug_draw_char(u8 c) {
    assert(VGA_DID_INIT, "vga_debug_draw_char() : vga needs to be initialized");
    psf_header* font = $psf_header* @_binary_font_psf_start;
    if(c == '\n') {
        VGA_DEBUG_CURSOR_COL = 0x0;
        VGA_DEBUG_CURSOR_ROW ++;
        if(VGA_DEBUG_CURSOR_ROW == (VGA_FB_HEIGHT / $u64 font->height)) {
            VGA_KERNEL_SCROLL_BUFFER->shift_up($u64 font->height);
            VGA_DEBUG_CURSOR_ROW --;
        }

        if(!SCHEDULER_STARTED) {
            VGA_KERNEL_SCROLL_BUFFER->flush();
        }
    }
    else {  
        VGA_KERNEL_SCROLL_BUFFER->draw_char(VGA_DEBUG_CURSOR_COL * $u64 font->width, VGA_DEBUG_CURSOR_ROW * $u64 font->height, c, COLOR_BLACK, COLOR_WHITE);
        VGA_DEBUG_CURSOR_COL ++;
        if(VGA_DEBUG_CURSOR_COL == (VGA_KERNEL_SCROLL_BUFFER->width / $u64 font->width)) {
            VGA_DEBUG_CURSOR_ROW ++;
            VGA_DEBUG_CURSOR_COL = 0x0;
        }
        if(VGA_DEBUG_CURSOR_ROW == (VGA_FB_HEIGHT / $u64 font->height)) {
            VGA_KERNEL_SCROLL_BUFFER->shift_up($u64 font->height);
            VGA_DEBUG_CURSOR_ROW --;
        }
    }
}

//flush whatever is in the staging buffers into the actual VGA framebuffer
void vga_flush() {
    assert(VGA_DID_INIT, "vga_flush() : need init vga to complete");
    VGA_USER_SCROLL_BUFFER->flush();
    if(DEBUG_MODE || !SCHEDULER_STARTED) VGA_KERNEL_SCROLL_BUFFER->flush();
}

//just invert the 3 least significant octets
u32 vga_invert_color(u32 color) {
    return color ^ $u32 0x00FFFFFF;
}

// -- VGA SCROLL BUFFER -- 
//owns a contiguous horizontal section of the screen
struct vga_scroll_buffer {
    u64 width; 
    u64 offset;         //horizontal offset from left
    u64 height;         //total height of the scroll buffer
    u32* buf;
    u64 line_offset;    //logical start of the screen within the scroll buffer

    vga_scroll_buffer() {
        panic("vga_scroll_buffer() : no use default constructor");
    }

    vga_scroll_buffer(u64 width, u64 offset) {
        assert(width + offset <= VGA_FB_WIDTH, "vga_scroll_buffer() : buffer going offscreen");
        assert(width > 0x0, "vga_scroll_buffer() : can\'t have buffer with 0 width");
        this.width = width;
        this.offset = offset;
        this.height = VGA_FB_HEIGHT * ($u64 16);
        this.buf = $u32* malloc(sizeof(u32) * this.width * this.height);
        memset($void* this.buf, 0, sizeof(u32) * this.width * this.height);
        this.line_offset = 0x0;
    }

    ~vga_scroll_buffer() {
        free($void* this.buf, sizeof(u32) * this.width * this.height);
    }

    void shift_down(u64 lines) {
        assert(lines <= VGA_FB_HEIGHT, "vga_scroll_buffer::shift_down() : shift too large");

        //do shift
        if(this.line_offset >= lines) this.line_offset -= lines;
        else this.line_offset = this.line_offset - lines + this.height;

        //clear top lines
        this.clear_lines(0x0, lines);
    }
    
    void shift_up(u64 lines) {
        assert(lines <= VGA_FB_HEIGHT, "vga_scroll_buffer::shift_up() : shift too large");

        //do shift
        this.line_offset = (this.line_offset + lines) % this.height;

        //clear bottom lines
        this.clear_lines(VGA_FB_HEIGHT - lines, VGA_FB_HEIGHT);
    }

    void clear_lines(u64 start, u64 end) {
        assert(start < end, "vga_scroll_buffer::clear_lines() : start must be <= end");
        assert(end <= VGA_FB_HEIGHT, "vga_scroll_buffer::clear_lines() : end out of bounds");
        start = (start + this.line_offset) % this.height;
        end = (end + this.line_offset) % this.height;

        if(start < end) {
            //no wrap
            memset($void* @(this.buf[start * this.width]), 0, sizeof(u32) * (end - start) * this.width);
        }
        else {
            //wrap
            memset($void* @(this.buf[start * this.width]), 0, sizeof(u32) * (this.height - start) * this.width);
            memset($void* this.buf, 0, sizeof(u32) * end * this.width);
        }
    }

    void clear_screen() {
        this.clear_lines(0x0, VGA_FB_HEIGHT);
    }

    void draw_pixel(u64 x, u64 y, u32 color) {
        this.buf[this.width * ((this.line_offset + y) % this.height) + x] = color;
    }

    void draw_char(u64 x, u64 y, u8 c, u32 bg_col, u32 fg_col) {
        psf_header* font = $psf_header* @_binary_font_psf_start;
        assert(x + $u64 font->width <= this.width && y + $u64 font->height <= VGA_FB_HEIGHT, "vga_scroll_buffer::draw_char() : glyph out of bounds");
        u64 bpl = ($u64 font->width + $u64 7) / $u64 8;
        u8* glyph = $u8* ($u64 font + $u64 font->headersize + $u64 font->bytesperglyph * $u64 c);
        for(i32 j = 0; j < $i32 font->height; j++){
            u64 line = ($u64* @(glyph[bpl * $u64 j]))[0];
            for(i32 i = 0; i < $i32 font->width; i++){
                if(line & ($u64 1 << ($u64 font->width - $u64 1 - $u64 i))) {
                    //foreground
                    this.buf[this.width * ((this.line_offset + y + $u64 j) % this.height) + x + $u64 i] = fg_col;
                }
                else {
                    //background
                    this.buf[this.width * ((this.line_offset + y + $u64 j) % this.height) + x + $u64 i] = bg_col;
                }
            }
        }
    }

    //flushes the contents of this buffer to the VGA FB
    void flush() {
        for(u64 i = 0x0; i < VGA_FB_HEIGHT; i++) {
            memcpy(
                $void* ($u64 VGA_FB + sizeof(u32) * (VGA_FB_SCANLINE * i + this.offset)), 
                $void* @(this.buf[((this.line_offset + i) % this.height) * this.width]), 
                sizeof(u32) * this.width
            );
        }
    }
}


// -- ANSI PARSER --
[__GLOBAL_FIRST__] u64 TERMINAL_PARSE_BUF_SIZE = $u64 128;
[__GLOBAL_FIRST__] u8 TERMINAL_ESC = $u8 0x1B;  // also written as \x1B

[__GLOBAL_FIRST__] u64 TERMINAL_STATE_INVALID           = 0x0;
[__GLOBAL_FIRST__] u64 TERMINAL_STATE_ENTRY             = 0x1;
[__GLOBAL_FIRST__] u64 TERMINAL_STATE_ESC               = 0x2;          // ESC
[__GLOBAL_FIRST__] u64 TERMINAL_STATE_CSI               = 0x3;          // ESC[             (control sequence introducer)

struct ansi_parse_state {
    u64 state;
    vector<u64> params;
    u8[128] buf;
    u64 bptr;
}

//flush buffer of chars in finite state machine to be drawn
//sets parse state to TERMINAL_STATE_ENTRY
void ansi_parser_flush_buf(ansi_parse_state& state, vga_terminal* term) {
    assert(state.bptr <= TERMINAL_PARSE_BUF_SIZE, "ansi_parser_flush_buf() : ideally, buffer should not overflow");
    for(u64 i = 0x0; i < state.bptr; i++) {
        u8 c = state.buf[i];
        if(c == TERMINAL_ESC) {
            vga_terminal_draw_string(term, "\\x1B");
        }
        else if(c >= ($u8 0x20) && c <= ($u8 0x7E)){
            //printable characters
            vga_terminal_draw_char(term, c);
        }
    }
    ansi_parser_reset_state(state);
}

//empties the terminal parse buffer without drawing
//sets parse state to TERMINAL_STATE_ENTRY
void ansi_parser_reset_state(ansi_parse_state& state) {
    state.params.clear();
    state.bptr = 0x0;
    state.state = TERMINAL_STATE_ENTRY;
}

void ansi_parser_buf_append(ansi_parse_state& state, u8 c) {
    assert(state.bptr < TERMINAL_PARSE_BUF_SIZE, "ansi_parser_buf_append() : parse buffer overflowed");
    state.buf[state.bptr ++] = c;
}

//finite state machine parser to handle one char at a time
void ansi_parser_accept_char(vga_terminal* term, u8 c) {
    ansi_parse_state& state = term->parse_state;
    if(state.state == TERMINAL_STATE_ENTRY) {
        if(c == TERMINAL_ESC) {
            //ANSI escape sequence start
            ansi_parser_buf_append(state, c);
            state.state = TERMINAL_STATE_ESC;
        }
        else if(c == '\n') {
            //newline, increment cursor row
            vga_terminal_inc_cursor_row(term);
        }
        else if(c == '\r') {
            //carriage return, set cursor back to beginning
            vga_terminal_set_cursor_col(term, 0x0);
        }
        else if(c == '\b') {
            //backspace, decrement cursor col if it's not at the beginning of the line
            if(term->cursor_col != 0x0) {
                vga_terminal_set_cursor_col(term, term->cursor_col - 0x1);
            }
        }
        else if(c <= $u8 0x1F) {
            //no-op control char
            vga_terminal_draw_char(term, '^');
            vga_terminal_draw_char(term, c + $u8 0x40);
        }
        else if(c == $u8 0x7F) {
            //DEL char
            vga_terminal_draw_string(term, "DEL");
        }
        else if(c >= ($u8 0x20) && c <= ($u8 0x7E)){
            //just print it
            vga_terminal_draw_char(term, c);
        }
    }
    else if(state.state == TERMINAL_STATE_ESC) {
        ansi_parser_buf_append(state, c);
        if(c == '[') {
            state.state = TERMINAL_STATE_CSI;
        }
        else ansi_parser_flush_buf(state, term);
    }
    else if(state.state == TERMINAL_STATE_CSI) {
        ansi_parser_buf_append(state, c);
        //only support CSI sequences that are a bunch of semicolon separated numbers followed by a latin character
        if('0' <= c && c <= '9') {
            //just append to buffer
            return;
        }
        else if(state.buf[state.bptr - 0x2] != '[') {
            //separator, see if we can parse previous number
            if(!('0' <= state.buf[state.bptr - 0x2] && state.buf[state.bptr - 0x2] <= '9')) {
                //there is no number
                ansi_parser_flush_buf(state, term);
                return;
            }

            i32 valid = 1;
            u64 val = 0x0;
            u64 sptr;
            for(u64 i = state.bptr - 0x2; ; i--) {
                if(state.buf[i] == ';' || state.buf[i] == '[') {
                    sptr = i;
                    break;
                }
            }
            for(u64 i = sptr + 0x1; i < state.bptr - 0x1; i++) {
                u8 dig = state.buf[i];
                if(!('0' <= dig && dig <= '9')) {
                    valid = 0;
                    break;
                }
                val = (val * $u64 10) + $u64 (dig - '0');
            }
            if(valid) state.params.push_back(val);
            else {
                ansi_parser_flush_buf(state, term);
                return;
            }
        }

        if(c != ';') {
            //sequence terminator
            //figure out what sequence these parameters correspond to
            i32 found_seq = 0;
            if(state.params.size() == 0x0) {
                if(c == 'A') {          // ESC[A : up arrow
                    if(term->cursor_row != 0x0) vga_terminal_set_cursor_row(term, term->cursor_row - 0x1);
                    found_seq = 1;
                }
                else if(c == 'B') {     // ESC[B : down arrow
                    vga_terminal_inc_cursor_row(term);
                    found_seq = 1;
                }
                else if(c == 'C') {     // ESC[C : right arrow
                    vga_terminal_inc_cursor_col(term);
                    found_seq = 1;
                }
                else if(c == 'D') {     // ESC[D : left arrow
                    if(term->cursor_col != 0x0) vga_terminal_set_cursor_col(term, term->cursor_col - 0x1);
                    found_seq = 1;
                }
                else if(c == 'H') {     // ESC[H : moves cursor to origin (0, 0)
                    vga_terminal_set_cursor_pos(term, 0x0, 0x0);
                    found_seq = 1;
                }
            }
            else if(state.params.size() == 0x1) {
                u64 n1 = state.params[0];
                if(n1 == 0x2 && c == 'J') {   // ESC[2J : erase entire screen
                    vga_terminal_clear_screen(term);
                    found_seq = 1;
                }
                else if(n1 == 0x6 && c == 'n') {   // ESC[6n : report cursor position as ESC[<row>;<col>R
                    assert(term->tty != nullptr, "ansi_parser_accept_char() : tty should not be null");
                    string msg;
                    msg.push_back(TERMINAL_ESC);
                    msg.push_back('[');
                    msg += to_string(term->cursor_row + 0x1);
                    msg.push_back(';');
                    msg += to_string(term->cursor_col + 0x1);
                    msg.push_back('R');
                    if($u64 tty_accept_input(term->tty, msg.jstr(), msg.size()) != msg.size()) {
                        panic("ansi_parser_accept_char() : this should succeed");
                    }
                    found_seq = 1;
                }
                else if(n1 == 0x0 && c == 'm') {    // ESC[0m : resets all modes (color + style)
                    term->fg_color = COLOR_WHITE;
                    term->bg_color = COLOR_BLACK;
                    found_seq = 1;
                }
            }
            else if(state.params.size() == 0x2) {
                u64 n1 = state.params[0];
                u64 n2 = state.params[1];
                if(c == 'H' || c == 'f') {  // ESC[{line};{column}H ESC[{line};{column}f : set cursor position
                    //row and column are given as 1-indexed, convert to 0-indexed
                    n1 --;
                    n2 --;
                    //clamp to grid
                    n1 = max(n1, 0x0);
                    n2 = max(n2, 0x0);
                    n1 = min(n1, term->grid_rows - 0x1);
                    n2 = min(n2, term->grid_cols - 0x1);
                    //set cursor pos
                    vga_terminal_set_cursor_pos(term, n1, n2);
                    found_seq = 1;
                }   
            }
            else if(state.params.size() == 0x5) {   
                u64 n1 = state.params[0];
                u64 n2 = state.params[1];
                u64 n3 = state.params[2];
                u64 n4 = state.params[3];
                u64 n5 = state.params[4];
                if(n1 == $u64 38 && n2 == $u64 2 && c == 'm') { // ESC[38;2;{r};{g};{b}m : set foreground color RGB
                    //set foreground color
                    n3 = min(n3, 0xFF);
                    n4 = min(n4, 0xFF);
                    n5 = min(n5, 0xFF);
                    term->fg_color = $u32 ((n3 << $u64 16) | (n4 << $u64 8) | (n5 << $u64 0));
                    found_seq = 1;
                }
                else if(n1 == $u64 48 && n2 == $u64 2 && c == 'm') { // ESC[48;2;{r};{g};{b}m : set background color RGB
                    //set background color
                    n3 = min(n3, 0xFF);
                    n4 = min(n4, 0xFF);
                    n5 = min(n5, 0xFF);
                    term->bg_color = $u32 ((n3 << $u64 16) | (n4 << $u64 8) | (n5 << $u64 0));
                    found_seq = 1;
                }
            }

            if(!found_seq) {
                ansi_parser_flush_buf(state, term);
            }
            else ansi_parser_reset_state(state);
        }
    }
    else panic("ansi_parser_accept_char() : invalid parse state");
}


// -- VGA TERMINAL --
struct vga_cell {
    u8 char;
    u32 fg_color;
    u32 bg_color;
}

struct vga_terminal {
    tty* tty;

    ansi_parse_state parse_state;

    u64 grid_rows;
    u64 grid_cols;

    u64 cursor_row;
    u64 cursor_col;

    //set to 1 when we write a printable character on the last column
    //if wrap_pending and we're trying to write a printable character, should wrap then write character
    //if wrap_pending and we're trying to do some other action that moves the cursor, clear wrap_pending
    i32 wrap_pending;   

    //active colors
    u32 fg_color;
    u32 bg_color;

    vga_cell* cells;

    vga_terminal() {
        this.tty = $tty* nullptr;

        psf_header* font = $psf_header* @_binary_font_psf_start;
        this.parse_state.state = TERMINAL_STATE_ENTRY;
        this.parse_state.bptr = 0x0;
        this.grid_rows = $u64 VGA_FB_HEIGHT / $u64 font->height;
        this.grid_cols = $u64 VGA_USER_SCROLL_BUFFER->width / $u64 font->width;
        this.cursor_row = 0x0;
        this.cursor_col = 0x0;
        this.wrap_pending = 0;
        this.fg_color = COLOR_WHITE;
        this.bg_color = COLOR_BLACK;

        //initialize cells
        this.cells = $vga_cell* malloc(sizeof(vga_cell) * this.grid_rows * this.grid_cols);
        for(u64 i = 0x0; i < this.grid_rows * this.grid_cols; i++) {
            this.cells[i].char = ' ';
            this.cells[i].fg_color = COLOR_WHITE;
            this.cells[i].bg_color = COLOR_BLACK;
        }
    }

    ~vga_terminal() {
        free($void* this.cells, sizeof(vga_cell) * this.grid_rows * this.grid_cols);
    }
}

//clears grid, sets all pixels to black
void vga_terminal_clear_screen(vga_terminal* term) {
    for(u64 i = 0x0; i < term->grid_rows * term->grid_cols; i++) {
        vga_cell* cell = @(term->cells[i]);
        cell->char = ' ';
    }
    VGA_USER_SCROLL_BUFFER->clear_screen();
}

//scrolls the terminal up one row, makes the bottom row empty
//doesn't move the cursor
void vga_terminal_scroll_up(vga_terminal* term) {
    //grid scroll
    {
        vga_cell* dst = term->cells;
        vga_cell* src = @(dst[term->grid_cols]);
        memmove($void* dst, $void* src, sizeof(vga_cell) * (term->grid_rows - 0x1) * term->grid_cols);

        for(u64 i = 0x0; i < term->grid_cols; i++) {
            vga_cell* cell = @(term->cells[(term->grid_rows - 0x1) * term->grid_cols + i]);
            cell->char = ' ';
        }
    }

    //visual scroll
    psf_header* font = $psf_header* @_binary_font_psf_start;
    VGA_USER_SCROLL_BUFFER->shift_up($u64 font->height);
}

//if col is outside the grid, wraps it around
//if row is outside the grid, scrolls screen up by one row and moves row back up one
void vga_terminal_set_cursor_pos(vga_terminal* term, u64 row, u64 col) {
    assert(col <= term->grid_cols, "vga_terminal_set_cursor_pos() : col should at most be one outside of grid");
    if(col == term->grid_cols) {
        col = 0x0;
        row ++;
    }
    assert(row <= term->grid_rows, "vga_terminal_set_cursor_pos() : row should at most be one outside of grid");
    if(row == term->grid_rows) {
        row --;
        vga_terminal_scroll_up(term);
    }
    term->cursor_row = row;
    term->cursor_col = col;
    term->wrap_pending = 0;     //unset wrap pending whenever the cursor moves
}

void vga_terminal_set_cursor_row(vga_terminal* term, u64 row) {
    vga_terminal_set_cursor_pos(term, row, term->cursor_col);
}

void vga_terminal_set_cursor_col(vga_terminal* term, u64 col) {
    vga_terminal_set_cursor_pos(term, term->cursor_row, col);
}

void vga_terminal_inc_cursor_row(vga_terminal* term) {
    vga_terminal_set_cursor_row(term, term->cursor_row + 0x1);
}

void vga_terminal_inc_cursor_col(vga_terminal* term) {
    vga_terminal_set_cursor_col(term, term->cursor_col + 0x1);
}

//draws character onto screen at cursor position, updates cursor position
//does default cursor movement (increments cursor col)
void vga_terminal_draw_char(vga_terminal* term, u8 c) {
    //handle wrapping
    if(term->wrap_pending) {
        assert(term->cursor_col + 0x1 == term->grid_cols, "vga_terminal_draw_char() : wrap_pending should only be set when the cursor is in last column");
        vga_terminal_inc_cursor_col(term);
    }

    //draw char
    psf_header* font = $psf_header* @_binary_font_psf_start;
    u64 x = term->cursor_col * $u64 font->width;
    u64 y = term->cursor_row * $u64 font->height;
    VGA_USER_SCROLL_BUFFER->draw_char(x, y, c, term->bg_color, term->fg_color);

    //update grid cell
    vga_cell* cell = @(term->cells[term->cursor_row * term->grid_cols + term->cursor_col]);
    cell->char = c;

    //update cursor
    if(term->cursor_col + 0x1 == term->grid_cols) {
        //arm next character to wrap
        term->wrap_pending = 1;
    }
    else {
        //move cursor right
        vga_terminal_inc_cursor_col(term);
    }      
}

void vga_terminal_draw_string(vga_terminal* term, u8* str) {
    u64 len = strlen(str);
    for(u64 i = 0x0; i < len; i++) {
        vga_terminal_draw_char(term, str[i]);
    }
}

void vga_terminal_accept_str(vga_terminal* term, u8* buf, u64 amt) {
    //de-render cursor
    {
        psf_header* font = $psf_header* @_binary_font_psf_start;    
        vga_cell& cell = term->cells[term->cursor_row * term->grid_cols + term->cursor_col];
        u8 c = cell.char;
        u32 bg_color = cell.bg_color;
        u32 fg_color = cell.fg_color;
        u64 x = term->cursor_col * $u64 font->width;
        u64 y = term->cursor_row * $u64 font->height;
        VGA_USER_SCROLL_BUFFER->draw_char(
            x, y, c, 
            bg_color, fg_color
        );
    }

    //accept all chars
    for(u64 i = 0x0; i < amt; i++) {
        ansi_parser_accept_char(term, buf[i]);
    }

    //render cursor
    {
        psf_header* font = $psf_header* @_binary_font_psf_start;
        vga_cell& cell = term->cells[term->cursor_row * term->grid_cols + term->cursor_col];
        u8 c = cell.char;
        u32 bg_color = cell.bg_color;
        u32 fg_color = cell.fg_color;
        u64 x = term->cursor_col * $u64 font->width;
        u64 y = term->cursor_row * $u64 font->height;
        VGA_USER_SCROLL_BUFFER->draw_char(
            x, y, c, 
            vga_invert_color(bg_color), vga_invert_color(fg_color)
        );
    }
}

[__GLOBAL_FIRST__] tty_backend_ops* TTY_BACKEND_OPS_VGA;
void init_vga_tty_backend_ops() {
    TTY_BACKEND_OPS_VGA = $tty_backend_ops* malloc(sizeof(tty_backend_ops));
    new (TTY_BACKEND_OPS_VGA) tty_backend_ops();
    TTY_BACKEND_OPS_VGA->op_accept_input = #<vga_accept_input(tty*, u8*, u64)>;
    TTY_BACKEND_OPS_VGA->op_close = #<vga_close(tty*)>;
    TTY_BACKEND_OPS_VGA->op_get_winsize = #<vga_get_winsize(tty*, winsize*)>;
}

i64 vga_accept_input(tty* tty, u8* buf, u64 amt) {
    vga_terminal* term = $vga_terminal* tty->backend;
    vga_terminal_accept_str(term, buf, amt);
    return $i64 amt;
}

i32 vga_close(tty* tty) {
    //free terminal struct
    vga_terminal* term = $vga_terminal* tty->backend;
    term->~();
    return 0;
}

i32 vga_get_winsize(tty* tty, winsize* out_winsize) {
    vga_terminal* term = $vga_terminal* tty->backend;
    out_winsize->ws_row = $u16 term->grid_rows;
    out_winsize->ws_col = $u16 term->grid_cols;
    out_winsize->ws_xpixel = $u16 0;
    out_winsize->ws_ypixel = $u16 0;
    return 0;
}
