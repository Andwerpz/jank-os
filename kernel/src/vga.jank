//ways to improve speed of VGA
// - reading from VGA is very slow (looking at the shift-up operation), should instead keep a parallel copy
//   of the VGA buffer that we can do the shift up, then memcpy it into the VGA buffer
// - can allow the CPU to more aggressively group memory operations by mapping the VGA memory as WC (write-combining)
//   will need to set up the PAT to do this. 
// - look into writing custom assembly for memcpy and memmove operations:
//     rep movsq, rep movsd
//     rep stosq, rep stosd
// - instead of flushing to FB every time we write, have an interrupt fire 60 times a second and flush in the interrupt. 

[__GLOBAL_FIRST__] u32* VGA_FB = $u32* 0xfffffffffc000000;
[VGA] u64 VGA_FB_SCANLINE = $u64 bootinfo->fb_ppsl;
[VGA] u64 VGA_FB_WIDTH = $u64 bootinfo->fb_width;
[VGA] u64 VGA_FB_HEIGHT = $u64 bootinfo->fb_height;

[__GLOBAL_FIRST__] u32 COLOR_WHITE = $u32 0x00ffffff;
[__GLOBAL_FIRST__] u32 COLOR_BLACK = $u32 0x00000000;
[__GLOBAL_FIRST__] u32 COLOR_GRAY = $u32 0x00aaaaaa;

[__GLOBAL_FIRST__] extern u8 _binary_font_psf_start;

[__GLOBAL_FIRST__] u32* VGA_STAGING_BUF = $u32* nullptr;
[__GLOBAL_FIRST__] u64 VGA_STAGING_LINE_OFF;
[__GLOBAL_FIRST__] u64 VGA_STAGING_HEIGHT;

struct psf_header {
    u32 magic;
    u32 version;
    u32 headersize;
    u32 flags;
    u32 numglyph;
    u32 bytesperglyph;
    u32 height;
    u32 width;
    u8 glyphs;  //glyph starting byte
}

[__GLOBAL_FIRST__] i32 VGA_DID_INIT = 0;
void init_vga() {
    //set VGA framebuffer MMIO to be WC
    {
        u64 ptr = $u64 VGA_FB;
        pagetable_t pt = pt_get_current();
        assert((ptr % PAGE_SIZE) == 0x0, "init_vga() : expect VGA FB to be page-aligned");
        for(u64 i = 0x0; i < sizeof(u32) * VGA_FB_SCANLINE * VGA_FB_HEIGHT; i += PAGE_SIZE) {
            void* vaddr = $void* (ptr + i);
            pt_set_leaf_flags(pt, vaddr, pte_pat_bits(PAT_WC) | PTE_WRITEABLE);
        }
    }

    //allocate staging buffer
    VGA_STAGING_HEIGHT = VGA_FB_HEIGHT * $u64 16;
    VGA_STAGING_LINE_OFF = 0x0;
    VGA_STAGING_BUF = $u32* malloc(sizeof(u32) * VGA_FB_SCANLINE * VGA_STAGING_HEIGHT);

    //copy everything from current FB to staging buffer
    memcpy($void* VGA_STAGING_BUF, $void* VGA_FB, sizeof(u32) * VGA_FB_SCANLINE * VGA_FB_HEIGHT);

    VGA_DID_INIT = 1;
    println("done init vga");
}

[__GLOBAL_FIRST__] u64 VGA_DEBUG_CURSOR_COL = 0x0;
[__GLOBAL_FIRST__] u64 VGA_DEBUG_CURSOR_ROW = 0x0;
void vga_debug_draw_char(u8 c) {
    assert(VGA_DID_INIT, "vga_debug_draw_char() : vga needs to be initialized");
    psf_header* font = $psf_header* @_binary_font_psf_start;
    if(c == '\n') {
        VGA_DEBUG_CURSOR_COL = 0x0;
        VGA_DEBUG_CURSOR_ROW ++;
        if(VGA_DEBUG_CURSOR_ROW == (VGA_FB_HEIGHT / $u64 font->height)) {
            vga_shift_up($u64 font->height);
            VGA_DEBUG_CURSOR_ROW --;
        }
        vga_flush();
    }
    else {  
        vga_draw_char(VGA_DEBUG_CURSOR_COL * $u64 font->width, VGA_DEBUG_CURSOR_ROW * $u64 font->height, c, COLOR_BLACK, COLOR_WHITE);
        VGA_DEBUG_CURSOR_COL ++;
    }
}

//flush whatever is in the staging buffer into the actual VGA buffer
void vga_flush() {
    assert(VGA_STAGING_LINE_OFF < VGA_STAGING_HEIGHT, "vga_flush() : invalid staging offset");
    if(VGA_STAGING_LINE_OFF + VGA_FB_HEIGHT > VGA_STAGING_HEIGHT) {
        // wrapping
        u64 bef_wrap = VGA_STAGING_HEIGHT - VGA_STAGING_LINE_OFF;
        memcpy($void* VGA_FB, $void* (@VGA_STAGING_BUF[VGA_STAGING_LINE_OFF * VGA_FB_SCANLINE]), sizeof(u32) * VGA_FB_SCANLINE * bef_wrap);
        memcpy($void* @(VGA_FB[bef_wrap * VGA_FB_SCANLINE]), $void* VGA_STAGING_BUF, sizeof(u32) * VGA_FB_SCANLINE * (VGA_FB_HEIGHT - bef_wrap));
    }
    else {
        // no wrap
        memcpy($void* VGA_FB, $void* @(VGA_STAGING_BUF[VGA_STAGING_LINE_OFF * VGA_FB_SCANLINE]), sizeof(u32) * VGA_FB_SCANLINE * VGA_FB_HEIGHT);
    }
}

void vga_draw_pixel(u64 x, u64 y, u32 color) {
    VGA_STAGING_BUF[VGA_FB_SCANLINE * ((VGA_STAGING_LINE_OFF + y) % VGA_STAGING_HEIGHT) + x] = color;
}

//top left corner positioned at (x, y)
//the bits within each byte are big endian, but the bytes themselves are little endian. 
void vga_draw_char(u64 x, u64 y, u8 c, u32 bg_col, u32 fg_col) {
    psf_header* font = $psf_header* @_binary_font_psf_start;
    u64 bpl = ($u64 font->width + $u64 7) / $u64 8;
    u8* glyph = $u8* ($u64 font + $u64 font->headersize + $u64 font->bytesperglyph * $u64 c);
    for(i32 j = 0; j < $i32 font->height; j++){
        u64 line = ($u64* @(glyph[bpl * $u64 j]))[0];
        for(i32 i = 0; i < $i32 font->width; i++){
            if(line & ($u64 1 << ($u64 font->width - $u64 1 - $u64 i))) {
                //foreground
                vga_draw_pixel(x + $u64 i, y + $u64 j, fg_col);
            }
            else {
                //background
                vga_draw_pixel(x + $u64 i, y + $u64 j, bg_col);
            }
        }
    }
}

void vga_clear_lines(u64 start, u64 end) {
    assert(start < end, "vga_clear_lines() : start must be <= end");
    assert(end <= VGA_FB_HEIGHT, "vga_clear_lines() : end out of bounds");
    start = (start + VGA_STAGING_LINE_OFF) % VGA_STAGING_HEIGHT;
    end = (end + VGA_STAGING_LINE_OFF) % VGA_STAGING_HEIGHT;

    if(start < end) {
        //no wrap
        memset($void* @(VGA_STAGING_BUF[start * VGA_FB_SCANLINE]), 0, sizeof(u32) * (end - start) * VGA_FB_SCANLINE);
    }
    else {
        //wrap
        memset($void* @(VGA_STAGING_BUF[start * VGA_FB_SCANLINE]), 0, sizeof(u32) * (VGA_STAGING_HEIGHT - start) * VGA_FB_SCANLINE);
        memset($void* VGA_STAGING_BUF, 0, sizeof(u32) * end * VGA_FB_SCANLINE);
    }
}

void vga_clear_screen() {
    vga_clear_lines(0x0, VGA_FB_HEIGHT);
}

//shifts whatever is currently drawn down by some amount of lines
//clears top lines
void vga_shift_down(u64 lines) {
    assert(VGA_DID_INIT, "vga_shift_down() : vga should init before using this");
    assert(lines <= VGA_FB_HEIGHT, "vga_shift_down() : shift too large");

    //do shift
    if(VGA_STAGING_LINE_OFF >= lines) VGA_STAGING_LINE_OFF -= lines;
    else VGA_STAGING_LINE_OFF = VGA_STAGING_HEIGHT - lines + VGA_STAGING_LINE_OFF;

    //clear top lines
    vga_clear_lines(0x0, lines);
}

//shifts whatever is currently drawn up by some amount of lines
//clears bottom lines
void vga_shift_up(u64 lines) {
    assert(VGA_DID_INIT, "vga_shift_up() : vga should init before using this");
    assert(lines <= VGA_FB_HEIGHT, "vga_shift_up() : shift too large");

    //do shift
    VGA_STAGING_LINE_OFF = (VGA_STAGING_LINE_OFF + lines) % VGA_STAGING_HEIGHT;

    //clear bottom lines
    vga_clear_lines(VGA_FB_HEIGHT - lines, VGA_FB_HEIGHT);
}


// -- VGA TERMINAL --
[__GLOBAL_FIRST__] u64 TERMINAL_PARSE_BUF_SIZE = $u64 16;
[__GLOBAL_FIRST__] u8 TERMINAL_ESC = $u8 0x1B;  // also written as \x1B

[__GLOBAL_FIRST__] u64 TERMINAL_STATE_ENTRY             = 0x0;
[__GLOBAL_FIRST__] u64 TERMINAL_STATE_ESC               = 0x1;          // ESC
[__GLOBAL_FIRST__] u64 TERMINAL_STATE_CSI               = 0x2;          // ESC[             (control sequence introducer)
[__GLOBAL_FIRST__] u64 TERMINAL_STATE_CSI_NR            = 0x3;          // ESC[#*
[__GLOBAL_FIRST__] u64 TERMINAL_STATE_CSI_NR_SEMI       = 0x4;          // ESC[#*;
[__GLOBAL_FIRST__] u64 TERMINAL_STATE_CSI_NR_SEMI_NR    = 0x5;          // ESC[#*;#*

struct vga_cell {
    u8 char;
}

struct vga_terminal {
    tty* tty;

    u8[16] parse_buf;
    u64 parse_bptr;
    u64 parse_state;

    u64 grid_rows;
    u64 grid_cols;

    u64 cursor_row;
    u64 cursor_col;

    vga_cell* cells;

    vga_terminal() {
        this.tty = $tty* nullptr;

        psf_header* font = $psf_header* @_binary_font_psf_start;
        this.parse_bptr = 0x0;
        this.grid_rows = $u64 VGA_FB_HEIGHT / $u64 font->height;
        this.grid_cols = $u64 VGA_FB_WIDTH / $u64 font->width;
        this.cursor_row = 0x0;
        this.cursor_col = 0x0;

        //initialize cells
        this.cells = $vga_cell* malloc(sizeof(vga_cell) * this.grid_rows * this.grid_cols);
        for(u64 i = 0x0; i < this.grid_rows * this.grid_cols; i++) {
            this.cells[i].char = ' ';
        }
    }

    ~vga_terminal() {
        free($void* this.cells, sizeof(vga_cell) * this.grid_rows * this.grid_cols);
    }
}

//clears grid, sets all pixels to black
void vga_terminal_clear_screen(vga_terminal* term) {
    for(u64 i = 0x0; i < term->grid_rows * term->grid_cols; i++) {
        vga_cell* cell = @(term->cells[i]);
        cell->char = ' ';
    }
    vga_clear_screen();
}

//scrolls the terminal up one row, makes the bottom row empty
//doesn't move the cursor
void vga_terminal_scroll_up(vga_terminal* term) {
    //grid scroll
    {
        vga_cell* dst = term->cells;
        vga_cell* src = @(dst[term->grid_cols]);
        memmove($void* dst, $void* src, sizeof(vga_cell) * (term->grid_rows - 0x1) * term->grid_cols);

        for(u64 i = 0x0; i < term->grid_cols; i++) {
            vga_cell* cell = @(term->cells[(term->grid_rows - 0x1) * term->grid_cols + i]);
            cell->char = ' ';
        }
    }

    //visual scroll
    psf_header* font = $psf_header* @_binary_font_psf_start;
    vga_shift_up($u64 font->height);
}

//if col is outside the grid, wraps it around
//if row is outside the grid, scrolls screen up by one row and moves row back up one
void vga_terminal_set_cursor_pos(vga_terminal* term, u64 row, u64 col) {
    assert(col <= term->grid_cols, "vga_terminal_set_cursor_pos() : col should at most be one outside of grid");
    if(col == term->grid_cols) {
        col = 0x0;
        row ++;
    }
    assert(row <= term->grid_rows, "vga_terminal_set_cursor_pos() : row should at most be one outside of grid");
    if(row == term->grid_rows) {
        row --;
        vga_terminal_scroll_up(term);
    }
    term->cursor_row = row;
    term->cursor_col = col;
}

void vga_terminal_set_cursor_row(vga_terminal* term, u64 row) {
    vga_terminal_set_cursor_pos(term, row, term->cursor_col);
}

void vga_terminal_set_cursor_col(vga_terminal* term, u64 col) {
    vga_terminal_set_cursor_pos(term, term->cursor_row, col);
}

void vga_terminal_inc_cursor_row(vga_terminal* term) {
    vga_terminal_set_cursor_row(term, term->cursor_row + 0x1);
}

void vga_terminal_inc_cursor_col(vga_terminal* term) {
    vga_terminal_set_cursor_col(term, term->cursor_col + 0x1);
}

//draws character onto screen at cursor position, updates cursor position
//does default cursor movement (increments cursor col)
void vga_terminal_draw_char(vga_terminal* term, u8 c) {
    //draw char
    psf_header* font = $psf_header* @_binary_font_psf_start;
    u64 x = term->cursor_col * $u64 font->width;
    u64 y = term->cursor_row * $u64 font->height;
    vga_draw_char(x, y, c, COLOR_BLACK, COLOR_WHITE);

    //update grid cell
    vga_cell* cell = @(term->cells[term->cursor_row * term->grid_cols + term->cursor_col]);
    cell->char = c;

    //update cursor
    vga_terminal_inc_cursor_col(term);
}

void vga_terminal_draw_string(vga_terminal* term, u8* str) {
    u64 len = strlen(str);
    for(u64 i = 0x0; i < len; i++) {
        vga_terminal_draw_char(term, str[i]);
    }
}

//flush buffer of chars in finite state machine to be drawn
//sets parse state to TERMINAL_STATE_ENTRY
void vga_terminal_flush_buf(vga_terminal* term) {
    assert(term->parse_bptr <= TERMINAL_PARSE_BUF_SIZE, "vga_terminal_flush_buf() : ideally, buffer should not overflow");
    for(u64 i = 0x0; i < term->parse_bptr; i++) {
        u8 c = term->parse_buf[i];
        if(c == TERMINAL_ESC) {
            vga_terminal_draw_string(term, "\\x1B");
        }
        else if(c >= ($u8 0x20) && c <= ($u8 0x7E)){
            //printable characters
            vga_terminal_draw_char(term, c);
        }
    }
    term->parse_bptr = 0x0;
    term->parse_state = TERMINAL_STATE_ENTRY;
}

//empties the terminal parse buffer without drawing
//sets parse state to TERMINAL_STATE_ENTRY
void vga_terminal_clear_buf(vga_terminal* term) {
    term->parse_bptr = 0x0;
    term->parse_state = TERMINAL_STATE_ENTRY;
}

void vga_terminal_buf_append(vga_terminal* term, u8 c) {
    assert(term->parse_bptr < TERMINAL_PARSE_BUF_SIZE, "vga_terminal_buf_append() : check for buffer overflow");
    term->parse_buf[term->parse_bptr ++] = c;
}

//finite state machine parser to handle one char at a time
void vga_terminal_accept_char(vga_terminal* term, u8 c) {
    if(term->parse_state == TERMINAL_STATE_ENTRY) {
        if(c == TERMINAL_ESC) {
            //ANSI escape sequence start
            vga_terminal_buf_append(term, c);
            term->parse_state = TERMINAL_STATE_ESC;
        }
        else if(c == '\n') {
            //newline, increment cursor row
            vga_terminal_inc_cursor_row(term);
        }
        else if(c == '\r') {
            //carriage return, set cursor back to beginning
            vga_terminal_set_cursor_col(term, 0x0);
        }
        else if(c == '\b') {
            //backspace, decrement cursor col if it's not at the beginning of the line
            if(term->cursor_col != 0x0) {
                vga_terminal_set_cursor_col(term, term->cursor_col - 0x1);
            }
        }
        else if(c <= $u8 0x1F) {
            //no-op control char
            vga_terminal_draw_char(term, '^');
            vga_terminal_draw_char(term, c + $u8 0x40);
        }
        else if(c == $u8 0x7F) {
            //DEL char
            vga_terminal_draw_string(term, "DEL");
        }
        else if(c >= ($u8 0x20) && c <= ($u8 0x7E)){
            //just print it
            vga_terminal_draw_char(term, c);
        }
    }
    else if(term->parse_state == TERMINAL_STATE_ESC) {
        vga_terminal_buf_append(term, c);
        if(c == '[') {
            term->parse_state = TERMINAL_STATE_CSI;
        }
        else vga_terminal_flush_buf(term);
    }
    else if(term->parse_state == TERMINAL_STATE_CSI) {
        vga_terminal_buf_append(term, c);
        if('0' <= c && c <= '9') {
            term->parse_state = TERMINAL_STATE_CSI_NR;
        }
        else if(c == 'A') {     // ESC[A : up arrow
            if(term->cursor_row != 0x0) vga_terminal_set_cursor_row(term, term->cursor_row - 0x1);
            vga_terminal_clear_buf(term);
        }
        else if(c == 'B') {     // ESC[B : down arrow
            vga_terminal_inc_cursor_row(term);
            vga_terminal_clear_buf(term);
        }
        else if(c == 'C') {     // ESC[C : right arrow
            vga_terminal_inc_cursor_col(term);
            vga_terminal_clear_buf(term);
        }
        else if(c == 'D') {     // ESC[D : left arrow
            if(term->cursor_col != 0x0) vga_terminal_set_cursor_col(term, term->cursor_col - 0x1);
            vga_terminal_clear_buf(term);
        }
        else if(c == 'H') {     // ESC[H : moves cursor to origin (0, 0)
            vga_terminal_set_cursor_pos(term, 0x0, 0x0);
            vga_terminal_clear_buf(term);
        }
        else vga_terminal_flush_buf(term);
    }
    else if(term->parse_state == TERMINAL_STATE_CSI_NR) {
        vga_terminal_buf_append(term, c);
        if('0' <= c && c <= '9') {
            term->parse_state = TERMINAL_STATE_CSI_NR;
        }
        else if(c == ';') {
            term->parse_state = TERMINAL_STATE_CSI_NR_SEMI;
        }
        else {
            //parse the number, see if it matches with an ANSI escape sequence
            assert(term->parse_bptr >= 0x2, "vga_terminal_accept_char() : TERMINAL_STATE_CSI_NR should have enough room for digits");
            u64 ptr = term->parse_bptr - 0x2;
            assert('0' <= term->parse_buf[ptr] && term->parse_buf[ptr] <= '9', "vga_terminal_accept_char() : TERMINAL_STATE_CSI_NR should be a digit");
            i32 pow10 = 1;
            i32 n1 = 0;
            while('0' <= term->parse_buf[ptr] && term->parse_buf[ptr] <= '9') {
                assert(ptr != 0x0, "vga_terminal_accept_char() : TERMINAL_STATE_CSI_NR should always be something before the number");
                i32 dig = $i32 (term->parse_buf[ptr] - '0');
                n1 += dig * pow10;
                pow10 *= 10;
                ptr --;
            }
            assert(term->parse_buf[ptr] == '[' && ptr == 0x1, "vga_terminal_accept_char() : TERMINAL_STATE_CSI_NR making sure read all of the number");
            if(n1 == 2 && c == 'J') {   // ESC[2J : erase entire screen
                vga_terminal_clear_screen(term);
                vga_terminal_clear_buf(term);
            }
            if(n1 == 6 && c == 'n') {   // ESC[6n : report cursor position as ESC[<row>;<col>R
                assert(term->tty != nullptr, "vga_terminal_accept_char() : tty should not be null");
                string msg;
                msg.push_back(TERMINAL_ESC);
                msg.push_back('[');
                msg += to_string(term->cursor_row + 0x1);
                msg.push_back(';');
                msg += to_string(term->cursor_col + 0x1);
                msg.push_back('R');
                if($u64 tty_accept_input(term->tty, msg.jstr(), msg.size()) != msg.size()) {
                    panic("vga_terminal_accept_char() : this should succeed");
                }
                vga_terminal_clear_buf(term);
            }
            else vga_terminal_flush_buf(term);
        }
    }
    else if(term->parse_state == TERMINAL_STATE_CSI_NR_SEMI) {
        vga_terminal_buf_append(term, c);
        if('0' <= c && c <= '9') {
            term->parse_state = TERMINAL_STATE_CSI_NR_SEMI_NR;
        }
        else vga_terminal_flush_buf(term);
    }
    else if(term->parse_state == TERMINAL_STATE_CSI_NR_SEMI_NR) {
        vga_terminal_buf_append(term, c);
        if('0' <= c && c <= '9') {
            term->parse_state = TERMINAL_STATE_CSI_NR_SEMI_NR;
        }
        else {
            //parse the numbers, see if they match with an ANSI escape sequence
            assert(term->parse_bptr >= 0x2, "vga_terminal_accept_char() : TERMINAL_STATE_CSI_NR_SEMI_NR should have enough room for digits");
            u64 ptr = term->parse_bptr - 0x2;
            assert('0' <= term->parse_buf[ptr] && term->parse_buf[ptr] <= '9', "vga_terminal_accept_char() : TERMINAL_STATE_CSI_NR_SEMI_NR should be a digit");
            i32 pow10 = 1;
            i32 n1 = 0;
            while('0' <= term->parse_buf[ptr] && term->parse_buf[ptr] <= '9') {
                assert(ptr != 0x0, "vga_terminal_accept_char() : TERMINAL_STATE_CSI_NR_SEMI_NR should always be something before the number");
                i32 dig = $i32 (term->parse_buf[ptr] - '0');
                n1 += dig * pow10;
                pow10 *= 10;
                ptr --;
            }
            assert(term->parse_buf[ptr] == ';' && ptr >= 0x1, "vga_terminal_accept_char() : TERMINAL_STATE_CSI_NR_SEMI_NR should be at semicolon now");
            ptr --;
            assert('0' <= term->parse_buf[ptr] && term->parse_buf[ptr] <= '9', "vga_terminal_accept_char() : TERMINAL_STATE_CSI_NR_SEMI_NR should be a digit 2");
            pow10 = 1;
            i32 n2 = 0;
            while('0' <= term->parse_buf[ptr] && term->parse_buf[ptr] <= '9') {
                assert(ptr != 0x0, "vga_terminal_accept_char() : TERMINAL_STATE_CSI_NR_SEMI_NR should always be something before the number");
                i32 dig = $i32 (term->parse_buf[ptr] - '0');
                n2 += dig * pow10;
                pow10 *= 10;
                ptr --;
            }       
            assert(term->parse_buf[ptr] == '[' && ptr == 0x1, "vga_terminal_accept_char() : TERMINAL_STATE_CSI_NR_SEMI_NR making sure read all of the number");
            if(c == 'H' || c == 'f') {  // ESC[{line};{column}H ESC[{line};{column}f : set cursor position
                //row and column are given as 1-indexed, convert to 0-indexed
                n1 --;
                n2 --;
                //clamp to grid
                n1 = max(n1, 0);
                n2 = max(n2, 0);
                n1 = min(n1, $i32 term->grid_cols - 1);
                n2 = min(n2, $i32 term->grid_rows - 1);
                //set cursor pos
                vga_terminal_set_cursor_pos(term, $u64 n2, $u64 n1);
                vga_terminal_clear_buf(term);
            }               
            else vga_terminal_flush_buf(term);
        }
    }
    else panic("vga_terminal_accept_char() : invalid parse state");
}

void vga_terminal_accept_str(vga_terminal* term, u8* buf, u64 amt) {
    //de-render cursor
    {
        psf_header* font = $psf_header* @_binary_font_psf_start;
        u8 c = term->cells[term->cursor_row * term->grid_cols + term->cursor_col].char;
        u64 x = term->cursor_col * $u64 font->width;
        u64 y = term->cursor_row * $u64 font->height;
        vga_draw_char(x, y, c, COLOR_BLACK, COLOR_WHITE);
    }

    //accept all chars
    for(u64 i = 0x0; i < amt; i++) {
        vga_terminal_accept_char(term, buf[i]);
    }

    //render cursor
    {
        psf_header* font = $psf_header* @_binary_font_psf_start;
        u8 c = term->cells[term->cursor_row * term->grid_cols + term->cursor_col].char;
        u64 x = term->cursor_col * $u64 font->width;
        u64 y = term->cursor_row * $u64 font->height;
        vga_draw_char(x, y, c, COLOR_WHITE, COLOR_BLACK);
    }
}

[__GLOBAL_FIRST__] tty_backend_ops* TTY_BACKEND_OPS_VGA;
void init_vga_tty_backend_ops() {
    TTY_BACKEND_OPS_VGA = $tty_backend_ops* malloc(sizeof(tty_backend_ops));
    new (TTY_BACKEND_OPS_VGA) tty_backend_ops();
    TTY_BACKEND_OPS_VGA->op_accept_input = #<vga_accept_input(tty*, u8*, u64)>;
    TTY_BACKEND_OPS_VGA->op_close = #<vga_close(tty*)>;
}

i64 vga_accept_input(tty* tty, u8* buf, u64 amt) {
    vga_terminal* term = $vga_terminal* tty->backend;
    vga_terminal_accept_str(term, buf, amt);
    return $i64 amt;
}

i32 vga_close(tty* tty) {
    //free terminal struct
    vga_terminal* term = $vga_terminal* tty->backend;
    term->~();
    return 0;
}
