//ways to improve speed of VGA
// - reading from VGA is very slow (looking at the shift-up operation), should instead keep a parallel copy
//   of the VGA buffer that we can do the shift up, then memcpy it into the VGA buffer
// - can allow the CPU to more aggressively group memory operations by mapping the VGA memory as WC (write-combining)
//   will need to set up the PAT to do this. 
// - look into writing custom assembly for memcpy and memmove operations:
//     rep movsq, rep movsd
//     rep stosq, rep stosd
// - instead of flushing to FB every time we write, have an interrupt fire 60 times a second and flush in the interrupt. 

[__GLOBAL_FIRST__] u32* VGA_FB = $u32* 0xfffffffffc000000;
[VGA] u64 VGA_FB_SCANLINE = $u64 bootinfo->fb_ppsl;
[VGA] u64 VGA_FB_WIDTH = $u64 bootinfo->fb_width;
[VGA] u64 VGA_FB_HEIGHT = $u64 bootinfo->fb_height;

[__GLOBAL_FIRST__] u32 COLOR_WHITE = $u32 0x00ffffff;
[__GLOBAL_FIRST__] u32 COLOR_BLACK = $u32 0x00000000;
[__GLOBAL_FIRST__] u32 COLOR_GRAY = $u32 0x00aaaaaa;

[__GLOBAL_FIRST__] extern u8 _binary_font_psf_start;

[__GLOBAL_FIRST__] vga_scroll_buffer* VGA_KERNEL_SCROLL_BUFFER;
[__GLOBAL_FIRST__] vga_scroll_buffer* VGA_USER_SCROLL_BUFFER;

struct psf_header {
    u32 magic;
    u32 version;
    u32 headersize;
    u32 flags;
    u32 numglyph;
    u32 bytesperglyph;
    u32 height;
    u32 width;
    u8 glyphs;  //glyph starting byte
}

[__GLOBAL_FIRST__] i32 VGA_DID_INIT = 0;
void init_vga() {
    //set VGA framebuffer MMIO to be WC
    {
        u64 ptr = $u64 VGA_FB;
        pagetable_t pt = pt_get_current();
        assert((ptr % PAGE_SIZE) == 0x0, "init_vga() : expect VGA FB to be page-aligned");
        for(u64 i = 0x0; i < sizeof(u32) * VGA_FB_SCANLINE * VGA_FB_HEIGHT; i += PAGE_SIZE) {
            void* vaddr = $void* (ptr + i);
            pt_set_leaf_flags(pt, vaddr, pte_pat_bits(PAT_WC) | PTE_WRITEABLE);
        }
    }

    //allocate user and kernel staging buffers
    VGA_KERNEL_SCROLL_BUFFER = $vga_scroll_buffer* malloc(sizeof(vga_scroll_buffer));
    VGA_USER_SCROLL_BUFFER = $vga_scroll_buffer* malloc(sizeof(vga_scroll_buffer));
    if(DEBUG_MODE) {
        new (VGA_KERNEL_SCROLL_BUFFER) vga_scroll_buffer(VGA_FB_WIDTH / 0x2, VGA_FB_WIDTH / 0x2);
        new (VGA_USER_SCROLL_BUFFER) vga_scroll_buffer(VGA_FB_WIDTH / 0x2, 0x0);
    }
    else {
        new (VGA_KERNEL_SCROLL_BUFFER) vga_scroll_buffer(VGA_FB_WIDTH, 0x0);
        new (VGA_USER_SCROLL_BUFFER) vga_scroll_buffer(VGA_FB_WIDTH, 0x0);
    }


    VGA_DID_INIT = 1;
    println("done init vga");
}

[__GLOBAL_FIRST__] u64 VGA_DEBUG_CURSOR_COL = 0x0;
[__GLOBAL_FIRST__] u64 VGA_DEBUG_CURSOR_ROW = 0x0;
void vga_debug_draw_char(u8 c) {
    assert(VGA_DID_INIT, "vga_debug_draw_char() : vga needs to be initialized");
    psf_header* font = $psf_header* @_binary_font_psf_start;
    if(c == '\n') {
        VGA_DEBUG_CURSOR_COL = 0x0;
        VGA_DEBUG_CURSOR_ROW ++;
        if(VGA_DEBUG_CURSOR_ROW == (VGA_FB_HEIGHT / $u64 font->height)) {
            VGA_KERNEL_SCROLL_BUFFER->shift_up($u64 font->height);
            VGA_DEBUG_CURSOR_ROW --;
        }

        if(!SCHEDULER_STARTED) {
            VGA_KERNEL_SCROLL_BUFFER->flush();
        }
    }
    else {  
        VGA_KERNEL_SCROLL_BUFFER->draw_char(VGA_DEBUG_CURSOR_COL * $u64 font->width, VGA_DEBUG_CURSOR_ROW * $u64 font->height, c, COLOR_BLACK, COLOR_WHITE);
        VGA_DEBUG_CURSOR_COL ++;
        if(VGA_DEBUG_CURSOR_COL == (VGA_KERNEL_SCROLL_BUFFER->width / $u64 font->width)) {
            VGA_DEBUG_CURSOR_ROW ++;
            VGA_DEBUG_CURSOR_COL = 0x0;
        }
        if(VGA_DEBUG_CURSOR_ROW == (VGA_FB_HEIGHT / $u64 font->height)) {
            VGA_KERNEL_SCROLL_BUFFER->shift_up($u64 font->height);
            VGA_DEBUG_CURSOR_ROW --;
        }
    }
}

//flush whatever is in the staging buffers into the actual VGA framebuffer
void vga_flush() {
    assert(VGA_DID_INIT, "vga_flush() : need init vga to complete");
    VGA_USER_SCROLL_BUFFER->flush();
    if(DEBUG_MODE || !SCHEDULER_STARTED) VGA_KERNEL_SCROLL_BUFFER->flush();
}

// -- VGA SCROLL BUFFER -- 
//owns a contiguous horizontal section of the screen
struct vga_scroll_buffer {
    u64 width; 
    u64 offset;         //horizontal offset from left
    u64 height;         //total height of the scroll buffer
    u32* buf;
    u64 line_offset;    //logical start of the screen within the scroll buffer

    vga_scroll_buffer() {
        panic("vga_scroll_buffer() : no use default constructor");
    }

    vga_scroll_buffer(u64 width, u64 offset) {
        assert(width + offset <= VGA_FB_WIDTH, "vga_scroll_buffer() : buffer going offscreen");
        assert(width > 0x0, "vga_scroll_buffer() : can\'t have buffer with 0 width");
        this.width = width;
        this.offset = offset;
        this.height = VGA_FB_HEIGHT * ($u64 16);
        this.buf = $u32* malloc(sizeof(u32) * this.width * this.height);
        memset($void* this.buf, 0, sizeof(u32) * this.width * this.height);
        this.line_offset = 0x0;
    }

    ~vga_scroll_buffer() {
        free($void* this.buf, sizeof(u32) * this.width * this.height);
    }

    void shift_down(u64 lines) {
        assert(lines <= VGA_FB_HEIGHT, "vga_scroll_buffer::shift_down() : shift too large");

        //do shift
        if(this.line_offset >= lines) this.line_offset -= lines;
        else this.line_offset = this.line_offset - lines + this.height;

        //clear top lines
        this.clear_lines(0x0, lines);
    }
    
    void shift_up(u64 lines) {
        assert(lines <= VGA_FB_HEIGHT, "vga_scroll_buffer::shift_up() : shift too large");

        //do shift
        this.line_offset = (this.line_offset + lines) % this.height;

        //clear bottom lines
        this.clear_lines(VGA_FB_HEIGHT - lines, VGA_FB_HEIGHT);
    }

    void clear_lines(u64 start, u64 end) {
        assert(start < end, "vga_scroll_buffer::clear_lines() : start must be <= end");
        assert(end <= VGA_FB_HEIGHT, "vga_scroll_buffer::clear_lines() : end out of bounds");
        start = (start + this.line_offset) % this.height;
        end = (end + this.line_offset) % this.height;

        if(start < end) {
            //no wrap
            memset($void* @(this.buf[start * this.width]), 0, sizeof(u32) * (end - start) * this.width);
        }
        else {
            //wrap
            memset($void* @(this.buf[start * this.width]), 0, sizeof(u32) * (this.height - start) * this.width);
            memset($void* this.buf, 0, sizeof(u32) * end * this.width);
        }
    }

    void clear_screen() {
        this.clear_lines(0x0, VGA_FB_HEIGHT);
    }

    void draw_pixel(u64 x, u64 y, u32 color) {
        this.buf[this.width * ((this.line_offset + y) % this.height) + x] = color;
    }

    void draw_char(u64 x, u64 y, u8 c, u32 bg_col, u32 fg_col) {
        psf_header* font = $psf_header* @_binary_font_psf_start;
        assert(x + $u64 font->width <= this.width && y + $u64 font->height <= VGA_FB_HEIGHT, "vga_scroll_buffer::draw_char() : glyph out of bounds");
        u64 bpl = ($u64 font->width + $u64 7) / $u64 8;
        u8* glyph = $u8* ($u64 font + $u64 font->headersize + $u64 font->bytesperglyph * $u64 c);
        for(i32 j = 0; j < $i32 font->height; j++){
            u64 line = ($u64* @(glyph[bpl * $u64 j]))[0];
            for(i32 i = 0; i < $i32 font->width; i++){
                if(line & ($u64 1 << ($u64 font->width - $u64 1 - $u64 i))) {
                    //foreground
                    this.buf[this.width * ((this.line_offset + y + $u64 j) % this.height) + x + $u64 i] = fg_col;
                }
                else {
                    //background
                    this.buf[this.width * ((this.line_offset + y + $u64 j) % this.height) + x + $u64 i] = bg_col;
                }
            }
        }
    }

    //flushes the contents of this buffer to the VGA FB
    void flush() {
        for(u64 i = 0x0; i < VGA_FB_HEIGHT; i++) {
            memcpy(
                $void* ($u64 VGA_FB + sizeof(u32) * (VGA_FB_SCANLINE * i + this.offset)), 
                $void* @(this.buf[((this.line_offset + i) % this.height) * this.width]), 
                sizeof(u32) * this.width
            );
        }
    }
}


// -- VGA TERMINAL --
[__GLOBAL_FIRST__] u64 TERMINAL_PARSE_BUF_SIZE = $u64 16;
[__GLOBAL_FIRST__] u8 TERMINAL_ESC = $u8 0x1B;  // also written as \x1B

[__GLOBAL_FIRST__] u64 TERMINAL_STATE_ENTRY             = 0x0;
[__GLOBAL_FIRST__] u64 TERMINAL_STATE_ESC               = 0x1;          // ESC
[__GLOBAL_FIRST__] u64 TERMINAL_STATE_CSI               = 0x2;          // ESC[             (control sequence introducer)
[__GLOBAL_FIRST__] u64 TERMINAL_STATE_CSI_NR            = 0x3;          // ESC[#*
[__GLOBAL_FIRST__] u64 TERMINAL_STATE_CSI_NR_SEMI       = 0x4;          // ESC[#*;
[__GLOBAL_FIRST__] u64 TERMINAL_STATE_CSI_NR_SEMI_NR    = 0x5;          // ESC[#*;#*

struct vga_cell {
    u8 char;
    u32 fg_color;
    u32 bg_color;
}

struct vga_terminal {
    tty* tty;

    u8[16] parse_buf;
    u64 parse_bptr;
    u64 parse_state;

    u64 grid_rows;
    u64 grid_cols;

    u64 cursor_row;
    u64 cursor_col;

    //set to 1 when we write a printable character on the last column
    //if wrap_pending and we're trying to write a printable character, should wrap then write character
    //if wrap_pending and we're trying to do some other action that moves the cursor, clear wrap_pending
    i32 wrap_pending;   

    //active colors
    u32 fg_color;
    u32 bg_color;

    vga_cell* cells;

    vga_terminal() {
        this.tty = $tty* nullptr;

        psf_header* font = $psf_header* @_binary_font_psf_start;
        this.parse_bptr = 0x0;
        this.grid_rows = $u64 VGA_FB_HEIGHT / $u64 font->height;
        this.grid_cols = $u64 VGA_USER_SCROLL_BUFFER->width / $u64 font->width;
        this.cursor_row = 0x0;
        this.cursor_col = 0x0;
        this.wrap_pending = 0;
        this.fg_color = COLOR_WHITE;
        this.bg_color = COLOR_BLACK;

        //initialize cells
        this.cells = $vga_cell* malloc(sizeof(vga_cell) * this.grid_rows * this.grid_cols);
        for(u64 i = 0x0; i < this.grid_rows * this.grid_cols; i++) {
            this.cells[i].char = ' ';
            this.cells[i].fg_color = COLOR_WHITE;
            this.cells[i].bg_color = COLOR_BLACK;
        }
    }

    ~vga_terminal() {
        free($void* this.cells, sizeof(vga_cell) * this.grid_rows * this.grid_cols);
    }
}

//clears grid, sets all pixels to black
void vga_terminal_clear_screen(vga_terminal* term) {
    for(u64 i = 0x0; i < term->grid_rows * term->grid_cols; i++) {
        vga_cell* cell = @(term->cells[i]);
        cell->char = ' ';
    }
    VGA_USER_SCROLL_BUFFER->clear_screen();
}

//scrolls the terminal up one row, makes the bottom row empty
//doesn't move the cursor
void vga_terminal_scroll_up(vga_terminal* term) {
    //grid scroll
    {
        vga_cell* dst = term->cells;
        vga_cell* src = @(dst[term->grid_cols]);
        memmove($void* dst, $void* src, sizeof(vga_cell) * (term->grid_rows - 0x1) * term->grid_cols);

        for(u64 i = 0x0; i < term->grid_cols; i++) {
            vga_cell* cell = @(term->cells[(term->grid_rows - 0x1) * term->grid_cols + i]);
            cell->char = ' ';
        }
    }

    //visual scroll
    psf_header* font = $psf_header* @_binary_font_psf_start;
    VGA_USER_SCROLL_BUFFER->shift_up($u64 font->height);
}

//if col is outside the grid, wraps it around
//if row is outside the grid, scrolls screen up by one row and moves row back up one
void vga_terminal_set_cursor_pos(vga_terminal* term, u64 row, u64 col) {
    assert(col <= term->grid_cols, "vga_terminal_set_cursor_pos() : col should at most be one outside of grid");
    if(col == term->grid_cols) {
        col = 0x0;
        row ++;
    }
    assert(row <= term->grid_rows, "vga_terminal_set_cursor_pos() : row should at most be one outside of grid");
    if(row == term->grid_rows) {
        row --;
        vga_terminal_scroll_up(term);
    }
    term->cursor_row = row;
    term->cursor_col = col;
    term->wrap_pending = 0;     //unset wrap pending whenever the cursor moves
}

void vga_terminal_set_cursor_row(vga_terminal* term, u64 row) {
    vga_terminal_set_cursor_pos(term, row, term->cursor_col);
}

void vga_terminal_set_cursor_col(vga_terminal* term, u64 col) {
    vga_terminal_set_cursor_pos(term, term->cursor_row, col);
}

void vga_terminal_inc_cursor_row(vga_terminal* term) {
    vga_terminal_set_cursor_row(term, term->cursor_row + 0x1);
}

void vga_terminal_inc_cursor_col(vga_terminal* term) {
    vga_terminal_set_cursor_col(term, term->cursor_col + 0x1);
}

//draws character onto screen at cursor position, updates cursor position
//does default cursor movement (increments cursor col)
void vga_terminal_draw_char(vga_terminal* term, u8 c) {
    //handle wrapping
    if(term->wrap_pending) {
        assert(term->cursor_col + 0x1 == term->grid_cols, "vga_terminal_draw_char() : wrap_pending should only be set when the cursor is in last column");
        vga_terminal_inc_cursor_col(term);
    }

    //draw char
    psf_header* font = $psf_header* @_binary_font_psf_start;
    u64 x = term->cursor_col * $u64 font->width;
    u64 y = term->cursor_row * $u64 font->height;
    VGA_USER_SCROLL_BUFFER->draw_char(x, y, c, term->bg_color, term->fg_color);

    //update grid cell
    vga_cell* cell = @(term->cells[term->cursor_row * term->grid_cols + term->cursor_col]);
    cell->char = c;

    //update cursor
    if(term->cursor_col + 0x1 == term->grid_cols) {
        //arm next character to wrap
        term->wrap_pending = 1;
    }
    else {
        //move cursor right
        vga_terminal_inc_cursor_col(term);
    }      
}

void vga_terminal_draw_string(vga_terminal* term, u8* str) {
    u64 len = strlen(str);
    for(u64 i = 0x0; i < len; i++) {
        vga_terminal_draw_char(term, str[i]);
    }
}

//flush buffer of chars in finite state machine to be drawn
//sets parse state to TERMINAL_STATE_ENTRY
void vga_terminal_flush_buf(vga_terminal* term) {
    assert(term->parse_bptr <= TERMINAL_PARSE_BUF_SIZE, "vga_terminal_flush_buf() : ideally, buffer should not overflow");
    for(u64 i = 0x0; i < term->parse_bptr; i++) {
        u8 c = term->parse_buf[i];
        if(c == TERMINAL_ESC) {
            vga_terminal_draw_string(term, "\\x1B");
        }
        else if(c >= ($u8 0x20) && c <= ($u8 0x7E)){
            //printable characters
            vga_terminal_draw_char(term, c);
        }
    }
    term->parse_bptr = 0x0;
    term->parse_state = TERMINAL_STATE_ENTRY;
}

//empties the terminal parse buffer without drawing
//sets parse state to TERMINAL_STATE_ENTRY
void vga_terminal_clear_buf(vga_terminal* term) {
    term->parse_bptr = 0x0;
    term->parse_state = TERMINAL_STATE_ENTRY;
}

void vga_terminal_buf_append(vga_terminal* term, u8 c) {
    assert(term->parse_bptr < TERMINAL_PARSE_BUF_SIZE, "vga_terminal_buf_append() : check for buffer overflow");
    term->parse_buf[term->parse_bptr ++] = c;
}

//finite state machine parser to handle one char at a time
void vga_terminal_accept_char(vga_terminal* term, u8 c) {
    if(term->parse_state == TERMINAL_STATE_ENTRY) {
        if(c == TERMINAL_ESC) {
            //ANSI escape sequence start
            vga_terminal_buf_append(term, c);
            term->parse_state = TERMINAL_STATE_ESC;
        }
        else if(c == '\n') {
            //newline, increment cursor row
            vga_terminal_inc_cursor_row(term);
        }
        else if(c == '\r') {
            //carriage return, set cursor back to beginning
            vga_terminal_set_cursor_col(term, 0x0);
        }
        else if(c == '\b') {
            //backspace, decrement cursor col if it's not at the beginning of the line
            if(term->cursor_col != 0x0) {
                vga_terminal_set_cursor_col(term, term->cursor_col - 0x1);
            }
        }
        else if(c <= $u8 0x1F) {
            //no-op control char
            vga_terminal_draw_char(term, '^');
            vga_terminal_draw_char(term, c + $u8 0x40);
        }
        else if(c == $u8 0x7F) {
            //DEL char
            vga_terminal_draw_string(term, "DEL");
        }
        else if(c >= ($u8 0x20) && c <= ($u8 0x7E)){
            //just print it
            vga_terminal_draw_char(term, c);
        }
    }
    else if(term->parse_state == TERMINAL_STATE_ESC) {
        vga_terminal_buf_append(term, c);
        if(c == '[') {
            term->parse_state = TERMINAL_STATE_CSI;
        }
        else vga_terminal_flush_buf(term);
    }
    else if(term->parse_state == TERMINAL_STATE_CSI) {
        vga_terminal_buf_append(term, c);
        if('0' <= c && c <= '9') {
            term->parse_state = TERMINAL_STATE_CSI_NR;
        }
        else if(c == 'A') {     // ESC[A : up arrow
            if(term->cursor_row != 0x0) vga_terminal_set_cursor_row(term, term->cursor_row - 0x1);
            vga_terminal_clear_buf(term);
        }
        else if(c == 'B') {     // ESC[B : down arrow
            vga_terminal_inc_cursor_row(term);
            vga_terminal_clear_buf(term);
        }
        else if(c == 'C') {     // ESC[C : right arrow
            vga_terminal_inc_cursor_col(term);
            vga_terminal_clear_buf(term);
        }
        else if(c == 'D') {     // ESC[D : left arrow
            if(term->cursor_col != 0x0) vga_terminal_set_cursor_col(term, term->cursor_col - 0x1);
            vga_terminal_clear_buf(term);
        }
        else if(c == 'H') {     // ESC[H : moves cursor to origin (0, 0)
            vga_terminal_set_cursor_pos(term, 0x0, 0x0);
            vga_terminal_clear_buf(term);
        }
        else vga_terminal_flush_buf(term);
    }
    else if(term->parse_state == TERMINAL_STATE_CSI_NR) {
        vga_terminal_buf_append(term, c);
        if('0' <= c && c <= '9') {
            term->parse_state = TERMINAL_STATE_CSI_NR;
        }
        else if(c == ';') {
            term->parse_state = TERMINAL_STATE_CSI_NR_SEMI;
        }
        else {
            //parse the number, see if it matches with an ANSI escape sequence
            assert(term->parse_bptr >= 0x2, "vga_terminal_accept_char() : TERMINAL_STATE_CSI_NR should have enough room for digits");
            u64 ptr = term->parse_bptr - 0x2;
            assert('0' <= term->parse_buf[ptr] && term->parse_buf[ptr] <= '9', "vga_terminal_accept_char() : TERMINAL_STATE_CSI_NR should be a digit");
            i32 pow10 = 1;
            i32 n1 = 0;
            while('0' <= term->parse_buf[ptr] && term->parse_buf[ptr] <= '9') {
                assert(ptr != 0x0, "vga_terminal_accept_char() : TERMINAL_STATE_CSI_NR should always be something before the number");
                i32 dig = $i32 (term->parse_buf[ptr] - '0');
                n1 += dig * pow10;
                pow10 *= 10;
                ptr --;
            }
            assert(term->parse_buf[ptr] == '[' && ptr == 0x1, "vga_terminal_accept_char() : TERMINAL_STATE_CSI_NR making sure read all of the number");
            if(n1 == 2 && c == 'J') {   // ESC[2J : erase entire screen
                vga_terminal_clear_screen(term);
                vga_terminal_clear_buf(term);
            }
            if(n1 == 6 && c == 'n') {   // ESC[6n : report cursor position as ESC[<row>;<col>R
                assert(term->tty != nullptr, "vga_terminal_accept_char() : tty should not be null");
                string msg;
                msg.push_back(TERMINAL_ESC);
                msg.push_back('[');
                msg += to_string(term->cursor_row + 0x1);
                msg.push_back(';');
                msg += to_string(term->cursor_col + 0x1);
                msg.push_back('R');
                if($u64 tty_accept_input(term->tty, msg.jstr(), msg.size()) != msg.size()) {
                    panic("vga_terminal_accept_char() : this should succeed");
                }
                vga_terminal_clear_buf(term);
            }
            else vga_terminal_flush_buf(term);
        }
    }
    else if(term->parse_state == TERMINAL_STATE_CSI_NR_SEMI) {
        vga_terminal_buf_append(term, c);
        if('0' <= c && c <= '9') {
            term->parse_state = TERMINAL_STATE_CSI_NR_SEMI_NR;
        }
        else vga_terminal_flush_buf(term);
    }
    else if(term->parse_state == TERMINAL_STATE_CSI_NR_SEMI_NR) {
        vga_terminal_buf_append(term, c);
        if('0' <= c && c <= '9') {
            term->parse_state = TERMINAL_STATE_CSI_NR_SEMI_NR;
        }
        else {
            //parse the numbers, see if they match with an ANSI escape sequence
            assert(term->parse_bptr >= 0x2, "vga_terminal_accept_char() : TERMINAL_STATE_CSI_NR_SEMI_NR should have enough room for digits");
            u64 ptr = term->parse_bptr - 0x2;
            assert('0' <= term->parse_buf[ptr] && term->parse_buf[ptr] <= '9', "vga_terminal_accept_char() : TERMINAL_STATE_CSI_NR_SEMI_NR should be a digit");
            i32 pow10 = 1;
            i32 n1 = 0;
            while('0' <= term->parse_buf[ptr] && term->parse_buf[ptr] <= '9') {
                assert(ptr != 0x0, "vga_terminal_accept_char() : TERMINAL_STATE_CSI_NR_SEMI_NR should always be something before the number");
                i32 dig = $i32 (term->parse_buf[ptr] - '0');
                n1 += dig * pow10;
                pow10 *= 10;
                ptr --;
            }
            assert(term->parse_buf[ptr] == ';' && ptr >= 0x1, "vga_terminal_accept_char() : TERMINAL_STATE_CSI_NR_SEMI_NR should be at semicolon now");
            ptr --;
            assert('0' <= term->parse_buf[ptr] && term->parse_buf[ptr] <= '9', "vga_terminal_accept_char() : TERMINAL_STATE_CSI_NR_SEMI_NR should be a digit 2");
            pow10 = 1;
            i32 n2 = 0;
            while('0' <= term->parse_buf[ptr] && term->parse_buf[ptr] <= '9') {
                assert(ptr != 0x0, "vga_terminal_accept_char() : TERMINAL_STATE_CSI_NR_SEMI_NR should always be something before the number");
                i32 dig = $i32 (term->parse_buf[ptr] - '0');
                n2 += dig * pow10;
                pow10 *= 10;
                ptr --;
            }       
            assert(term->parse_buf[ptr] == '[' && ptr == 0x1, "vga_terminal_accept_char() : TERMINAL_STATE_CSI_NR_SEMI_NR making sure read all of the number");
            if(c == 'H' || c == 'f') {  // ESC[{line};{column}H ESC[{line};{column}f : set cursor position
                //row and column are given as 1-indexed, convert to 0-indexed
                n1 --;
                n2 --;
                //clamp to grid
                n1 = max(n1, 0);
                n2 = max(n2, 0);
                n1 = min(n1, $i32 term->grid_cols - 1);
                n2 = min(n2, $i32 term->grid_rows - 1);
                //set cursor pos
                vga_terminal_set_cursor_pos(term, $u64 n2, $u64 n1);
                vga_terminal_clear_buf(term);
            }               
            else vga_terminal_flush_buf(term);
        }
    }
    else panic("vga_terminal_accept_char() : invalid parse state");
}

void vga_terminal_accept_str(vga_terminal* term, u8* buf, u64 amt) {
    //de-render cursor
    {
        psf_header* font = $psf_header* @_binary_font_psf_start;
        u8 c = term->cells[term->cursor_row * term->grid_cols + term->cursor_col].char;
        u64 x = term->cursor_col * $u64 font->width;
        u64 y = term->cursor_row * $u64 font->height;
        VGA_USER_SCROLL_BUFFER->draw_char(x, y, c, term->bg_color, term->fg_color);
    }

    //accept all chars
    for(u64 i = 0x0; i < amt; i++) {
        vga_terminal_accept_char(term, buf[i]);
    }

    //render cursor
    {
        psf_header* font = $psf_header* @_binary_font_psf_start;
        u8 c = term->cells[term->cursor_row * term->grid_cols + term->cursor_col].char;
        u64 x = term->cursor_col * $u64 font->width;
        u64 y = term->cursor_row * $u64 font->height;
        VGA_USER_SCROLL_BUFFER->draw_char(x, y, c, term->fg_color, term->bg_color);
    }
}

[__GLOBAL_FIRST__] tty_backend_ops* TTY_BACKEND_OPS_VGA;
void init_vga_tty_backend_ops() {
    TTY_BACKEND_OPS_VGA = $tty_backend_ops* malloc(sizeof(tty_backend_ops));
    new (TTY_BACKEND_OPS_VGA) tty_backend_ops();
    TTY_BACKEND_OPS_VGA->op_accept_input = #<vga_accept_input(tty*, u8*, u64)>;
    TTY_BACKEND_OPS_VGA->op_close = #<vga_close(tty*)>;
}

i64 vga_accept_input(tty* tty, u8* buf, u64 amt) {
    vga_terminal* term = $vga_terminal* tty->backend;
    vga_terminal_accept_str(term, buf, amt);
    return $i64 amt;
}

i32 vga_close(tty* tty) {
    //free terminal struct
    vga_terminal* term = $vga_terminal* tty->backend;
    term->~();
    return 0;
}
