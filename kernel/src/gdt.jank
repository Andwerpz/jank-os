
//in 64-bit mode, Base and Limit values are ignored. Every segment covers the entire linear address space

[__GLOBAL_FIRST__] u8 GDT_ACCESS_PRESENT    = $u8 0b10000000;   //must be set for any valid segment
[__GLOBAL_FIRST__] u8 GDT_ACCESS_DPL_KERNEL = $u8 0b00000000;
[__GLOBAL_FIRST__] u8 GDT_ACCESS_DPL_USER   = $u8 0b01100000;
[__GLOBAL_FIRST__] u8 GDT_ACCESS_TYPE       = $u8 0b00010000;   //if set, defines a code or data segment, otherwise defines a system segment
[__GLOBAL_FIRST__] u8 GDT_ACCESS_EXECUTABLE = $u8 0b00001000;   //if set, defines a code segment, otherwise a data segment
[__GLOBAL_FIRST__] u8 GDT_ACCESS_DC         = $u8 0b00000100;
[__GLOBAL_FIRST__] u8 GDT_ACCESS_RW         = $u8 0b00000010;   //for code segments: determines if this segment is readable
                                                                //for data segments: determines if this segment is PTE_WRITEABLE
[__GLOBAL_FIRST__] u8 GDT_ACCESS_ACCESSED   = $u8 0b00000001;   //accessed bit: if set to 0, cpu will trigger a page fault when setting to 1. 
                                                                //best left set to 1. 

[__GLOBAL_FIRST__] u8 GDT_FLAGS_GRANULARITY = $u8 0b10000000;   //sets the scaling of the Limit value. 
[__GLOBAL_FIRST__] u8 GDT_FLAGS_DB          = $u8 0b01000000;   //this shouldn't matter in 64-bit mode??
[__GLOBAL_FIRST__] u8 GDT_FLAGS_LONGMODE    = $u8 0b00100000;   //if set, this segment is a 64-bit code segment
                                                                //for any other type of segment (other code types or any data segment), this should be 0

struct GDTSegmentDescriptor {
    u16 limit;
    u16 base_low;
    u8  base_middle;
    u8  access;
    u8  flags;
    u8  base_high;
}

struct GDTSystemDescriptor {
    u16 limit0;
    u16 base0;
    u8 base1;
    u8 access;
    u8 flags;
    u8 base2;
    u32 base3;
    u32 reserved;
}

struct GDTPointer {
    u16 limit;
    u64 base;
}

struct TSS {
    u32 reserved0;
    u64 rsp0;        
    u64 rsp1;        
    u64 rsp2;       
    u64 reserved1;
    u64 ist1;        
    u64 ist2;
    u64 ist3;
    u64 ist4;
    u64 ist5;
    u64 ist6;
    u64 ist7;
    u64 reserved2;
    u16 reserved3;
    u16 io_bitmap_offset;
}

// https://wiki.osdev.org/Global_Descriptor_Table
i32 init_gdt() {
    println("start init gdt");
    pagetable_t kernel_pt = pt_get_current();

    //map page for GDT
    pt_map_page(kernel_pt, $void* GDT_PAGE, palloc(), PTE_WRITEABLE);
    memset($void* GDT_PAGE, 0, PAGE_SIZE);  //clear page
    GDTSegmentDescriptor* gdt = $GDTSegmentDescriptor* GDT_PAGE;

    //initialize TSS
    pt_map_page(kernel_pt, $void* TSS_PAGE, palloc(), PTE_WRITEABLE);
    memset($void* TSS_PAGE, 0, PAGE_SIZE);
    TSS* tss = $TSS* TSS_PAGE;
    tss->rsp0 = BOOTBOOT_STACK_TOP; 

    //create GDTPointer
    GDTPointer* gdt_ptr = $GDTPointer* malloc(sizeof(GDTPointer));
    gdt_ptr->limit = $u16 sizeof(GDTSegmentDescriptor) * $u16 7 - $u16 1;  // 7 entries (including TSS which takes 2)
    gdt_ptr->base = $u64 gdt;    

    //setup GDT
    gdt_set_entry(0, $u32 0, $u32 0, $u8 0, $u8 0, gdt); // NULL segment
    gdt_set_entry(1, $u32 0, $u32 0xffffffff, $u8 0x9a, GDT_FLAGS_GRANULARITY | GDT_FLAGS_LONGMODE, gdt);   // kernel code segment
    gdt_set_entry(2, $u32 0, $u32 0xffffffff, $u8 0x92, GDT_FLAGS_GRANULARITY, gdt);   // kernel data segment
    gdt_set_entry(3, $u32 0, $u32 0xffffffff, $u8 0xf2, GDT_FLAGS_GRANULARITY, gdt);   // user data segment
    gdt_set_entry(4, $u32 0, $u32 0xffffffff, $u8 0xfa, GDT_FLAGS_GRANULARITY | GDT_FLAGS_LONGMODE, gdt);   // user code segment
    
    // TSS entry (takes 2 GDT entries: 5 and 6)
    gdt_set_system_entry(5, 
        TSS_PAGE, 
        $u32 sizeof(TSS) - $u32 1, 
        GDT_ACCESS_PRESENT | GDT_ACCESS_EXECUTABLE | GDT_ACCESS_ACCESSED, 
        $u8 0x00, 
        gdt
    );

    //flush changes
    gdt_flush(gdt_ptr);
    
    // Load TSS
    asm!("mov $0x28, %ax"); 
    asm!("ltr %ax");

    println("done init gdt");
    return 0;
}

//sets stack entry point for interrupts from user -> kernel mode
//should be set every time we schedule a new process
void tss_set_rsp0(u64 addr) {
    TSS* tss = $TSS* TSS_PAGE;
    tss->rsp0 = addr;
}

void gdt_set_entry(i32 idx, u32 base, u32 limit, u8 access, u8 flags, GDTSegmentDescriptor* gdt) {
    gdt[idx].base_low     = $u16 (base & $u32 0xffff);
    gdt[idx].base_middle  = $u8 ((base >> $u32 16) & $u32 0xff);
    gdt[idx].base_high    = $u8 ((base >> $u32 24) & $u32 0xff);
    gdt[idx].limit        = $u16 (limit & $u32 0xffff);
    gdt[idx].flags        = $u8 (((limit >> $u32 16) & $u32 0x0f));
    gdt[idx].flags       |= flags;
    gdt[idx].access       = access;
}

void gdt_set_system_entry(i32 idx, u64 base, u32 limit, u8 access, u8 flags, GDTSegmentDescriptor* gdt) {
    GDTSystemDescriptor* ent = $GDTSystemDescriptor* @gdt[idx];
    ent->limit0           = $u16 (limit & $u32 0xffff);
    ent->base0            = $u16 (base & 0xffff);
    ent->base1            = $u8 ((base >> $u64 16) & 0xff);
    ent->access           = access;
    ent->flags            = $u8 ((limit >> $u32 16) & $u32 0x0f);
    ent->flags           |= flags;
    ent->base2            = $u8 ((base >> $u64 24) & 0xff);
    ent->base3            = $u32 ((base >> $u64 32) & 0xffffffff);
    ent->reserved         = $u32 0;
}   

void gdt_flush(GDTPointer* ptr) {
    //set new GDT
    asm!("movq {ptr}, %rax");
    asm!("lgdt (%rax)");

    //reload segment registers
    asm!("mov $0x10, %ax");
    asm!("mov %ax, %ds");
    asm!("mov %ax, %es");
    asm!("mov %ax, %fs");
    asm!("mov %ax, %gs");
    asm!("mov %ax, %ss");

    //flush changes to GDT
    asm!("push $0x08");    //new CS
    asm!("lea 1f(%rip), %rax");
    asm!("push %rax");
    asm!("lretq");
    asm!("1:");
}

