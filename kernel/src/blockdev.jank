// standard interface for block device drivers

[__GLOBAL_FIRST__] u64 BLOCKDEV_TYPE_PARTITION  = 0x1;
[__GLOBAL_FIRST__] u64 BLOCKDEV_TYPE_AHCI       = 0x2;
[__GLOBAL_FIRST__] u64 BLOCKDEV_TYPE_USB_SCSI   = 0x3;

struct blockdev_cache_ent {
    i32 occupied;
    blockdev* dev;
    u64 lba;
    void* buf;
    u64 refcount;
    i32 dirty;
    i32 clock;

    // TODO add lock
}

//blockdev cache will be keyed by {blockdev*, lba}
[__GLOBAL_FIRST__] u64 BLOCKDEV_CACHE_SIZE = 0x10000;  // number of cache entries
[__GLOBAL_FIRST__] u64 BLOCKDEV_CACHE_CLOCK_PTR;
[__GLOBAL_FIRST__] blockdev_cache_ent* BLOCKDEV_CACHE;
[__GLOBAL_FIRST__] hashmap<pair<blockdev*, u64>, u64>* BLOCKDEV_CACHE_MAP;  // maps {blockdev*, lba} -> cache entry ind

struct blockdev_ops {
    fn<i32(blockdev*, u64, u64, void*)> read;       //reads some sectors from the block device into the provided buffer. returns 0 on success
    fn<i32(blockdev*, u64, u64, void*)> write;      //writes some sectors to the provided block device from the provided buffer. returns 0 on success
}

struct blockdev {
    u64 type;
    i32 is_root;
    u64 block_size;         //block size in bytes of underlying driver  

    // root
    void* resource_ptr;
    blockdev_ops* ops;

    // not root
    blockdev* parent;       
    u64 lba_start;          //start of this device partition
    u8 partition_type;      //partition type indicator from MBR (GPT has different structure)
}

i32 blockdev_read(blockdev* dev, u64 lba_start, u64 count, void* buf) {
    while(!(dev->is_root)) {
        lba_start += dev->lba_start;
        dev = dev->parent;
    }
    assert(dev->lba_start == 0x0, "blockdev_read() : lba_start should be 0 for root block devices");
    return dev->ops->read#(dev, lba_start, count, buf);
}

i32 blockdev_write(blockdev* dev, u64 lba_start, u64 count, void* buf) {
    while(!(dev->is_root)) {
        lba_start += dev->lba_start;
        dev = dev->parent;
    }
    assert(dev->lba_start == 0x0, "blockdev_read() : lba_start should be 0 for root block devices");
    return dev->ops->write#(dev, lba_start, count, buf);
} 

// flushes entry and deallocates any external memory related to the entry
i32 blockdev_evict_ent(blockdev_cache_ent* ent) {
    assert(ent->refcount == 0x0, "blockdev_evict_ent() : trying to evict ent with non-zero refcount");

    //flush 
    i32 status = blockdev_flush_ent(ent);
    if(status) return status;

    //dealloc buffer
    free(ent->buf, ent->dev->block_size);

    //remove map entry
    pair<blockdev*, u64> key = new pair<blockdev*, u64>(ent->dev, ent->lba);
    if(!BLOCKDEV_CACHE_MAP->erase(key)) {
        panic("blockdev_evict_ent() : should contain entry");
    }   

    ent->occupied = 0;
    return 0;
}

// allocates entry and populates buffer via input buffer
blockdev_cache_ent* blockdev_alloc_ent(blockdev* dev, u64 lba, void* buf) {
    u64 itercnt = 0x0;
    blockdev_cache_ent* ent;
    u64 ent_ind;
    while(1) {
        if(itercnt == BLOCKDEV_CACHE_SIZE * 0x2) {
            //made two rounds but still no evictable cache slots
            panic("blockdev_alloc_ent() : blockdev cache full");
        }
        itercnt ++;
        
        ent_ind = BLOCKDEV_CACHE_CLOCK_PTR;
        ent = @(BLOCKDEV_CACHE[BLOCKDEV_CACHE_CLOCK_PTR ++]);
        if(BLOCKDEV_CACHE_CLOCK_PTR == BLOCKDEV_CACHE_SIZE) {
            BLOCKDEV_CACHE_CLOCK_PTR = 0x0;
        }

        i32 allocd = 0;
        while(1) {
            if(!ent->occupied) {
                //unoccupied slot, go ahead and take this one
                memset($void* ent, 0, sizeof(blockdev_cache_ent));
                allocd = 1;
                break;
            }

            //if the entry still has references, can't evict
            if(ent->refcount != 0x0) {
                break;
            }

            //if the entry still has clock set, can't evict, but set clock to 0
            if(ent->clock) {
                ent->clock = 0;
                break;
            }

            //otherwise, ent has no references and is out of second chances, evict and return
            if(blockdev_evict_ent(ent)) {
                panic("blockdev_alloc_ent() : evict failed");
            }
            memset($void* ent, 0, sizeof(blockdev_cache_ent));
            allocd = 1;
            break;
        }
        if(allocd) break;
    }

    //populate ent
    ent->occupied = 1;
    ent->clock = 1;
    ent->refcount = 0x0;
    ent->dirty = 0;
    ent->dev = dev;
    ent->lba = lba;
    ent->buf = malloc(dev->block_size);
    memcpy(ent->buf, buf, dev->block_size);

    //add map entry
    pair<blockdev*, u64> key = new pair<blockdev*, u64>(ent->dev, ent->lba);
    assert(!BLOCKDEV_CACHE_MAP->contains(key), "blockdev_alloc_ent() : map should not contain this ent yet");
    BLOCKDEV_CACHE_MAP->insert(key, ent_ind);

    return ent;
}

// writes the buffer back to the underlying block device and unmarks the entry as dirty
i32 blockdev_flush_ent(blockdev_cache_ent* ent) {
    //see if we need to flush
    if(!ent->dirty) return 0;   
    i32 status = blockdev_write(ent->dev, ent->lba, 0x1, ent->buf);
    if(status) return status;   //flush failed
    ent->dirty = 0; 
    return 0;
} 

blockdev_cache_ent* blockdev_get_ent(blockdev* dev, u64 lba, i32 assert_existing) {
    pair<blockdev*, u64> key = new pair<blockdev*, u64>(dev, lba);
    blockdev_cache_ent* out_ent;
    if(BLOCKDEV_CACHE_MAP->contains(key)) {
        u64 ind = BLOCKDEV_CACHE_MAP->get(key);
        out_ent = @(BLOCKDEV_CACHE[ind]);
    }
    else {
        if(assert_existing) {
            panic("blockdev_get_ent() : this entry should exist in the cache");
        }

        //cache miss, read some blocks into the cache
        //for now, just have a fixed read-ahead
        // TODO 
        // - make sure we don't read past end of blockdev
        // - have some way to configure read-ahead amount
        u64 amt_bytes = 0x1 << $u64 16;  //65536
        assert(dev->block_size <= amt_bytes, "blockdev_get_ent() : those are some big blocks D:");
        u64 amt_blocks = amt_bytes / dev->block_size;
        assert(amt_blocks * dev->block_size == amt_bytes, "blockdev_get_ent() : these should line up");
        void* buf = malloc(amt_bytes);

        //read from device
        i32 read_status = blockdev_read(dev, lba, amt_blocks, buf);
        if(read_status) panic("blockdev_get_ent() : read failed D:");

        //register blocks in cache
        for(u64 i = 0x0; i < amt_blocks; i++) {
            blockdev_cache_ent* cent = blockdev_alloc_ent(dev, lba + i, $void* ($u64 buf + i * dev->block_size));
            if(i == 0x0) {
                //inc ref of returned ent so it doesn't get evicted
                out_ent = cent;
                out_ent->refcount ++;
            }
        }
        //this function shouldn't alloc ref, so dec ref back
        out_ent->refcount --;
        free(buf, amt_bytes);
    }
    assert(out_ent != nullptr, "blockdev_get_ent() : null out_ent");

    //reset clock on hit
    out_ent->clock = 1;
    return out_ent;
}

//returns a managed pointer to a buffer containing the requested block
//increments the refcount for the requested block
i32 blockdev_bget(blockdev* dev, u64 lba, void*& out_buf) {
    while(!(dev->is_root)) {
        lba += dev->lba_start;
        dev = dev->parent;
    }
    assert(dev->lba_start == 0x0, "blockdev_bget() : lba_start should be 0 for root block devices");

    blockdev_cache_ent* ent = blockdev_get_ent(dev, lba, 0);
    assert(ent != nullptr, "blockdev_bget() : null ent");
    ent->refcount ++;
    out_buf = ent->buf;

    return 0;
}

//decrements the refcount for the requested block
i32 blockdev_bput(blockdev* dev, u64 lba) {
    while(!(dev->is_root)) {
        lba += dev->lba_start;
        dev = dev->parent;
    }
    assert(dev->lba_start == 0x0, "blockdev_bput() : lba_start should be 0 for root block devices");

    //we must be able to find it within the cache
    blockdev_cache_ent* ent = blockdev_get_ent(dev, lba, 1);

    //decrement the refcount
    assert(ent->refcount != 0x0, "blockdev_bput() : zero refcount");
    ent->refcount --;

    return 0;
}

//marks the buffer for the requested block as dirty
//the requested block buffer will be flushed back to the underlying device at some point
i32 blockdev_bdirty(blockdev* dev, u64 lba) {
    while(!(dev->is_root)) {
        lba += dev->lba_start;
        dev = dev->parent;
    }
    assert(dev->lba_start == 0x0, "blockdev_bdirty() : lba_start should be 0 for root block devices");

    //we must be able to find this block within the cache
    blockdev_cache_ent* ent = blockdev_get_ent(dev, lba, 1);

    //mark as dirty
    assert(ent->refcount != 0x0, "blockdev_bput() : zero refcount");
    ent->dirty = 1;

    return 0;
}

[__GLOBAL_FIRST__] u64 BLOCKDEV_BUF_CNT = $u64 0;
[__GLOBAL_FIRST__] u64 BLOCKDEV_BUF_MAX = $u64 32;
[__GLOBAL_FIRST__] blockdev* BLOCKDEV_BUF;

void blockdev_add_dev(blockdev* dev) {
    assert(BLOCKDEV_BUF_CNT < BLOCKDEV_BUF_MAX, "blockdev_add_dev() : too many block devices!!");
    blockdev* ndev = $blockdev* @(BLOCKDEV_BUF[BLOCKDEV_BUF_CNT ++]);
    memcpy($void* ndev, $void* dev, sizeof(blockdev));

    if(dev->is_root) blockdev_find_partitions(ndev);
}

//these should create a block device and add it to the block device buffer
void blockdev_create_ahci(HBA_PORT* hba, u64 block_size) {
    blockdev* dev = $blockdev* malloc(sizeof(blockdev));
    new (dev) blockdev();

    dev->type = BLOCKDEV_TYPE_AHCI;
    dev->is_root = 1;
    dev->block_size = block_size;

    dev->resource_ptr = $void* hba;
    dev->ops = BLOCKDEV_OPS_AHCI;

    blockdev_add_dev(dev);
    free($void* dev, sizeof(blockdev));
}

void blockdev_create_usb_scsi(SCSI_disk* scsi, u64 block_size) {
    blockdev* dev = $blockdev* malloc(sizeof(blockdev));
    new (dev) blockdev();

    dev->type = BLOCKDEV_TYPE_USB_SCSI;
    dev->is_root = 1;
    dev->block_size = block_size;

    dev->resource_ptr = $void* scsi;
    dev->ops = BLOCKDEV_OPS_USB_SCSI;

    blockdev_add_dev(dev);
    free($void* dev, sizeof(blockdev));
}

void blockdev_create_partition(blockdev* dev, u64 lba_start, u8 partition_type) {
    blockdev* ndev = $blockdev* malloc(sizeof(blockdev));
    new (ndev) blockdev();

    ndev->type = BLOCKDEV_TYPE_PARTITION;
    ndev->is_root = 0;
    ndev->block_size = dev->block_size;

    ndev->parent = dev;
    ndev->lba_start = lba_start;
    ndev->partition_type = partition_type;

    blockdev_add_dev(ndev);
    free($void* ndev, sizeof(blockdev));
}

//looks for partitions within the block device 
//dev must be root block device
//only works with MBR for now, TODO add GPT
void blockdev_find_partitions(blockdev* dev) {
    assert(dev->is_root, "blockdev_find_partitions() : cannot find partitions in non-root blockdev");

    mbr* mbr = $mbr* palloc();
    if(blockdev_read(dev, 0x0, 0x1, $void* mbr)) {
        println("blockdev_find_partitions() : read MBR sector failed");
        pfree($void* mbr);
        return;
    }

    if(mbr->signature[0] == $u8 0x55 && mbr->signature[1] == $u8 0xAA) {
        println("blockdev_find_partitions() : found partitioned drive");

        //look through each partition
        for(u64 k = 0x0; k < 0x4; k++) {
            mbr_partition_entry* p = @mbr->partition_entries[k];
            if(p->type == MBR_PARTITION_TYPE_EMPTY) continue;
            println("blockdev_find_partitions() : found MBR partition type : ", $u64 p->type);
            blockdev_create_partition(dev, $u64 p->lba_first, p->type);
        }
    }
    else {
        println("blockdev_find_partitions() : found unpartitioned drive");

        //assume drive is one big partition
        blockdev_create_partition(dev, 0x0, $u8 0x00);
    }

    pfree($void* mbr);
}

//initializes all drivers
//tries to find all supported block devices 
//populates blockdev buffer, up to BLOCKDEV_BUF_MAX devices
void init_blockdev() {
    BLOCKDEV_BUF = $blockdev* malloc(sizeof(blockdev) * BLOCKDEV_BUF_MAX);

    //initialize cache
    BLOCKDEV_CACHE_CLOCK_PTR = 0x0;
    BLOCKDEV_CACHE = $blockdev_cache_ent* malloc(sizeof(blockdev_cache_ent) * BLOCKDEV_CACHE_SIZE);
    memset($void* BLOCKDEV_CACHE, 0, sizeof(blockdev_cache_ent) * BLOCKDEV_CACHE_SIZE);
    BLOCKDEV_CACHE_MAP = $hashmap<pair<blockdev*, u64>, u64>* malloc(sizeof(hashmap<pair<blockdev*, u64>, u64>));
    new (BLOCKDEV_CACHE_MAP) hashmap<pair<blockdev*, u64>, u64>(BLOCKDEV_CACHE_SIZE * 0x2);

    init_ahci_blockdev_ops();
    ahci_find();

    init_scsi_blockdev_ops();
}