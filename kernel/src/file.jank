
[__GLOBAL_FIRST__] u64 O_RDONLY = $u64 1 << $u64 0;
[__GLOBAL_FIRST__] u64 O_WRONLY = $u64 1 << $u64 1;
[__GLOBAL_FIRST__] u64 O_RDWR   = $u64 1 << $u64 2;
[__GLOBAL_FIRST__] u64 O_APPEND = $u64 1 << $u64 3;

[__GLOBAL_FIRST__] u64 FD_TYPE_SERIAL = 0x0;

[__GLOBAL_FIRST__] file_ops* FILE_OPS_SERIAL;

struct file_ops {
    fn<i64(file_descriptor*, u8*, u64)> op_read;
    fn<i64(file_descriptor*, u8*, u64)> op_write;
    fn<i64(file_descriptor*, u64, i32)> op_lseek;
    fn<i32(file_descriptor*)> op_close;
}

struct file_descriptor {
    u64 type;
    void* resource_ptr;
    file_ops* ops;
    u64 position;
    u64 flags;
    u64 refcount;

    //statistics
    u64 bytes_read;
    u64 bytes_written;
    u64 read_count;
    u64 write_count;
}

file_descriptor* create_serial_fd(u64 flags) {
    file_descriptor* fd = $file_descriptor* malloc(sizeof(file_descriptor));
    *fd := new file_descriptor();

    fd->type = FD_TYPE_SERIAL;
    fd->resource_ptr = nullptr;
    fd->ops = FILE_OPS_SERIAL;
    fd->position = 0x0;
    fd->flags = flags;
    fd->refcount = 0x1;

    return fd;
}

i64 fd_read(file_descriptor* fd, u8* buf, u64 amt) {
    i64 retval = fd->ops->op_read#(fd, buf, amt);
    fd->read_count ++;
    if(retval > $i64 0) fd->bytes_read += $u64 retval;
    return $i64 retval;
}

i64 fd_write(file_descriptor* fd, u8* buf, u64 amt) {
    i64 retval = fd->ops->op_write#(fd, buf, amt);
    fd->write_count ++;
    if(retval > $i64 0) fd->bytes_written += $u64 retval;
    return $i64 retval;
}   

i64 fd_lseek(file_descriptor* fd, u64 off, i32 whence) {
    return fd->ops->op_lseek#(fd, off, whence);
}

i32 fd_close(file_descriptor* fd) {
    passert(fd->refcount > 0x0, "fd_close() : file descriptors with 0 references should be already dealloced");
    fd->refcount --;
    i32 retval = 0;
    if(fd->refcount == 0x0) {
        retval = fd->ops->op_close#(fd);
        fd->~();
        free($void* fd, sizeof(file_descriptor));
    }
    return retval;
}