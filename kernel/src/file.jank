
[__GLOBAL_FIRST__] u64 FD_TYPE_SERIAL = 0x0;
[__GLOBAL_FIRST__] u64 FD_TYPE_VFS    = 0x1;

//file descriptor position should be managed internally by these file_ops. 
//position should just be some opaque thing that each fd uses to keep track of where they are. 
//for some file types, position can be well defined, user can modify it via lseek
struct file_ops {
    fn<i64(file_descriptor*, u8*, u64)> op_read;            //reads some bytes into the provided buffer, returns the number of bytes read or -1
    fn<i64(file_descriptor*, u8*, u64)> op_write;           //writes some bytes from the provided buffer, returns the number of bytes read or -1
    fn<i64(file_descriptor*, u64, i32)> op_lseek;           //moves the fd position, returns the new position or -1
    fn<i64(file_descriptor*, u8*, u64)> op_getdents;        //reads directory entries into provided buffer, returns number of bytes read
    fn<i32(file_descriptor*)> op_close;                     //closes the fd and underlying resource
}

struct file_descriptor {
    u64 type;
    void* resource_ptr;
    file_ops* ops;
    u64 position;
    u64 flags;
    u64 refcount;

    //statistics
    u64 bytes_read;
    u64 bytes_written;
    u64 read_count;
    u64 write_count;
}

file_descriptor* fd_create_serial(u64 flags) {
    file_descriptor* fd = $file_descriptor* malloc(sizeof(file_descriptor));
    new (fd) file_descriptor();

    fd->type = FD_TYPE_SERIAL;
    fd->resource_ptr = nullptr;
    fd->ops = FILE_OPS_SERIAL;
    fd->position = 0x0;
    fd->flags = flags;
    fd->refcount = 0x1;

    return fd;
}

//inode should already have a reference allocated to it. 
file_descriptor* fd_create_vfs(u64 flags, vfs_inode* inode) {
    file_descriptor* fd = $file_descriptor* malloc(sizeof(file_descriptor));
    new (fd) file_descriptor();

    fd->type = FD_TYPE_VFS;
    fd->resource_ptr = $void* inode;
    fd->ops = FILE_OPS_VFS;
    fd->position = 0x0;
    fd->flags = flags;
    fd->refcount = 0x1;

    return fd;
}

i64 fd_read(file_descriptor* fd, u8* buf, u64 amt) {
    i64 retval = fd->ops->op_read#(fd, buf, amt);
    fd->read_count ++;
    if(retval > $i64 0) fd->bytes_read += $u64 retval;
    return $i64 retval;
}

i64 fd_write(file_descriptor* fd, u8* buf, u64 amt) {
    i64 retval = fd->ops->op_write#(fd, buf, amt);
    fd->write_count ++;
    if(retval > $i64 0) fd->bytes_written += $u64 retval;
    return $i64 retval;
}   

i64 fd_lseek(file_descriptor* fd, u64 off, i32 whence) {
    return fd->ops->op_lseek#(fd, off, whence);
}

i64 fd_getdents(file_descriptor* fd, u8* buf, u64 amt) {
    i64 retval = fd->ops->op_getdents#(fd, buf, amt);
    return $i64 retval;
}

i32 fd_close(file_descriptor* fd) {
    passert(fd->refcount > 0x0, "fd_close() : file descriptors with 0 references should be already dealloced");
    fd->refcount --;
    i32 retval = 0;
    if(fd->refcount == 0x0) {
        retval = fd->ops->op_close#(fd);
        fd->~();
        free($void* fd, sizeof(file_descriptor));
    }
    return retval;
}