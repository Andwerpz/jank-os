// USB core
// each interface on a device should correspond to some driver

// all USB descriptors should have this as their header
struct USB_descriptor_header {
    u8 bLength;
    u8 bDescriptorType;
}

// standard USB descriptors : https://www.beyondlogic.org/usbnutshell/usb5.shtml
struct USB_device_descriptor {
    u8 bLength;                 // = 18 
    u8 bDescriptorType;         // = 1
    u16 bcdUSB;                 
    u8 bDeviceClass;            
    u8 bDeviceSubclass;         
    u8 bDeviceProtocol;         
    u8 bMaxPacketSize;          // maximum packet size for EP0
    u16 idVendor;               
    u16 idProduct;
    u16 bcdDevice;
    u8 iManufacturer;
    u8 iProduct;
    u8 iSerialNumber;
    u8 bNumConfigurations;
}

struct USB_configuration_descriptor {
    u8 bLength;                 
    u8 bDescriptorType;         // = 2
    u16 wTotalLength;           
    u8 bNumInterfaces;          
    u8 bConfigurationValue;     // value to use when selecting this configuration
    u8 iConfiguration;          // index of string descriptor describing this configuration
    u8 bmAttributes;            // bit 6 : self powered, bit 5 : remote wakeup
    u8 bMaxPower;               // max power consumption in 2mA units
}

struct USB_interface_descriptor {
    u8 bLength;                 
    u8 bDescriptorType;
    u8 bInterfaceNumber;        // interface number, one interface can have multiple alternate settings
    u8 bAlternateSetting;       // value used to select alternate setting. if this is 0, this is the default setting
    u8 bNumEndpoints;           
    u8 bInterfaceClass;         // class code (assigned by USB.org)
    u8 bInterfaceSubClass;      // subclass code (assigned by USB.org)
    u8 bInterfaceProtocol;      // protocol code (assigned by USB.org)
    u8 iInterface;              // index of string descriptor describing this interface
}

struct USB_endpoint_descriptor {
    u8 bLength;                 // = 7
    u8 bDescriptorType;         // = 5
    u8 bEndpointAddress;        // bits 0123 : endpoint number, bit 7 : direction 0=out 1=in
    u8 bmAttributes;            // bits 01 : transfer type, rest of bits only matter for isochronous endpoints
    u16 wMaxPacketSize;         // maximum packet size this endpoint is capable of sending or receiving
    u8 bInterval;               // interval for polling endpoint data transfers
}

// https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/usbspec/ns-usbspec-_usb_hub_descriptor
struct USB_hub_descriptor {
    u8 bLength;
    u8 bDescriptorType;
    u8 bNumberOfPorts;
    u16 wHubCharacteristics;
    u8 bPowerOnToPowerGood;
    u8 bHubControlCurrent;
    u8[64] bRemoveAndPowerMask;
}

// USB standard requests
// bRequest constants (Setup Stage field)
// https://www.beyondlogic.org/usbnutshell/usb6.shtml
[__GLOBAL_FIRST__] u32 USB_REQUEST_GET_STATUS           = $u32 0x00;
[__GLOBAL_FIRST__] u32 USB_REQUEST_CLEAR_FEATURE        = $u32 0x01;
[__GLOBAL_FIRST__] u32 USB_REQUEST_SET_FEATURE          = $u32 0x03;
[__GLOBAL_FIRST__] u32 USB_REQUEST_SET_ADDRESS          = $u32 0x05;
[__GLOBAL_FIRST__] u32 USB_REQUEST_GET_DESCRIPTOR       = $u32 0x06;
[__GLOBAL_FIRST__] u32 USB_REQUEST_SET_DESCRIPTOR       = $u32 0x07;
[__GLOBAL_FIRST__] u32 USB_REQUEST_GET_CONFIGURATION    = $u32 0x08;
[__GLOBAL_FIRST__] u32 USB_REQUEST_SET_CONFIGURATION    = $u32 0x09;
[__GLOBAL_FIRST__] u32 USB_REQUEST_GET_INTERFACE        = $u32 0x0A;
[__GLOBAL_FIRST__] u32 USB_REQUEST_SET_INTERFACE        = $u32 0x0B;

// bmRequestType constants (Setup Stage field)
[__GLOBAL_FIRST__] u32 USB_REQUEST_TYPE_DIR_MASK            = $u32 0b10000000;
[__GLOBAL_FIRST__] u32 USB_REQUEST_TYPE_TYPE_MASK           = $u32 0b01100000;
[__GLOBAL_FIRST__] u32 USB_REQUEST_TYPE_RECIPIENT_MASK      = $u32 0b00011111;
[__GLOBAL_FIRST__] u32 USB_REQUEST_TYPE_DIR_OUT             = $u32 0b00000000;
[__GLOBAL_FIRST__] u32 USB_REQUEST_TYPE_DIR_IN              = $u32 0b10000000;
[__GLOBAL_FIRST__] u32 USB_REQUEST_TYPE_TYPE_STANDARD       = $u32 0b00000000;
[__GLOBAL_FIRST__] u32 USB_REQUEST_TYPE_TYPE_CLASS          = $u32 0b00100000;
[__GLOBAL_FIRST__] u32 USB_REQUEST_TYPE_TYPE_VENDOR         = $u32 0b01000000;
[__GLOBAL_FIRST__] u32 USB_REQUEST_TYPE_RECIPIENT_DEVICE    = $u32 0b00000000;
[__GLOBAL_FIRST__] u32 USB_REQUEST_TYPE_RECIPIENT_INTERFACE = $u32 0b00000001;
[__GLOBAL_FIRST__] u32 USB_REQUEST_TYPE_RECIPIENT_ENDPOINT  = $u32 0b00000010;
[__GLOBAL_FIRST__] u32 USB_REQUEST_TYPE_RECIPIENT_OTHER     = $u32 0b00000011;

// USB descriptor types
[__GLOBAL_FIRST__] u32 USB_DESCRIPTOR_TYPE_DEVICE                      = $u32 1;        // standard
[__GLOBAL_FIRST__] u32 USB_DESCRIPTOR_TYPE_CONFIGURATION               = $u32 2;        // standard
[__GLOBAL_FIRST__] u32 USB_DESCRIPTOR_TYPE_STRING                      = $u32 3;        // standard
[__GLOBAL_FIRST__] u32 USB_DESCRIPTOR_TYPE_INTERFACE                   = $u32 4;        // standard
[__GLOBAL_FIRST__] u32 USB_DESCRIPTOR_TYPE_ENDPOINT                    = $u32 5;        // standard    
[__GLOBAL_FIRST__] u32 USB_DESCRIPTOR_TYPE_DEVICE_QUALIFIER            = $u32 6;        // standard         
[__GLOBAL_FIRST__] u32 USB_DESCRIPTOR_TYPE_OTHER_SPEED_CONFIGURATION   = $u32 7;        // standard
[__GLOBAL_FIRST__] u32 USB_DESCRIPTOR_TYPE_INTERFACE_POWER             = $u32 8;        // standard
[__GLOBAL_FIRST__] u32 USB_DESCRIPTOR_TYPE_HUB                         = $u32 0x29;     // class

// string descriptor language IDs
[__GLOBAL_FIRST__] u16 USB_LANGID_ENGLISH_US      = $u16 0x0409;
[__GLOBAL_FIRST__] u16 USB_LANGID_ENGLISH_AUS     = $u16 0x0C09;

struct USB_device { 
    u64 dev_idx;            // index in the global USB_DEVICES array
    USB_device* parent;     // only null if this is dummy root device
    u64 refcnt;             

    //hub devices
    i32 is_hub;
    USB_endpoint* ep_intr_in;
    u64 nr_ports;
    USB_device** children;  // array of pointers to children. Find children using their port index (1-indexed). should only be not nullptr if this is a USB hub device
    i32* child_present;     // signals whether a child is present at some port index

    i32 configured;
    u32 port;               // port index on the parent hub
    u32 slot;               // xHCI slot index of this device
    u64 ep0_max_packet_size;
    string desc_str;        // string describing this device
    vector<USB_configuration*> configurations;

    USB_device(u64 dev_idx) {
        this.dev_idx = dev_idx;
        this.configured = 0;
    }

    ~USB_device() {
        assert(this.refcnt == 0x0, "~USB_device() : non-zero refcnt");

        panic("shouldn\'t be freeing devices, haven\'t implemented hotplug yet");

        if(this.is_hub) {
            assert(this.children != nullptr, "~USB_device() : null children");
            assert(this.child_present != nullptr, "~USB_device() : null child_present");
            free($void* this.children, sizeof(USB_device*) * (this.nr_ports + 0x1));
            free($void* this.child_present, sizeof(i32) * (this.nr_ports + 0x1));
        }

        for(u64 i = 0x0; i < this.configurations.size(); i++) {
            this.configurations[i]->~();
            free($void* this.configurations[i], sizeof(USB_configuration));
        }
        xhci_free_slot(this.slot);  //this should be freed when we transition from CONNECTED to DISCONNECTED state? 
    }
}

//information about an active USB transfer
//transfer event handler should find a corresponding USB_transfer struct, populate it, and wake waiters / call callback
struct USB_transfer {
    USB_device* dev;
    u64 refcnt;
    u32 slot;
    u32 endpoint;
    u32 interrupter;
    u64 trb_ptr;
    u64 amt;

    i32 is_done;
    i64 status; 
    waitq wait_queue;
    i32 has_callback;
    fn<void(USB_transfer*)> callback;
}

[__GLOBAL_FIRST__] USB_device* USB_DEVICES;
[__GLOBAL_FIRST__] i32* USB_DEVICE_USED;
[__GLOBAL_FIRST__] u64 USB_MAX_DEVICES = $u64 512;

// dummy root hub device, root of USB device tree
[__GLOBAL_FIRST__] USB_device* USB_ROOT_DEVICE;

[__GLOBAL_FIRST__] u64 USB_MAX_TRANSFERS = $u64 128;
[__GLOBAL_FIRST__] i32* USB_TRANSFER_PRESENT;
[__GLOBAL_FIRST__] USB_transfer* USB_TRANSFERS;

struct USB_configuration {
    vector<USB_interface*> interfaces;
    u64 configuration_value;

    ~USB_configuration() {
        for(u64 i = 0x0; i < this.interfaces.size(); i++) {
            this.interfaces[i]->~();
            free($void* this.interfaces[i], sizeof(USB_interface));
        }
    }
}

struct USB_interface {
    vector<USB_endpoint*> endpoints;
    u64 interface_number;
    u64 alternate_setting_value;

    //can identify the intended type of this interface from these fields
    u8 class;
    u8 subclass;
    u8 protocol;

    ~USB_interface() {
        for(u64 i = 0x0; i < this.endpoints.size(); i++) {
            this.endpoints[i]->~();
            free($void* this.endpoints[i], sizeof(USB_endpoint));
        }
    }
}

[__GLOBAL_FIRST__] u8 USB_ENDPOINT_TRANSFER_TYPE_CONTROL        = $u8 0;
[__GLOBAL_FIRST__] u8 USB_ENDPOINT_TRANSFER_TYPE_ISOCHRONOUS    = $u8 1;
[__GLOBAL_FIRST__] u8 USB_ENDPOINT_TRANSFER_TYPE_BULK           = $u8 2;
[__GLOBAL_FIRST__] u8 USB_ENDPOINT_TRANSFER_TYPE_INTERRUPT      = $u8 3;

struct USB_endpoint {
    u32 endpoint;           // DCI endpoint address 
    u32 endpoint_type;      // XHCI_ENDPOINT_TYPE_*
    u64 max_packet_size;    // in bytes
    u64 interval;           // only matters for Interrupt + Isochronous endpoints

    // USB3 endpoints
    // TODO read descriptor type 48 for usb 'superspeed' related information

    ~USB_endpoint() {

    }
}

[__GLOBAL_FIRST__] u8 USB_CLASS_HID             = $u8 0x03; // Human Interface Device
[__GLOBAL_FIRST__] u8 USB_CLASS_MASS_STORAGE    = $u8 0x08;
[__GLOBAL_FIRST__] u8 USB_CLASS_HUB             = $u8 0x09;

[__GLOBAL_FIRST__] u8 USB_SUBCLASS_SCSI = $u8 0x06;
[__GLOBAL_FIRST__] u8 USB_PROTOCOL_BOT = $u8 0x50;  // bulk only transfers

void init_usb() {
    if(!XHCI_DID_INIT) {
        println("init_usb() : no xHCI controller found, cannot init usb");
        return;
    }

    assert(XHCI_DID_INIT, "init_usb() : need to have XHCI");
    println("start init usb");

    assert(sizeof(USB_device_descriptor) == $u64 18, "init_usb() : sizeof(device_descriptor) should be 18");
    assert(sizeof(USB_configuration_descriptor) == $u64 9, "init_usb() : sizeof(configuration_descriptor) should be 9");
    assert(sizeof(USB_interface_descriptor) == $u64 9, "init_usb() : sizeof(interface_descriptor) should be 9");
    assert(sizeof(USB_endpoint_descriptor) == $u64 7, "init_usb() : sizeof(endpoint_descriptor) should be 7");

    //initialize USB transfer array
    USB_TRANSFERS = $USB_transfer* malloc(sizeof(USB_transfer) * USB_MAX_TRANSFERS);
    USB_TRANSFER_PRESENT = $i32* malloc(sizeof(i32) * USB_MAX_TRANSFERS);
    memset($void* USB_TRANSFERS, 0, sizeof(USB_transfer) * USB_MAX_TRANSFERS);
    memset($void* USB_TRANSFER_PRESENT, 0, sizeof(i32) * USB_MAX_TRANSFERS);

    //initialize device allocator
    USB_DEVICES = $USB_device* malloc(sizeof(USB_device) * USB_MAX_DEVICES);
    USB_DEVICE_USED = $i32* malloc(sizeof(i32) * USB_MAX_DEVICES);
    for(u64 i = 0x0; i < USB_MAX_DEVICES; i++) {
        USB_DEVICE_USED[i] = 0;
    }

    //create root hub device
    USB_ROOT_DEVICE = usb_alloc_device();
    USB_ROOT_DEVICE->is_hub = 1;
    USB_ROOT_DEVICE->nr_ports = XHCI_MAX_PORTS;
    USB_ROOT_DEVICE->children = $USB_device** malloc(sizeof(USB_device*) * (XHCI_MAX_PORTS + 0x1));
    USB_ROOT_DEVICE->child_present = $i32* malloc(sizeof(i32) * (XHCI_MAX_PORTS + 0x1));
    for(u64 i = 0x0; i <= XHCI_MAX_PORTS; i++) {
        USB_ROOT_DEVICE->child_present[i] = 0;
    }
    USB_ROOT_DEVICE->desc_str = "USB Root";

    //do root ports sweep
    println("Root ports sweep : ", XHCI_MAX_PORTS);
    for(u32 i = $u32 0x1; i <= $u32 XHCI_MAX_PORTS; i++) {
        //check if anything is connected here
        if(!xhci_port_is_device_connected(i)) {
            //nothing connected
            println("Nothing on port : ", i);
            continue;
        }   
        println("Found something on port : ", i);

        //index device
        USB_device* dev = usb_index_device(USB_ROOT_DEVICE, i);
        println("Done indexing device");

        //configure device
        usb_configure_device(dev);
        println("Done configuring device");
    }

    println("USB Device Tree : ");
    usb_print_devtree();

    // panic("stop here for now");

    println("done init usb");
}


// -- USB device --
//configures the provided USB device
//should only be called once per device
//also makes device interfaces public for use elsewhere (BOT -> blockdev for example)
void usb_configure_device(USB_device* dev) {
    assert(!dev->configured, "usb_configure_device() : device has already been configured");
    dev->configured = 1;

    //choose configuration
    //for now, always choose the first configuration
    assert(dev->configurations.size() != 0x0, "usb_configure_device() : device has no configurations");
    USB_configuration* cfg = dev->configurations[0];

    //choose interface settings
    //for now, always choose default settings
    vector<USB_interface*> selected_interfaces;
    for(u64 i = 0x0; i < cfg->interfaces.size(); i++) {
        USB_interface* int = cfg->interfaces[i];
        if(int->alternate_setting_value != 0x0) {
            //not default, skip this one
            continue;
        }

        //select this one
        selected_interfaces.push_back(int);
    }

    vector<USB_endpoint*> selected_endpoints;
    for(u64 i = 0x0; i < selected_interfaces.size(); i++) {
        USB_interface* int = selected_interfaces[i];
        for(u64 j = 0x0; j < int->endpoints.size(); j++) {
            selected_endpoints.push_back(int->endpoints[j]);
        }
    }

    //configure device itself
    //all interfaces will be enabled with their default settings (alternate_setting_value = 0)
    usb_device_set_configuration(dev, $u32 cfg->configuration_value);

    //configure endpoint for xHC
    {
        void* buf = palloc();
        memset(buf, 0, PAGE_SIZE);

        // - Input Control Context -
        xHCI_input_control_ctx32* icc = $xHCI_input_control_ctx32* buf;
        icc->drop_context_flags = $u32 0;
        icc->add_context_flags = $u32 ((1 << 0));                   //slot

        u32 last_ctx_entry = $u32 XHCI_EP0;
        for(u64 i = 0x0; i < selected_endpoints.size(); i++) {
            USB_endpoint* end = selected_endpoints[i];
            u32 dci = $u32 end->endpoint;
            assert(dci > $u32 XHCI_EP0, "usb_configure_device() : DCI should not be EP0 or slot");
            assert((icc->add_context_flags & ($u32 1 << dci)) == $u32 0, "usb_configure_device() : duplicate endpoint");
            icc->add_context_flags |= ($u32 1 << dci);
            if(dci > last_ctx_entry) last_ctx_entry = dci;
        }

        // - Slot Context -
        //copy over slot context from output device context
        void* dev_ctx_buf = xhci_get_slot_device_ctx(dev->slot);
        xHCI_slot_ctx32* slot = $xHCI_slot_ctx32* ($u64 buf + $u64 32);
        memcpy($void* slot, dev_ctx_buf, sizeof(xHCI_slot_ctx32));
        
        //update last valid context entry
        slot->dev_info0 = (slot->dev_info0 & $u32 0xF8000000) | (last_ctx_entry << $u32 27);

        // - other endpoints -
        for(u64 i = 0x0; i < selected_endpoints.size(); i++) {
            USB_endpoint* end = selected_endpoints[i];
            u32 dci = $u32 end->endpoint;
            u32 endpoint_type = end->endpoint_type;
            u64 ep_ring_phys = $u64 xhci_get_slot_transfer_ring(dev->slot, dci);
            assert(dci > $u32 XHCI_EP0, "usb_configure_device() : DCI should not be EP0 or slot");

            xHCI_endpoint_ctx32* ep_ctx = $xHCI_endpoint_ctx32* ($u64 buf + $u64 32 * ($u64 dci + 0x1));
            xhci_build_endpoint_ctx32(
                ep_ctx,
                $u32 3,                         // cerr
                endpoint_type,                  // endpoint type
                $u32 0,                         // max burst size
                $u32 end->max_packet_size,      // max packet size
                1,                              // DCS
                ep_ring_phys,                   // transfer ring pointer
                $u32 8                          // average TRB length
            );
        }

        //configure endpoints
        xhci_configure_endpoint(dev->slot, $u64 buf);

        pfree(buf);
    }

    //classify selected interfaces
    for(u64 i = 0x0; i < selected_interfaces.size(); i++) {
        USB_interface* int = cfg->interfaces[i];
        u8 class = int->class;
        u8 subclass = int->subclass;
        u8 protocol = int->protocol;

        if(class == USB_CLASS_MASS_STORAGE && subclass == USB_SUBCLASS_SCSI && protocol == USB_PROTOCOL_BOT) {
            // SCSI BOT storage device
            //see if we can uniquely identify a bulk_in and bulk_out endpoint
            i32 is_valid = 1;
            USB_endpoint* bulk_in = $USB_endpoint* nullptr;
            USB_endpoint* bulk_out = $USB_endpoint* nullptr;
            for(u64 j = 0x0; j < int->endpoints.size(); j++) {
                USB_endpoint* end = int->endpoints[j];
                if(end->endpoint_type == XHCI_ENDPOINT_TYPE_BULK_IN) {
                    if(bulk_in != nullptr) is_valid = 0;
                    bulk_in = end;
                }
                else if(end->endpoint_type == XHCI_ENDPOINT_TYPE_BULK_OUT) {
                    if(bulk_out != nullptr) is_valid = 0;
                    bulk_out = end;
                }
            }
            if(bulk_in == nullptr || bulk_out == nullptr) is_valid = 0;
            if(!is_valid) continue;

            println("Found SCSI BOT Storage Device");
            MSC_BOT* bot = $MSC_BOT* malloc(sizeof(MSC_BOT));
            new (bot) MSC_BOT();
            bot->dev = dev;
            bot->bulk_in = bulk_in;
            bot->bulk_out = bulk_out;

            SCSI_disk* scsi = $SCSI_disk* malloc(sizeof(SCSI_disk));
            new (scsi) SCSI_disk();
            scsi->bot = bot;

            assert(sizeof(BOT_CBW) == $u64 31, "CBW bruh");
            assert(sizeof(BOT_CSW) == $u64 13, "CSW bruh");
            
            u64 last_lba;
            u64 block_size;
            scsi_read_capacity(scsi, last_lba, block_size);
            scsi->block_size = block_size;

            println("Last LBA : ", $void* last_lba);
            println("Block Size : ", block_size);

            blockdev_create_usb_scsi(scsi, block_size);
            println("USB SCSI block device created");
        }  
        else if(class == USB_CLASS_HUB) {
            // USB hub
            //if we can find an interrupt IN endpoint, then we can classify this device as a hub
            i32 is_valid = 1;
            USB_endpoint* intr_in = $USB_endpoint* nullptr;
            for(u64 j = 0x0; j < int->endpoints.size(); j++) {
                USB_endpoint* end = int->endpoints[j];
                if(end->endpoint_type == XHCI_ENDPOINT_TYPE_INTERRUPT_IN) {
                    if(intr_in != nullptr) is_valid = 0;
                    intr_in = end;
                }
            }
            if(intr_in == nullptr) is_valid = 0;
            if(!is_valid) continue;

            println("Found USB Hub");
            dev->is_hub = 1;
            dev->ep_intr_in = intr_in;
        }
    }

    // if we classified this device as a hub, initialize related stuff here
    if(dev->is_hub) {
        //get hub descriptor
        void* buf = palloc();
        u64 transfer_amt = usb_device_get_descriptor_class(dev, USB_DESCRIPTOR_TYPE_HUB, $u32 0, buf, sizeof(USB_hub_descriptor));
        assert(transfer_amt == sizeof(USB_hub_descriptor), "usb_configure_device() : should fully transfer hub descriptor");
        USB_hub_descriptor* hub_desc = $USB_hub_descriptor* buf;

        // find nr ports
        u64 nr_ports = $u64 hub_desc->bNumberOfPorts;
        dev->nr_ports = nr_ports;
        dev->children = $USB_device** malloc(sizeof(USB_device*) * (nr_ports + 0x1));
        dev->child_present = $i32* malloc(sizeof(i32) * (nr_ports + 0x1));
        for(u64 i = 0x0; i <= nr_ports; i++) {
            dev->child_present[i] = 0;
        }

        println("Hub Nr Ports : ", nr_ports);

        // scan ports for connected devices
        // TODO

        // dispatch port status callback 
        // TODO

        pfree(buf);
    }
}

string usb_get_string_descriptor(USB_device* dev, u32 index, u32 lang) {
    assert(index != $u32 0, "usb_get_string_descriptor() : index = 0 indicates invalid string descriptor");

    u64 transfer_amt;
    void* buf = palloc();

    //extract header    
    transfer_amt = usb_device_get_descriptor(dev, USB_DESCRIPTOR_TYPE_STRING, index, lang, buf, 0x2);
    assert(transfer_amt == 0x2, "usb_get_string_descriptor() : should transfer full thing");

    //extract entire descriptor
    u64 desc_len = $u64 ($USB_descriptor_header* buf)->bLength;
    assert(desc_len >= 0x2, "usb_get_string_descriptor() : desc_len should be at least size of header");
    transfer_amt = usb_device_get_descriptor(dev, USB_DESCRIPTOR_TYPE_STRING, index, lang, buf, desc_len);
    assert(transfer_amt == desc_len, "usb_get_string_descriptor() : should transfer full thing x2");
    string str = new string($u8* ($u64 buf + 0x2), desc_len - 0x2);

    pfree(buf);
    return str;
}   

//initializes the port and creates a new USB_device struct at the first available slot
//does not enable any configurations, just indexes the device
// TODO need to do stuff differently if parent is not the root
USB_device* usb_index_device(USB_device* parent, u32 port) {
    assert(parent == USB_ROOT_DEVICE, "usb_index_device() : not handling hubs for now");
    assert(parent->children != nullptr, "usb_index_device() : parent children array is nullptr");
    assert(xhci_port_is_device_connected(port), "usb_index_device() : no device to index");
    
    //initialize port
    u32 slot = xhci_initialize_port(port);

    //alloc child, register as child in parent
    USB_device* dev = usb_alloc_device();
    dev->port = port;
    dev->slot = slot;
    dev->parent = parent;
    assert(!parent->child_present[port], "usb_index_device() : parent already has child at this port");
    usb_device_inc_refcnt(parent);
    parent->children[port] = dev;
    parent->child_present[port] = 1;

    //descriptor transfer buffer
    void* buf = palloc();
    u64 transfer_amt;

    //find supported langid
    u16 langid = $u16 0;
    {
        transfer_amt = usb_device_get_descriptor(dev, USB_DESCRIPTOR_TYPE_STRING, $u32 0, $u32 0, buf, 0x4);
        u64 descriptor_len = $u64 ($u8* buf)[0];
        if(descriptor_len >= 0x4) {
            //it returned some languages, just take the first one
            langid = ($u16* ($u64 buf + 0x2))[0];
        }
    }

    //get device descriptor
    u64 nr_configurations;
    {
        transfer_amt = usb_device_get_descriptor(dev, USB_DESCRIPTOR_TYPE_DEVICE, $u32 0, $u32 0, buf, sizeof(USB_device_descriptor));
        assert(transfer_amt == sizeof(USB_device_descriptor), "usb_index_device() : failed to transmit entire device descriptor");
        USB_device_descriptor* dev_desc = $USB_device_descriptor* buf;

        nr_configurations = $u64 dev_desc->bNumConfigurations;
        dev->ep0_max_packet_size = $u64 dev_desc->bMaxPacketSize;

        //extract device descriptor string
        if(langid != $u16 0) {
            i32 need_sep = 0;
            if(dev_desc->iManufacturer != $u8 0) {
                dev->desc_str += usb_get_string_descriptor(dev, $u32 dev_desc->iManufacturer, $u32 langid);
                need_sep = 1;
            }
            if(dev_desc->iProduct != $u8 0) {
                if(need_sep) dev->desc_str += ", ";
                dev->desc_str += usb_get_string_descriptor(dev, $u32 dev_desc->iProduct, $u32 langid);
                need_sep = 1;
            }
            if(dev_desc->iSerialNumber != $u8 0) {
                if(need_sep) dev->desc_str += ", ";
                dev->desc_str += usb_get_string_descriptor(dev, $u32 dev_desc->iSerialNumber, $u32 langid);
                need_sep = 1;
            }
        }
        if(dev->desc_str.size() == 0x0) {
            dev->desc_str = "USB Device (no supported language)";
        }
    }
    assert(nr_configurations != 0x0, "usb_index_device() : there should be non-zero amount of configurations I think");
    println("Nr Configurations : ", nr_configurations);

    //index configurations
    for(u64 cfg_ind = 0x0; cfg_ind < nr_configurations; cfg_ind++) {
        //get configuration descriptor
        USB_configuration* cfg = $USB_configuration* malloc(sizeof(USB_configuration));
        new (cfg) USB_configuration();
        u64 cfg_tot_sz;
        u64 nr_interfaces;
        {
            transfer_amt = usb_device_get_descriptor(dev, USB_DESCRIPTOR_TYPE_CONFIGURATION, $u32 cfg_ind, $u32 0, buf, sizeof(USB_configuration_descriptor));
            assert(transfer_amt == sizeof(USB_configuration_descriptor), "usb_index_device() : failed to transmit entire configuration descriptor");
            USB_configuration_descriptor* cfg_desc = $USB_configuration_descriptor* buf;

            cfg_tot_sz = $u64 cfg_desc->wTotalLength;
            nr_interfaces = $u64 cfg_desc->bNumInterfaces;
            cfg->configuration_value = $u64 cfg_desc->bConfigurationValue;
        }
        println("Nr Interfaces : ", nr_interfaces);
        println("Cfg Total Size : ", cfg_tot_sz);   
        assert(cfg_tot_sz <= PAGE_SIZE, "usb_index_device() : for now, can only support transferring up to a page at a time");

        //get entire configuration descriptor
        transfer_amt = usb_device_get_descriptor(dev, USB_DESCRIPTOR_TYPE_CONFIGURATION, $u32 cfg_ind, $u32 0, buf, cfg_tot_sz);
        assert(transfer_amt == cfg_tot_sz, "usb_index_device() : failed to transmit entire configuration data blob");

        //parse remainder of configuration
        u64 buf_ptr = sizeof(USB_configuration_descriptor);
        USB_interface* int = $USB_interface* nullptr;
        USB_endpoint* end = $USB_endpoint* nullptr;
        println(" ");
        while(buf_ptr < cfg_tot_sz) {
            USB_descriptor_header* header = $USB_descriptor_header* ($u64 buf + buf_ptr);
            u64 length = $u64 header->bLength;
            u32 type = $u32 header->bDescriptorType;

            if(type == USB_DESCRIPTOR_TYPE_INTERFACE) {
                if(end != nullptr) {
                    //add previous endpoint to interface
                    int->endpoints.push_back(end);
                    end = $USB_endpoint* nullptr;
                }
                if(int != nullptr) {
                    //add previous interface to configuration
                    cfg->interfaces.push_back(int);
                    int = $USB_interface* nullptr;
                }

                USB_interface_descriptor* int_desc = $USB_interface_descriptor* ($u64 buf + buf_ptr);
                u64 interface_number = $u64 int_desc->bInterfaceNumber;
                u64 alternate_setting_value = $u64 int_desc->bAlternateSetting;
                u64 nr_endpoints = $u64 int_desc->bNumEndpoints;
                u8 class = int_desc->bInterfaceClass;
                u8 subclass = int_desc->bInterfaceSubClass;
                u8 protocol = int_desc->bInterfaceProtocol;

                assert(int == nullptr, "usb_index_device() : need int to be null when overwriting");
                int = $USB_interface* malloc(sizeof(USB_interface));
                new (int) USB_interface();
                int->interface_number = interface_number;
                int->alternate_setting_value = alternate_setting_value;
                int->class = class;
                int->subclass = subclass;
                int->protocol = protocol;

                println("USB Interface Descriptor : ");
                println("Interface Number : ", interface_number);
                println("Alternate Setting Value : ", alternate_setting_value);
                println("Nr Endpoints : ", nr_endpoints);
                println("Class : ", $u64 class);
                println("Subclass : ", $u64 subclass);
                println("Protocol : ", $u64 protocol); 
            }
            else if(type == USB_DESCRIPTOR_TYPE_ENDPOINT) {
                if(end != nullptr) {
                    //add previous endpoint to interface
                    int->endpoints.push_back(end);
                    end = $USB_endpoint* nullptr;
                }

                USB_endpoint_descriptor* ep_desc = $USB_endpoint_descriptor* ($u64 buf + buf_ptr);
                u64 endpoint = $u64 ep_desc->bEndpointAddress;
                u64 attributes = $u64 ep_desc->bmAttributes;
                u64 max_packet_size = $u64 ep_desc->wMaxPacketSize;
                u64 interval = $u64 ep_desc->bInterval;

                //parse attributes
                u32 endpoint_type = $u32 (attributes & 0b11);

                //convert endpoint from USB addr to xHCI DCI
                println("EP : ", $void* endpoint);
                if(endpoint & 0x80) {   
                    // IN endpoint
                    endpoint -= 0x80;
                    endpoint = (endpoint * 0x2) + 0x1;
                    endpoint_type += $u32 4;
                }
                else {
                    // OUT endpoint
                    endpoint = endpoint * 0x2;
                }
                assert(0x1 <= endpoint && endpoint < 0x20, "usb_index_device() : endpoint DCI out of range");

                assert(end == nullptr, "usb_index_device() : need end to be null when overwriting");
                end = $USB_endpoint* malloc(sizeof(USB_endpoint));
                new (end) USB_endpoint();
                end->endpoint = $u32 endpoint;
                end->endpoint_type = endpoint_type;
                end->max_packet_size = max_packet_size;
                end->interval = interval;

                println("USB Endpoint Descriptor : ");
                println("Endpoint : ", endpoint);
                println("Attributes : ", $void* attributes);
                println("Max Packet Size : ", max_packet_size);
                println("Interval : ", interval);
            }
            else {
                println("Unhandled descriptor : ", type);
            }
            println(" ");

            buf_ptr += length;
        }
        assert(buf_ptr == cfg_tot_sz, "usb_index_device() : buf ptr should be at very end of config now");

        if(end != nullptr) {
            //add previous endpoint to interface
            int->endpoints.push_back(end);
            end = $USB_endpoint* nullptr;
        }
        if(int != nullptr) {
            //add previous interface to configuration
            cfg->interfaces.push_back(int);
            int = $USB_interface* nullptr;
        }

        if(cfg->interfaces.size() != nr_interfaces) {
            println("usb_index_device() : interface count does not line up with metadata");
        }

        //add configuration to usb device
        dev->configurations.push_back(cfg);
    }

    pfree(buf);
    return dev;
}

USB_device* usb_alloc_device() {
    for(u64 i = 0x0; i < USB_MAX_DEVICES; i++) {
        if(USB_DEVICE_USED[i]) continue;

        //found device
        USB_device* dev = @(USB_DEVICES[i]);
        USB_DEVICE_USED[i] = 1;
        new (dev) USB_device(i);
        return dev;
    }
    panic("usb_alloc_device() : out of devices");
    return $USB_device* nullptr;
}

void usb_dealloc_device(USB_device* dev) {
    assert(dev != nullptr, "usb_dealloc_device() : null device");
    u64 idx = dev->dev_idx;
    assert(idx < USB_MAX_DEVICES, "usb_dealloc_device() : idx out of bounds");
    assert(USB_DEVICE_USED[idx], "usb_dealloc_device() : device being dealloc\'d should be used");
    assert(@(USB_DEVICES[idx]) == dev, "usb_dealloc_device() : address does not line up");
    assert(dev->refcnt == 0x0, "usb_dealloc_device() : dev still has refs");

    //ok, dealloc device
    USB_DEVICE_USED[idx] = 0;
    dev->~();

    USB_device* parent = dev->parent;
    if(parent != nullptr) {
        u32 port = dev->port;
        assert(parent->children[port] == dev, "usb_dealloc_device() : parent->child mismatch");
        assert(parent->child_present[port], "usb_dealloc_device() : child should be present");
        
        usb_device_dec_refcnt(parent);
        parent->children[port] = $USB_device* nullptr;
        parent->child_present[port] = 0;
    }
}

void usb_device_dec_refcnt(USB_device* dev) {
    assert(dev != nullptr, "usb_device_dec_refcnt() : null dev");
    assert(dev->refcnt != 0x0, "usb_device_dec_refcnt() : zero refs");
    dev->refcnt --;
}

void usb_device_inc_refcnt(USB_device* dev) {
    assert(dev != nullptr, "usb_device_inc_refcnt() : null dev");
    dev->refcnt ++;
}


// -- DEVICE REQUESTS --
//sends a STANDARD SET_CONFIGURATION request 
void usb_device_set_configuration(USB_device* dev, u32 config_value) {
    assert(dev != nullptr, "usb_device_set_configuration() : null dev");

    u32 bm_request_type = USB_REQUEST_TYPE_DIR_OUT | USB_REQUEST_TYPE_TYPE_STANDARD | USB_REQUEST_TYPE_RECIPIENT_DEVICE;
    u32 b_request = USB_REQUEST_SET_CONFIGURATION;
    u32 w_value = config_value;
    u32 w_index = $u32 0;
    u32 w_length = $u32 0;

    u32 trb_status;
    i64 status = xhci_device_request(
        $u32 0,
        dev->slot,
        bm_request_type,
        b_request,
        w_value,
        w_index,
        w_length,
        nullptr,
        trb_status
    );
    assert(status == $i64 0, "usb_device_set_configuration() : should succeed for now");
}

//sends a STANDARD GET_DESCRIPTOR request 
//populates buf with the first amt bytes of the descriptor
//buf must be a physical buffer
//returns the amount actually transferred
u64 usb_device_get_descriptor(USB_device* dev, u32 desc_type, u32 desc_index, u32 lang_index, void* buf, u64 amt) {
    assert(dev != nullptr, "usb_device_get_descriptor() : null dev");
    assert(amt != 0x0, "usb_device_get_descriptor() : amt needs to be non-zero");
    assert(buf != nullptr, "usb_device_get_descriptor() : null buf");
    if(desc_type != USB_DESCRIPTOR_TYPE_STRING) assert(lang_index == $u32 0, "usb_device_get_descriptor() : lang_index must be 0 when not requesting string descriptor");

    u32 bm_request_type = USB_REQUEST_TYPE_DIR_IN | USB_REQUEST_TYPE_TYPE_STANDARD | USB_REQUEST_TYPE_RECIPIENT_DEVICE;
    u32 b_request = USB_REQUEST_GET_DESCRIPTOR;

    // high 8-bit is descriptor type
    // low 8-bit is descriptor index
    u32 w_value = (desc_type << $u32 8) | desc_index;
    u32 w_index = lang_index;
    u32 w_length = $u32 amt;

    u32 trb_status;
    i64 status = xhci_device_request(
        $u32 0,
        dev->slot,
        bm_request_type,
        b_request,
        w_value,
        w_index,
        w_length,
        buf, 
        trb_status
    );
    assert(status >= $i64 0, "usb_device_get_descriptor() : should succeed for now");

    return $u64 status;
}

//sends a CLASS GET_DESCRIPTOR request 
//populates buf with the first amt bytes of the descriptor
//buf must be a physical buffer
//returns the amount actually transferred
u64 usb_device_get_descriptor_class(USB_device* dev, u32 desc_type, u32 desc_index, void* buf, u64 amt) {
    assert(dev != nullptr, "usb_device_get_descriptor_class() : null dev");
    assert(amt != 0x0, "usb_device_get_descriptor_class() : amt needs to be non-zero");
    assert(buf != nullptr, "usb_device_get_descriptor_class() : null buf");
    
    u32 bm_request_type = USB_REQUEST_TYPE_DIR_IN | USB_REQUEST_TYPE_TYPE_CLASS | USB_REQUEST_TYPE_RECIPIENT_DEVICE;
    u32 b_request = USB_REQUEST_GET_DESCRIPTOR;

    // high 8-bit is descriptor type
    // low 8-bit is descriptor index
    u32 w_value = (desc_type << $u32 8) | desc_index;
    u32 w_index = $u32 0;
    u32 w_length = $u32 amt;

    u32 trb_status;
    i64 status = xhci_device_request(
        $u32 0,
        dev->slot,
        bm_request_type,
        b_request,
        w_value,
        w_index,
        w_length,
        buf, 
        trb_status
    );
    assert(status >= $i64 0, "usb_device_get_descriptor_class() : should succeed for now");

    return $u64 status;
}


// -- USB transfer --
// TODO probably need a way to purge stale transfers
//  will have to worry about this when I implement hotplug, 
//  perhaps going around and purging all transfers related to recently disconnected devices

void usb_handle_transfer_event(xHCI_TRB* trb) {
    assert(xhci_trb_type(trb) == XHCI_TRB_TYPE_TRANSFER_EVENT, "usb_handle_transfer_event() : trb is not transfer event trb");

    //find transfer
    u32 slot = xhci_event_trb_slot_id(trb);
    u64 trb_ptr = xhci_event_trb_trb_ptr(trb);
    USB_transfer* transfer = usb_find_transfer(slot, trb_ptr);
    assert(transfer != nullptr, "usb_handle_transfer_event() : null transfer");
    assert(transfer->is_done == 0, "usb_handle_transfer_event() : transfer already done");
    
    //populate transfer status
    if(xhci_event_trb_completion_code(trb) == XHCI_COMPLETION_CODE_SUCCESS) {
        //it gives you the part that wasn't transfered
        transfer->status = $i64 (transfer->amt - $u64 trb->status & 0x00FFFFFF);
    }
    else {
        // TODO consider returning something more informative
        transfer->status = $i64 -1;
    }

    //mark transfer as done
    transfer->is_done = 1;

    //wake waiters + call callback
    waitq_wake_all(@(transfer->wait_queue));
    if(transfer->has_callback) {
        //call the callback
        assert($u64 (transfer->callback) != 0x0, "usb_handle_transfer_event() : null callback");
        transfer->callback#(transfer);
    }

    //drop USB transfer array reference
    usb_transfer_dec_refcnt(transfer);
}

USB_transfer* usb_find_transfer(u32 slot, u64 trb_ptr) {
    for(u64 i = 0x0; i < USB_MAX_TRANSFERS; i++) {
        if(!USB_TRANSFER_PRESENT[i]) continue;

        USB_transfer* transfer = @(USB_TRANSFERS[i]);
        if(transfer->slot != slot || transfer->trb_ptr != trb_ptr) continue;

        //found transfer
        return transfer;
    }

    panic("usb_find_transfer() : failed to find transfer");
    return $USB_transfer* nullptr;
}

void usb_transfer_dec_refcnt(USB_transfer* transfer) {
    assert(transfer != nullptr, "usb_transfer_dec_refcnt() : null transfer");
    assert(transfer->refcnt != 0x0, "usb_transfer_dec_refcnt() : zero refcnt");
    transfer->refcnt --;
    if(transfer->refcnt == 0x0) {
        //dealloc the transfer
        usb_dealloc_transfer(transfer);
    }
}

void usb_transfer_inc_refcnt(USB_transfer* transfer) {
    assert(transfer != nullptr, "usb_transfer_dec_refcnt() : null transfer");
    transfer->refcnt ++;
}

USB_transfer* usb_alloc_transfer() {
    for(u64 i = 0x0; i < USB_MAX_TRANSFERS; i++) {
        if(USB_TRANSFER_PRESENT[i]) continue;

        //ok, alloc transfer
        USB_TRANSFER_PRESENT[i] = 1;
        USB_transfer* transfer = @(USB_TRANSFERS[i]);
        memset($void* transfer, 0, sizeof(USB_transfer));
        new (transfer) USB_transfer();

        //add USB transfer array reference
        usb_transfer_inc_refcnt(transfer);

        return transfer;
    }
    panic("usb_alloc_transfer() : out of transfers");
    return $USB_transfer* nullptr;
}

void usb_dealloc_transfer(USB_transfer* transfer) {
    assert($u64 transfer >= $u64 USB_TRANSFERS, "usb_dealloc_transfer() : transfer address before transfers array");
    assert(($u64 USB_TRANSFERS - $u64 transfer) % sizeof(USB_transfer) == 0x0, "usb_dealloc_transfer() : transfer must be aligned");
    u64 ind = ($u64 USB_TRANSFERS - $u64 transfer) / sizeof(USB_transfer);
    assert(ind < USB_MAX_TRANSFERS, "usb_dealloc_transfer() : transfer is outside array");
    assert(USB_TRANSFER_PRESENT[ind], "usb_dealloc_transfer() : transfer is not present");
    assert(transfer->refcnt == 0x0, "usb_dealloc_transfer() : transfer still has references");

    //ok, dealloc transfer
    USB_TRANSFER_PRESENT[ind] = 0;
    transfer->~();
}


// -- BULK TRANSPORT --
//executes a bulk OUT (host -> device) transfer
//the given endpoint must be of type XHCI_ENDPOINT_TYPE_BULK_OUT
//buf must be a physical buffer
//on success, returns the number of bytes transferred, on failure returns -1
i64 usb_bulk_out(USB_device* dev, USB_endpoint* end, void* buf, u64 amt) {
    assert(end->endpoint_type == XHCI_ENDPOINT_TYPE_BULK_OUT, "usb_bulk_out() : wrong endpoint type");
    if(SCHEDULER_STARTED) { 
        //allocate USB transfer struct
        USB_transfer* transfer = usb_alloc_transfer();
        usb_transfer_inc_refcnt(transfer);
        transfer->dev = dev;
        transfer->slot = dev->slot;
        transfer->endpoint = end->endpoint;
        transfer->interrupter = XHCI_INTR0;
        transfer->amt = amt;
        
        //initiate transfer
        u64 trb_ptr = xhci_initiate_bulk_transfer(dev->slot, end->endpoint, XHCI_INTR0, buf, amt);
        transfer->trb_ptr = trb_ptr;

        //block process until transfer is done
        process* process = get_cur_proc();
        while(1) {
            if(transfer->is_done) break;
            wait_on(@(transfer->wait_queue));
        }

        //handle transfer
        i64 status = transfer->status;
        usb_transfer_dec_refcnt(transfer);

        return status;
    }
    else {
        //do synchronous transfer
        i64 retval = xhci_bulk_transfer(dev->slot, end->endpoint, XHCI_INTR0, buf, amt);
        return retval;
    }
}

//executes a bulk IN (device -> host) transfer 
//the given endpoint must be of type XHCI_ENDPOINT_TYPE_BULK_IN
//buf must be a physical buffer
//on success, returns the number of bytes transferred, on failure returns -1
i64 usb_bulk_in(USB_device* dev, USB_endpoint* end, void* buf, u64 amt) {
    assert(end->endpoint_type == XHCI_ENDPOINT_TYPE_BULK_IN, "usb_bulk_in() : wrong endpoint type");
    if(SCHEDULER_STARTED) {
        //allocate USB transfer struct
        USB_transfer* transfer = usb_alloc_transfer();
        usb_transfer_inc_refcnt(transfer);
        transfer->dev = dev;
        transfer->slot = dev->slot;
        transfer->endpoint = end->endpoint;
        transfer->interrupter = XHCI_INTR0;
        transfer->amt = amt;
        
        //initiate transfer
        u64 trb_ptr = xhci_initiate_bulk_transfer(dev->slot, end->endpoint, XHCI_INTR0, buf, amt);
        transfer->trb_ptr = trb_ptr;

        //block process until transfer is done
        process* process = get_cur_proc();
        while(1) {
            if(transfer->is_done) break;
            wait_on(@(transfer->wait_queue));
        }

        //handle transfer
        i64 status = transfer->status;
        usb_transfer_dec_refcnt(transfer);

        return status;
    }
    else {
        //do synchronous transfer
        i64 retval = xhci_bulk_transfer(dev->slot, end->endpoint, XHCI_INTR0, buf, amt);
        return retval;
    }
}


// -- MISC --
void usb_print_devtree() {
    usb_print_devtree(USB_ROOT_DEVICE, 0x0);
}

void usb_print_devtree(USB_device* dev, u64 depth) {
    for(u64 i = 0x0; i < depth; i++) print("    ");
    println(dev->desc_str);

    if(dev->is_hub) {
        for(u64 i = 0x1; i <= dev->nr_ports; i++) {
            if(!dev->child_present[i]) continue;
            usb_print_devtree(dev->children[i], depth + 0x1);
        }
    }
}


