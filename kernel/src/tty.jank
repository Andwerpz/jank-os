
//TTY : teletypwriter
//one kind of fd

//each tty should have one backend associated with it
//this usually represents some actual hardware, but it could also be emulated
//writes to tty get pushed through to the backend, and writes to backend get pushed through to tty
//accept_input is the way for tty and backend to recieve bytes from eachother

//for now, keyboard input gets manually sent here
[__GLOBAL_FIRST__] tty* active_tty = $tty* 0x0; 

struct tty_backend_ops {
    fn<i64(tty*, u8*, u64)> op_accept_input;
    fn<i32(tty*)> op_close;
}

[__GLOBAL_FIRST__] u64 TTY_NEXT_INO = 0x1;
struct tty {
    u64 ino;
    deque<u8> outq;                 //bytes ready to be sent to user program
    deque<u8> inq;                  //bytes waiting to be processed
    termios termios;                //tty settings
    void* backend;                  //hardware terminal / terminal emulator handle
    tty_backend_ops* backend_ops;       
    u64 refcount;                   //number of open file structs pointing here

    tty() {
        this.ino = TTY_NEXT_INO ++;
    }

    tty(tty& other) {
        panic("tty() : should not be using tty copy constructor");
    }
}

tty* tty_create_vga(vga_terminal* term) {
    tty* tty = $tty* malloc(sizeof(tty));
    new (tty) tty();
    tty->termios = tty_gen_default_termios();
    tty->backend = $void* term;
    tty->backend_ops = TTY_BACKEND_OPS_VGA;
    tty->refcount = 0x0;

    term->tty = tty;

    assert(active_tty == nullptr, "tty_create_vga() : for now, should only create one tty");
    active_tty = tty;

    return tty;
}

//default termios 
termios tty_gen_default_termios() {
    termios t = new termios();

    // zero everything first
    t.c_iflag = $u32 0;
    t.c_oflag = $u32 0;
    t.c_cflag = $u32 0;
    t.c_lflag = $u32 0;
    for (u64 i = 0x0; i < TTY_NCCS; i++) t.c_cc[i] = $u8 0;

    // --- input flags ---
    t.c_iflag |= $u32 TTY_ICRNL;    //map CR -> NL

    // --- output flags ---
    t.c_oflag |= $u32 TTY_OPOST;    //enable post-processing 
    t.c_oflag |= $u32 TTY_ONLCR;    //map NL -> CR NL

    // --- control flags ---

    // --- local flags ---
    t.c_lflag |= $u32 TTY_ICANON;   //enable line discipline
    t.c_lflag |= $u32 TTY_ECHO;     //echo characters back to backend
    t.c_lflag |= $u32 TTY_ECHOE;    //visually delete the last character typed on backspace

    // --- control chars ---
    t.c_cc[TTY_VERASE] = $u8 0x7F;      //set backspace char to be DEL

    return t;
}

//reads bytes from outq into buf
i64 tty_read(tty* tty, u8* buf, u64 amt) {
    assert(tty != nullptr, "tty_read() : this should not be null");

    //for debugging
    //poll serial port until out of bytes, feed through accept_input
    if(0) {   
        string serial_buf = new string();
        while(1) {
            i32 res = poll_serial();
            if(res < 0) break;
            assert(res >= 0 && res < 256, "tty_read() : checking if res is in range");
            serial_buf.push_back($u8 res);
        }
        u8* jstr = serial_buf.jstr();
        u64 bufptr = 0x0;
        while(bufptr < serial_buf.size()) {
            i64 ret = tty_accept_input(tty, @(jstr[bufptr]), serial_buf.size() - bufptr);
            if(ret < $i64 0) {
                panic("tty_read() : this thing should always work i hope D:");
            }
            bufptr += $u64 ret;
        }
        assert(bufptr == serial_buf.size(), "tty_read() : bufptr should be at end of buffer");
    }

    //read to buf from outq
    u64 ret = 0x0;
    for(u64 i = 0x0; i < amt; i++) {
        if(tty->outq.size() == 0x0) {
            break;
        }
        buf[i] = tty->outq.pop_front();
        ret ++;
    }

    if(ret == 0x0) {
        //try again later
        return $i64 -ERR_AGAIN;
    }
    return $i64 ret;
}

//writes to backend from buf, handles all output formatting
i64 tty_write(tty* tty, u8* buf, u64 amt) {
    assert(tty != nullptr, "tty_write() : this should not be null");

    if(!(tty->termios.c_oflag & $u32 TTY_OPOST)) {
        //skip output formatting
        return tty->backend_ops->op_accept_input#(tty, buf, amt);
    }   
    //output formatting
    //stream the bytes one by one
    u64 bytes_written = 0x0;
    for(u64 i = 0x0; i < amt; i++) {
        //generate formatted char
        u8 c = buf[i];
        u8* fmt = $u8* nullptr;
        if(c == '\n' && $i32 (tty->termios.c_oflag & $u32 TTY_ONLCR)) {
            fmt = "\r\n";
        }
        else {
            fmt = @c;
        }

        //write to backend
        assert($void* fmt != nullptr, "tty_write() : should be assigned by now");
        u64 fmt_sz = strlen(fmt);
        u64 fmt_ptr = 0x0;
        while(fmt_ptr < fmt_sz) {
            i64 stat = tty->backend_ops->op_accept_input#(tty, @(fmt[fmt_ptr]), fmt_sz - fmt_ptr);
            if(stat < $i64 0) {
                return stat;
            }
            fmt_ptr += $u64 stat;
        }
        assert(fmt_ptr == fmt_sz, "tty_write() : should be done writing here");
        bytes_written ++;
    }
    return $i64 bytes_written;
}

//writes to inq from buf, handles all input formatting, then if ready, writes to outq
i64 tty_accept_input(tty* tty, u8* buf, u64 amt) {
    assert(tty != nullptr, "tty_accept_input() : this should not be null");

    //stream bytes one by one into inq
    u64 bytes_written = 0x0;
    i32 icrnl = $i32 (tty->termios.c_iflag & $u32 TTY_ICRNL) != 0;
    i32 canonical = $i32 (tty->termios.c_lflag & $u32 TTY_ICANON) != 0;
    i32 echo = $i32 (tty->termios.c_lflag & $u32 TTY_ECHO) != 0;
    for(u64 i = 0x0; i < amt; i++) {
        i32 flush = 0;
        u8 c = buf[i];

        //map CR -> NL
        if(icrnl && c == '\r') {
            c = '\n';
        }

        //handle flush behaviour
        if(canonical) {
            //only flush on newline
            if(c == '\n') flush = 1;
        }
        else {
            //always flush on non-canonical mode
            flush = 1;
        }

        //handle pushing char to inq
        i32 erased = 0;
        if(canonical) {
            if(c == tty->termios.c_cc[TTY_VERASE]) {
                //backspace
                if(tty->inq.size() != 0x0) {
                    tty->inq.pop_back();
                    erased = 1;
                }
            }
            else {
                //push char to inq
                tty->inq.push_back(c);
            }
        }
        else {
            //no line editing
            tty->inq.push_back(c);
        }

        //handle echoing
        if(echo) {
            i32 echoe = $i32 (tty->termios.c_lflag & $u32 TTY_ECHOE);
            if(c == tty->termios.c_cc[TTY_VERASE] && echoe && erased) {
                //echo "\b \b" to visually erase
                if($u64 (tty->backend_ops->op_accept_input#(tty, "\b \b", 0x3)) != 0x3) {
                    panic("tty_accept_input() : this should succeed");
                }
            }
            else {
                //just echo normally
                if($u64 (tty->backend_ops->op_accept_input#(tty, @c, 0x1)) != 0x1) {
                    panic("tty_accept_input() : this should succeed");
                }
            }
        }

        //if we need to flush, move everything from inq to outq
        if(flush) {
            while(tty->inq.size() != 0x0) {
                tty->outq.push_back(tty->inq.pop_front());
            }
        }

        bytes_written ++;
    }

    return $i64 bytes_written;
}

i32 tty_set_termios(tty* tty, termios* in_termios) {
    memcpy($void* @(tty->termios), $void* in_termios, sizeof(termios));
    return 0;
}

i32 tty_get_termios(tty* tty, termios* out_termios) {
    memcpy($void* out_termios, $void* @(tty->termios), sizeof(termios));
    return 0;
}

i32 tty_close(tty* tty) {
    assert(tty->refcount != 0x0, "tty_close() : tty with 0 references should already be dealloced");
    tty->refcount --;
    i32 retval = 0;
    if(tty->refcount == 0x0) {
        retval = tty->backend_ops->op_close#(tty);
        tty->~();
        free($void* tty, sizeof(tty));
    }
    return retval;
}


[__GLOBAL_FIRST__] file_ops* FILE_OPS_TTY;
void init_tty_file_ops() {
    FILE_OPS_TTY = $file_ops* malloc(sizeof(file_ops));
    new (FILE_OPS_TTY) file_ops();
    FILE_OPS_TTY->op_read = #<tty_read(file*, u8*, u64)>;
    FILE_OPS_TTY->op_write = #<tty_write(file*, u8*, u64)>;
    FILE_OPS_TTY->op_lseek = #<tty_lseek(file*, i64, i32)>;
    FILE_OPS_TTY->op_getdents = #<tty_getdents(file*, u8*, u64)>;
    FILE_OPS_TTY->op_close = #<tty_close(file*)>;
    FILE_OPS_TTY->op_truncate = #<tty_truncate(file*, u64)>;
    FILE_OPS_TTY->op_fstat = #<tty_fstat(file*, stat*)>;
}

i64 tty_read(file* fd, u8* buf, u64 amt) {
    assert(fd->type == FILE_TYPE_TTY, "tty_read() : mismatching type");
    assert(fd->resource_ptr != nullptr, "tty_read() : resource must be not null");
    tty* tty = $tty* fd->resource_ptr;
    return tty_read(tty, buf, amt);
}

i64 tty_write(file* fd, u8* buf, u64 amt) {
    assert(fd->type == FILE_TYPE_TTY, "tty_write() : mismatching type");
    assert(fd->resource_ptr != nullptr, "tty_write() : resource must be not null");
    tty* tty = $tty* fd->resource_ptr;
    return tty_write(tty, buf, amt);
}

i64 tty_lseek(file* fd, i64 off, i32 whence) {
    //lseek doesn't make sense
    return $i64 -1;
}

i64 tty_getdents(file* fd, u8* buf, u64 amt) {
    //getdents doesn't make sense
    return $i64 -1;
}

i32 tty_close(file* fd){ 
    assert(fd->type == FILE_TYPE_TTY, "tty_close() : mismatching type");
    assert(fd->resource_ptr != nullptr, "tty_close() : resource must be not null");
    tty* tty = $tty* fd->resource_ptr;
    return tty_close(tty);
}

i32 tty_truncate(file* fd, u64 nsz) {
    //truncate doesn't make sense
    return $i32 -1; 
}

i32 tty_fstat(file* file, stat* stat) {
    tty* tty = $tty* file->resource_ptr;

    //clear stat
    memset($void* stat, 0, sizeof(stat));

    //fill stat
    stat->st_dev = FILE_TTY_DEV;
    stat->st_ino = tty->ino;
    stat->st_nlink = 0x0;

    stat->st_mode = S_IFCHR;

    stat->st_rdev = 0x0;
    stat->st_size = $i64 0x0;
    stat->st_blksize = $i64 PAGE_SIZE;
    stat->st_blocks = $i64 0x0;

    return 0;
}


void init_tty() {
    init_vga_tty_backend_ops();
    init_serial_tty_backend_ops();
}
