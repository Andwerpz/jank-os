#include <string>;

[__GLOBAL_FIRST__] u16 COM1 = $u16 0x3f8;

[PRINTSTREAM] printstream cout = new printstream();

struct printstream {}

printstream& operator<<(printstream& stream, u8* s) {
    print(s);
    return stream;
}

printstream& operator<<(printstream& stream, u8 c) {
    print(c);
    return stream;
}

printstream& operator<<(printstream& stream, i64 x) {
    print(x);
    return stream;
}

printstream& operator<<(printstream& stream, i32 x) {
    print(x);
    return stream;
}

printstream& operator<<(printstream& stream, u64 x) {
    print(x);
    return stream;
}

printstream& operator<<(printstream& stream, u32 x) {
    print(x);
    return stream;
}

printstream& operator<<(printstream& stream, u16 x) {
    print(x);
    return stream;
}

printstream& operator<<(printstream& stream, string& s) {
    print(s);
    return stream;
}

printstream& operator<<(printstream& stream, string s) {
    print(s);
    return stream;
}

template<T>
printstream& operator<<(printstream& stream, T* p) {
    print(p);
    return stream;
}

i32 init_serial() {
    outb(COM1 + $u16 1, $u8 0x00);    // Disable all interrupts
    outb(COM1 + $u16 3, $u8 0x80);    // Enable DLAB (set baud rate divisor)
    outb(COM1 + $u16 0, $u8 0x03);    // Set divisor to 3 (lo byte) 38400 baud
    outb(COM1 + $u16 1, $u8 0x00);    //                  (hi byte)
    outb(COM1 + $u16 3, $u8 0x03);    // 8 bits, no parity, one stop bit
    outb(COM1 + $u16 2, $u8 0xc7);    // Enable FIFO, clear them, with 14-byte threshold
    outb(COM1 + $u16 4, $u8 0x0b);    // IRQs enabled, RTS/DSR set
    outb(COM1 + $u16 4, $u8 0x1e);    // Set in loopback mode, test the serial chip
    outb(COM1 + $u16 0, $u8 0xae);    // Test serial chip (send byte 0xAE and check if serial returns same byte)

    // Check if serial is faulty (i.e: not same byte as sent)
    if(inb(COM1 + $u16 0) != $u8 0xae) {
        return $i32 1;
    }

    // If serial is not faulty set it in normal operation mode
    // (not-loopback with IRQs enabled and OUT#1 and OUT#2 bits enabled)
    outb(COM1 + $u16 4, $u8 0x0f);

    return $i32 0;
}

u8 is_transmit_empty() {
    return inb(COM1 + $u16 5) & $u8 0x20;
}

u8 serial_received() {
    return inb(COM1 + $u16 5) & $u8 1;
}

//blocking read
u8 read_serial() {
    while(serial_received() == $u8 0) {}
    u8 c = inb(COM1);
    return c;
}

//non-blocking read
i32 poll_serial() {
    if(serial_received() != $u8 0) {
        u8 c = inb(COM1);
        return $i32 c;
    }
    return -1;
}

void write_serial(u8 a) {
    if(a == '\n') {
        while(is_transmit_empty() == $u8 0) {}
        outb(COM1, '\r');
    }
    while(is_transmit_empty() == $u8 0) {}
    outb(COM1, a);
}

[__GLOBAL_FIRST__] file_ops* FILE_OPS_SERIAL;
void init_serial_file_ops() {
    FILE_OPS_SERIAL = $file_ops* malloc(sizeof(file_ops));
    new (FILE_OPS_SERIAL) file_ops();
    FILE_OPS_SERIAL->op_read = #<serial_read(file*, u8*, u64)>;
    FILE_OPS_SERIAL->op_write = #<serial_write(file*, u8*, u64)>;
    FILE_OPS_SERIAL->op_lseek = #<serial_lseek(file*, i64, i32)>;
    FILE_OPS_SERIAL->op_getdents = #<serial_getdents(file*, u8*, u64)>;
    FILE_OPS_SERIAL->op_close = #<serial_close(file*)>;
    FILE_OPS_SERIAL->op_truncate = #<serial_truncate(file*, u64)>;
    FILE_OPS_SERIAL->op_fstat = #<serial_fstat(file*, stat*)>;
    FILE_OPS_SERIAL->op_poll = #<serial_poll(file*)>;
}

// POLL FILL IN
u16 serial_poll(file* f) {
    return $u16 0;
}

i64 serial_read(file* fd, u8* buf, u64 amt) {
    u64 buf_ptr = 0x0;
    while(buf_ptr < amt) {
        i32 res = poll_serial();
        if(res < 0) break;
        assert(res >= 0 && res < 256, "serial_read() : checking if res is in range");
        buf[buf_ptr ++] = $u8 res;
    }
    if(buf_ptr == 0x0) {
        //try again later
        return $i64 -ERR_AGAIN;
    }
    return $i64 buf_ptr;
}

i64 serial_write(file* fd, u8* buf, u64 amt) {
    for(u64 i = 0x0; i < amt; i++) write_serial(buf[i]);
    return $i64 amt;
}

i64 serial_lseek(file* fd, i64 off, i32 whence) {
    //lseek doesn't make sense for serial input
    return $i64 -1;
}

i64 serial_getdents(file* fd, u8* buf, u64 amt) {
    //getdents doesn't make sense for serial input
    return $i64 -1;
}

i32 serial_close(file* fd) {
    //do nothing
    return 0;
}

i32 serial_truncate(file* fd, u64 nsz) {
    //truncate doesn't make sense for serial input
    return -1;
}

i32 serial_fstat(file* file, stat* stat) {
    return -1;  //TODO
}


[__GLOBAL_FIRST__] tty_backend_ops* TTY_BACKEND_OPS_SERIAL;
void init_serial_tty_backend_ops() {
    TTY_BACKEND_OPS_SERIAL = $tty_backend_ops* malloc(sizeof(tty_backend_ops));
    new (TTY_BACKEND_OPS_SERIAL) tty_backend_ops();
    TTY_BACKEND_OPS_SERIAL->op_accept_input = #<serial_accept_input(tty*, u8*, u64)>;
    TTY_BACKEND_OPS_SERIAL->op_close = #<serial_close(tty*)>;
}

i64 serial_accept_input(tty* tty, u8* buf, u64 amt) {
    for(u64 i = 0x0; i < amt; i++) write_serial(buf[i]);
    return $i64 amt;
}

i32 serial_close(tty* tty) {
    //do nothing
    return 0;
}
