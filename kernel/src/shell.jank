#include <string>;
#include <vector>;
#include <jstring>;

struct file {
    string name;
    u8* buf;
    u64 size;

    file(file& other) {
        this.name = other.name;
        this.buf = $u8* malloc(other.size);
        memcpy($void* this.buf, $void* other.buf, other.size);
        this.size = other.size;
    }

    ~file() {
        free($void* this.buf, this.size);
    }
}

process* curr_process;

void shell() {
    vector<file> files;
    while(1) {
        sout << "jankshell> ";
        vector<string> cmd = sin.next_line().split(' ');
        if(cmd.size() == 0x0) continue;

        if(cmd[0] == "exit") {
            break;
        }
        else if(cmd[0] == "load") {
            while(1) {
                if(cmd.size() < 0x4) {
                    sout << "Usage : load <file_name> <file_len_bytes> <hex_encoded_file>\n";
                    break;
                }

                errno = 0;
                u64 file_len = stou64(cmd[2]);
                if(errno) {
                    sout << "file_len malformed\n";
                    break;
                }

                string encoded_file = cmd[3];
                if(encoded_file.size() != file_len * 0x2) {
                    sout << "encoded file length must be exactly twice file_len\n";
                    break;
                }

                i32 encoding_valid = 1;
                u8* buf = $u8* malloc(file_len);
                u8 checksum = $u8 0;
                for(u64 i = 0x0; i < file_len; i++) {
                    u8 fb = encoded_file[i * 0x2 + 0x0];
                    u8 sb = encoded_file[i * 0x2 + 0x1];
                    if('0' <= fb && fb <= '9') fb -= '0';
                    else if('a' <= fb && fb <= 'f') fb = fb - 'a' + $u8 10;
                    else encoding_valid = 0;
                    if('0' <= sb && sb <= '9') sb -= '0';
                    else if('a' <= sb && sb <= 'f') sb = sb - 'a' + $u8 10;
                    else encoding_valid = 0;

                    u8 c = (fb << $u8 4) + sb;
                    buf[i] = c;
                    checksum ^= c;
                }
                if(!encoding_valid) {
                    sout << "encoding is not valid\n";
                    free($void* buf, file_len);
                    break;
                }

                file f;
                f.name = cmd[1];
                f.buf = buf;
                f.size = file_len;

                files.push_back(f);
                sout << "Created and added new file: \n";
                sout << "checksum : " << $u64 checksum << "\n";
                describe_file(f, 1);

                break;
            }
        }
        else if(cmd[0] == "list_files") {
            sout << "File cnt : " << files.size() << "\n";
            for(u64 i = 0x0; i < files.size(); i++){
                sout << "-- " << i << " --" << "\n";
                describe_file(files[i], 0);
                sout << "\n";
            }
        }
        else if(cmd[0] == "schedule") {
            while(1) {
                if(cmd.size() < 0x2) {
                    sout << "Usage : schedule <file_ind>\n";
                    break;
                }

                errno = 0;
                u64 ind = stou64(cmd[1]);
                if(errno) {
                    sout << "file_ind malformed\n";
                    break;
                }

                //initialize process
                file& f = files[ind];
                process* proc = create_process(f.buf, f.size);
                sout << "PROC ADDR : " << proc << "\n";

                //point %rsp to top of kernel stack
                asm!("mov BOOTBOOT_STACK_TOP(%rip), %rsp");

                //startup the scheduler
                scheduler();
            }
        }
        else {
            sout << "Unknown command\n";
        }
    }
}

void describe_file(file& f, i32 print_content) {
    sout << "Name : " << f.name << "\n";
    sout << "Size : " << f.size << "\n";
    if(print_content) {
        sout << "Content : \n";
        for(u64 i = $u64 0; i < f.size; i++) {
            sout << f.buf[i];
        }
        sout << "\n";
    }
}
