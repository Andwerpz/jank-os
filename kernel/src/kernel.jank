#include <math>;
#include <string>;
#include <jstring>;
#include <vector>;
#include <deque>;

#include "memlayout.jank";
#include "panic.jank";
#include "serial.jank";
#include "vga.jank";
#include "pma.jank";
#include "pagetable.jank";
#include "kmalloc.jank";
#include "globals.jank";
#include "elf.jank";
#include "gdt.jank";
#include "syscall.jank";
#include "utils.jank";
#include "idt.jank";
#include "scheduler.jank";
#include "pic.jank";
#include "file.jank";
#include "process.jank";
#include "ext2fs.jank";
#include "acpi.jank";
#include "mutex.jank";
#include "vfs.jank";
#include "pipe.jank";
#include "tty.jank";
#include "blockdev.jank";
#include "ahci.jank";
#include "mbr.jank";
#include "ps2.jank";
#include "kb.jank";
#include "usb/xhci.jank";
#include "usb/usb.jank";
#include "usb/bot.jank";
#include "usb/scsi.jank";

[SERIAL] i32 INIT_SERIAL_STATUS = init_serial();
[PMA] i32 INIT_PMA_STATUS = init_pma();
[GDT] i32 INIT_GDT_STATUS = init_gdt();
[IDT] i32 INIT_IDT_STATUS = init_idt();
[PAGING] i32 INIT_PAGING_STATUS = init_paging();
[SYSCALL] i32 INIT_SYSCALL_STATUS = init_syscall();
[PIC] i32 INIT_PIC_STATUS = init_pic();

void check_paging_enabled() {
    u64 cr0;
    asm!("mov %cr0, %rax");
    asm!("mov %rax, {cr0}");
    if(cr0 & ($u64 1 << $u64 31)) println("paging enabled");
    else println("paging disabled");
}   

void check_syscall_enabled() {
    u64 x;
    asm!("mov $0x80000001, %eax");
    asm!("cpuid");
    asm!("mov %edx, {x}");
    assert(x & $u64 (1 << 11), "syscall instruction should be supported");
}

void mem_touch(u64 low, u64 high) {
    print("TOUCHING : ");
    print($void* low);
    print(" ");
    println($void* high);
    u8* mem = $u8* $u64 0;
    for(u64 i = low; i < high; i++){
        mem[i];
    }
    println("done touching");
}

void print_mmap() {
    MMapEnt* mmap = $MMapEnt* @(bootinfo->mmap);
    for(u64 i = 0x0; i < $u64 bootinfo->mmap_entries; i++) {
        u64 base = mmap->base;
        u64 size = mmap->size;
        u64 type = $u64 mmap->type;

        print("base : ", $void* base);
        print(", size : ", $void* size);
        println(", type : ", $void* type);

        mmap = $MMapEnt* ($u64 mmap + $u64 sizeof(MMapEnt));
    }
}

void tests() {
    check_syscall_enabled();

    if(1) {
        print_mmap();
    }

    if(1) {
        pagetable_t kernel_pt = pt_get_current();
        void* fb_phys = pt_translate(kernel_pt, $void* BOOTBOOT_FB);
        print("FB PHYS : ");
        println(fb_phys);
        void* info_phys = pt_translate(kernel_pt, $void* BOOTBOOT_INFO);
        print("INFO PHYS : ");
        println(info_phys);
    }
    
    if(0) {
        u64 tlow  = 0x0000000007fe0000;
        u64 thigh = 0x0000000007fe0000;

        pagetable_t kernel_pt = pt_get_current();
        print("kernel pt addr : ");
        println(kernel_pt);

        assert(pt_is_vaddr_mapped(kernel_pt, $void* 0x10000), "bruh");

        mem_touch(tlow, thigh);
    }

    //check if we can map new pages
    if(0) {
        pagetable_t kernel_pt = pt_get_current();
        u64 low  = 0x0000000100000000;
        u64 high = 0x0000000100100000;
        for(u64 i = low; i < high; i += PAGE_SIZE) {
            print("MAP : ");
            println($void* i);
            pt_map_page(kernel_pt, $void* i, $void* (i - low), PTE_WRITEABLE);
        }
        mem_touch(low, high);
        for(u64 i = low; i < high; i += PAGE_SIZE) {
            pt_unmap_page(kernel_pt, $void* i);
        }
        //mem_touch(low, high); //this should pagefault
    }

    //check if malloc works 
    if(1) {
        for(i32 i = 0; i < 10; i++){
            println(i);
        }

        i32 N = 10;
        i32** dp = $i32** malloc($u64 N * sizeof(i32*));
        for(i32 i = 0; i < N; i = i + 1) dp[i] = $i32* malloc($u64 N * sizeof(i32));
        dp[0][0] = 1;
        for(i32 i = 0; i < N; i = i + 1) {
            for(i32 j = 0; j < N; j = j + 1) {
                if(i == 0 && j == 0) continue;
                dp[i][j] = 0;
                if(i != 0) dp[i][j] = dp[i][j] + dp[i - 1][j];
                if(j != 0) dp[i][j] = dp[i][j] + dp[i][j - 1];
            }
        }
        for(i32 i = 0; i < N; i = i + 1) {
            for(i32 j = 0; j < N; j = j + 1) {
                print(dp[i][j]);
                print(" ");
            }
            print("\n");
        }

        print("KHEAP PTR : ");
        println($void* kheap_brk);
    }
}

void shutdown_qemu() {
    //qemu shutdown signal
    outw($u16 0x604, $u16 0x2000);
    panic("shutdown failed");
}   

void vfs_tests() {
    cout << "=== PRINTING FS TREE ===\n";
    vfs_print_tree(new string("/"));

    cout << "=== READ SHELL.JANK ===\n";
    while(1) {
        string path = new string("/sys/shell.jank");
        u64 size;
        if(vfs_get_size(path, size)) {
            cout << "get_size failed\n";
            break;
        }
        cout << "GET SIZE SUCCESS\n";
        cout << "FILE SIZE : " << size << "\n";
        //read file in small chunks
        u64 chunk = $u64 17;
        u8* buf = $u8* malloc(chunk + 0x1);
        u64 ptr = 0x0;
        while(ptr != size) {
            u64 read_amt;
            if(vfs_read_file(path, buf, chunk, ptr, read_amt)) {
                cout << "\nfile read failed\n";
                break;
            }
            ptr += read_amt;
            buf[read_amt] = '\0';
            cout << buf;
            // cout << "PTR : " << ptr << " " << read_amt << "\n";
        }
        cout << "\n";
        free($void* buf, chunk + 0x1);

        break;
    }
}

//manually triggers a general protection fault
void gp_handler_test() {
    u8* bad_addr = $u8* 0x0f00000000000000; //non-canonical address
    bad_addr[0] = 'a';
    panic("gp_handler_test() : should not be here");
}

//scans through all block devices and mounts the first ext2 filesystem it finds to root
void blockdev_mount_ext2() {
    for(u64 i = 0x0; i < BLOCKDEV_BUF_CNT; i++) {
        blockdev* dev = @(BLOCKDEV_BUF[i]);
        if(dev->partition_type == MBR_PARTITION_TYPE_EXT2) {
            ext2_fs* fs = $ext2_fs* malloc(sizeof(ext2_fs));
            if(!ext2_probe(dev, fs)) {
                println("found ext2 filesystem");
                vfs_mount(new string("/"), $void* fs, VFS_EXT2_OPS);
                return;
            }
            free($void* fs, sizeof(ext2_fs));
        }
    }
    panic("failed to find ext2 filesystem");
}

i32 main() {
    init_kb();
    init_acpi();
    init_ps2();
    init_file();
    init_tty();
    init_vfs();
    init_blockdev();

    init_usb();

    blockdev_mount_ext2();

    // cout << "PRINTING PAGETABLES :\n";
    // pagetable_t kernel_pt = pt_get_current();
    // pt_print(kernel_pt, 3, 0);

    // cout << "MMAP : \n";
    // print_mmap();

    vga_clear_screen(COLOR_BLACK);

    // vfs_tests();

    // gp_handler_test();

    // shutdown_qemu();
    // kernel_shell();

    //tests();    

    init_scheduler();

    //shouldn't get here
    panic("init scheduler failed");
    
    return 0;
}
